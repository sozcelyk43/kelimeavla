<!DOCTYPE html>
<html lang="tr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Kelime Avı - Tam Sürüm</title>
	<script src="libs/react.production.min.js"></script>
	<script src="libs/react-dom.production.min.js"></script>
	<script src="libs/lodash.min.js"></script>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="libs/confetti.browser.min.js"></script>
	<script src="https://unpkg.com/heroicons@2.1.3/24/outline/index.js"></script>
	<script src="libs/firebase-app.js"></script>
	<script src="libs/firebase-firestore.js"></script>
	<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
	<script src="libs/babel.min.js"></script>
	<script src="wordstr.js"></script>
	<script src="words_tr_2letters.js"></script>
	<script src="wordsen.js"></script>
<style>
	body {overscroll-behavior-y: none;-webkit-user-select: none;user-select: none;height: 100vh;font-family: 'Inter', sans-serif;background-color: #f3f4f6;    }
	body.no-scroll {overflow: hidden;touch-action: none;}
    	body.no-scroll #root {overflow: hidden;}
    .grid { -webkit-tap-highlight-color: transparent; }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    .scrollbar-thin { scrollbar-width: thin; scrollbar-color: #9CA3AF #E5E7EB; }
    .scrollbar-thin::-webkit-scrollbar { width: 5px; }
    .scrollbar-thin::-webkit-scrollbar-track { background: #E5E7EB; border-radius: 10px;}
    .scrollbar-thin::-webkit-scrollbar-thumb { background-color: #9CA3AF; border-radius: 10px; border: 1px solid #E5E7EB; }
    .shake-animation {  animation: shake 0.3s ease-in-out;}
    .toast-notification { animation: toast-in-out 4s forwards; }
    .hidden-word-start-letter { color: #0d6efd !important; font-weight: 900; }
    .animate-hint-pulse {animation: pulse-hint 1.5s infinite ease-in-out;color: #713f12 !important;font-weight: 900;}
    .animate-word-found { animation: word-found-animation 0.6s ease-out; }

    @keyframes word-found-animation {
    0% { transform: scale(1); background-color: #6ee7b7; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
    50% { transform: scale(1.1); background-color: #34d399; box-shadow: 0 0 15px 5px rgba(16, 185, 129, 0.5); }
    100% { transform: scale(1); background-color: #6ee7b7; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }	}
    .animate-bonus-glow {animation: bonus-double-glow-animation 1.2s ease-out;}

    @keyframes bonus-double-glow-animation {    0% {        transform: scale(1);    }
    25% {        transform: scale(1.15);        background-color: #fde047;        box-shadow: 0 0 15px #facc15;    }
    50% {        transform: scale(1);    }
    75% {        transform: scale(1.15);        background-color: #fde047;         box-shadow: 0 0 15px #facc15;    }
    100% {       transform: scale(1);    }    }	

	.animate-timer-pulse {
	animation: pulse-timer 0.5s ease-out;}

    @keyframes pulse-timer {      0% { transform: scale(1); }
      40% { transform: scale(1.15); color: #ef4444; }
      100% { transform: scale(1); }}

    @keyframes toast-in-out {
    0% { transform: translateY(100%); opacity: 0; }
    15% { transform: translateY(0); opacity: 1; }
    85% { transform: translateY(0); opacity: 1; }
    100% { transform: translateY(100%); opacity: 0; }}

    @keyframes shake {
    0% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    50% { transform: translateX(5px); }
    75% { transform: translateX(-5px); }
    100% { transform: translateX(0); }}

    @keyframes pulse-hint {  0%, 100% { background-color: #fef08a; transform: scale(1); }50% { background-color: #fde047; 	transform: scale(1.05); box-shadow: 0 0 8px #facc15; } }
	</style>
</head>

<body class="h-[100vh] flex flex-col">
<div id="root" class="flex-1"></div>
<audio id="correctSound" preload="auto" src="sounds/correct.mp3">Tarayıcınız ses etiketini desteklemiyor.</audio>
<audio id="wrongSound" preload="auto" src="sounds/wrong.mp3">Tarayıcınız ses etiketini desteklemiyor.</audio>
<audio id="achievementSound" preload="auto" src="sounds/achievement.mp3">Tarayıcınız ses etiketini desteklemiyor.</audio>

<script type="text/babel">

function initializeGame() {
                if (window.firebase && window._ && window.React && window.ReactDOM) {
                    runApp();
                } else {
                    console.log("Waiting for libraries...");
                    setTimeout(initializeGame, 100);
                }
            }


const ModernModeCard = ({ title, icon, bgColor, className, onClick, disabled, userInfo, buttonText = "Oyna" }) => 
	{const handleClick = () => {
        if (!disabled) {onClick();}};

    return (
        <div
            onClick={handleClick}
            role="button" // Erişilebilirlik için bunun bir buton olduğunu belirtiyoruz
            tabIndex={disabled ? -1 : 0} // Klavyeyle erişim için
            className={`relative group w-full rounded-2xl text-white overflow-hidden transition-opacity duration-200 border border-white/20 will-change-transform ${bgColor} ${className} ${disabled ? 'opacity-60 cursor-not-allowed' : 'cursor-pointer'}`}
        >
            <div className="absolute -right-2 -bottom-2 text-8xl opacity-40 drop-shadow-lg">
                {icon}
            </div>

            {userInfo && userInfo.username && (
                <div className="absolute bottom-2 right-3 bg-black/30 backdrop-blur-sm text-white text-[10px] font-bold px-2 py-0.5 rounded-full flex items-center gap-1">
                    <div className={`w-1.5 h-1.5 ${userInfo.status === 'Çevrimiçi' ? 'bg-green-400' : 'bg-gray-400'} rounded-full`}></div>
                    {userInfo.username}
                </div>
            )}

            <div className="p-3 h-full flex flex-col justify-between text-left pointer-events-none">
                <h3 className="text-lg font-bold leading-tight">{title}</h3>
                <div className={`mt-2 self-start bg-white/20 backdrop-blur-sm text-white text-xs font-bold uppercase tracking-wider rounded-full px-4 py-1.5 flex items-center gap-2`}>
                    <span>{disabled ? '...' : buttonText}</span>
                    {!disabled && <span>→</span>}
                </div>
            </div>
        </div>
    );
};

const availableAvatars = [
    { id: 'avatar1', url: 'avatars/avatar1.png' },
    { id: 'avatar2', url: 'avatars/avatar2.png' },
    { id: 'avatar3', url: 'avatars/avatar3.png' },
    { id: 'avatar4', url: 'avatars/avatar4.png' },
    { id: 'avatar5', url: 'avatars/avatar5.png' },
    { id: 'avatar6', url: 'avatars/avatar6.png' },
    { id: 'avatar7', url: 'avatars/avatar7.png' },
    { id: 'avatar8', url: 'avatars/avatar8.png' },
    { id: 'avatar9', url: 'avatars/avatar9.png' },
    { id: 'avatar10', url: 'avatars/avatar10.png' },
    { id: 'avatar11', url: 'avatars/avatar11.png' },
    { id: 'avatar12', url: 'avatars/avatar12.png' },
    { id: 'avatar13', url: 'avatars/avatar13.png' },
    { id: 'avatar14', url: 'avatars/avatar14.png' },
    { id: 'avatar15', url: 'avatars/avatar15.png' },
    { id: 'avatar16', url: 'avatars/avatar16.png' }
 
];

function AvatarSelectionModal({ isOpen, onClose, onAvatarSelect }) {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div 
                className="bg-gradient-to-br from-slate-50 to-gray-100 p-6 rounded-2xl shadow-2xl w-full max-w-md text-center flex flex-col max-h-[85vh] border border-gray-200" 
                onClick={e => e.stopPropagation()}
            >
                {/* --- BAŞLIK BURADA GÜNCELLENDİ --- */}
                <h3 className="text-3xl font-black mb-6 text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 flex-shrink-0">
                    Avatarını Seç
                </h3>
                
                <div className="overflow-y-auto scrollbar-thin flex-1 pr-2 -mr-2">
                    <div className="grid grid-cols-3 sm:grid-cols-4 gap-4">
                        {availableAvatars.map(avatar => (
                            <div key={avatar.id} onClick={() => onAvatarSelect(avatar.id)} className="cursor-pointer group flex flex-col items-center">
                                <img 
                                    src={avatar.url} 
                                    alt={avatar.id} 
                                    className="w-20 h-20 rounded-full object-cover bg-gray-200 border-4 border-transparent group-hover:border-indigo-500 group-hover:scale-110 group-hover:shadow-lg transition-all duration-200"
                                />
                            </div>
                        ))}
                    </div>
                </div>
                 
                <button 
                    onClick={onClose} 
                    className="mt-8 bg-slate-200 text-slate-800 font-bold py-2 px-8 rounded-lg hover:bg-slate-300 transition-all flex-shrink-0 shadow-sm"
                >
                    Kapat
                </button>
            </div>
        </div>
    );
}


function FriendsPage({ username, onInvite, onBack, db }) {
    const [players, setPlayers] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [invitedFriends, setInvitedFriends] = React.useState([]);

    React.useEffect(() => {
        const fetchUsersAndStatus = async () => {
            try {
                const lobbyQuery = await db.collection('lobby').get();
                const onlineUsernames = lobbyQuery.docs.map(doc => doc.id);

                const usersQuery = await db.collection('users').get();
                const allUsers = usersQuery.docs.map(doc => {
                    const docData = doc.data(); // Kullanıcının tüm verisini al
                    const docId = doc.id;
                    const status = onlineUsernames.includes(docId) ? 'Çevrimiçi' : 'Çevrimdışı';
                    
                    return { 
                        username: docId, 
                        status: status,
                        avatarId: docData.avatarId || null // avatarId'yi al, yoksa null ata
                    };
                }).filter(user => user.username !== username);

                setPlayers(allUsers);
            } catch (error) {
                console.error("Kullanıcılar çekilirken hata oluştu:", error);
            } finally {
                setLoading(false);
            }
        };

        if (db) fetchUsersAndStatus();
    }, [username, db]);

    const handleInvite = (targetPlayer) => {
        onInvite(targetPlayer);
        setInvitedFriends([...invitedFriends, targetPlayer.username]);
    };

    if (loading) {
        return <div className="flex items-center justify-center h-full text-lg">Oyuncu listesi yükleniyor...</div>;
    }

    return (
        <div className="h-full w-full bg-slate-100 flex flex-col">
            <div className="container mx-auto px-4 pt-3 text-center flex flex-col flex-1">
                <header className="my-2 flex-shrink-0 flex items-center justify-between">
                    <h1 className="text-3xl font-black text-slate-700">Oyuncu Seç</h1>
                    <button onClick={onBack} className="bg-white border border-slate-200 text-slate-600 px-4 py-2 rounded-lg font-semibold">Geri</button>
                </header>
                <div className="flex-1 min-h-0 overflow-y-auto scrollbar-thin py-4">
                    <div className="w-full max-w-md mx-auto grid grid-cols-2 auto-rows-fr gap-3">
                        {players.map(player => {
			const isInvited = invitedFriends.includes(player.username);
			const playerIcon = player.avatarId ? (
                                <img 
                                    src={`avatars/${player.avatarId}.png`} 
                                    alt={player.username}
                                    className="w-20 h-20 rounded-full object-cover opacity-100" 
                                />
                            ) : (
                                "👤" 
                            );

                            return (
                                <ModernModeCard
                                    key={player.username}
                                    title={player.username}
                                    icon={playerIcon} // <-- ikonu dinamik olarak buraya iletiyoruz
                                    bgColor={player.status === 'Çevrimiçi' ? "bg-gradient-to-br from-green-500 to-teal-600" : "bg-gradient-to-br from-slate-500 to-gray-700"}
                                    className="h-26"
                                    onClick={() => handleInvite(player)}
                                    disabled={isInvited}
                                    userInfo={{username: '', status: player.status}}
                                    buttonText={isInvited ? "Gönderildi" : "Davet Et"}
                                />
                            );
                        })}
                    </div>
                </div>
            </div>
        </div>
    );
}
function InvitationModal({ isOpen, invitationDetails, onAccept, onDecline }) {
    if (!isOpen || !invitationDetails) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
            <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-sm text-center transform transition-all animate-pulse-once">
                <h3 className="text-3xl font-bold mb-2 text-gray-800">⚔️ Düello Daveti ⚔️</h3>
                <p className="text-gray-600 text-lg mb-6">
                    <span className="font-bold text-indigo-600">{invitationDetails.invitedBy}</span> sizi bir düelloya davet ediyor!
                </p>
                <div className="flex justify-center gap-4 mt-4">
                    <button
                        onClick={onDecline}
                        className="px-8 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-all transform hover:scale-105 shadow-lg">
                        Reddet
                    </button>
                    <button
                        onClick={onAccept}
                        className="px-8 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition-all transform hover:scale-105 shadow-lg">
                        Kabul Et
                    </button>
                </div>
            </div>
        </div>
    );
}

function runApp() {
            const servers = {
                  iceServers: [
                    {
                      urls: [
                        'stun:stun1.l.google.com:19302',
                        'stun:stun2.l.google.com:19302',
                      ],
                    },
                  ],
                  iceCandidatePoolSize: 10,
                };

                let peerConnection = null;
                let dataChannel = null;

                const firebaseConfig = {
                  apiKey: "AIzaSyC9qRRHO-m3e_2Kfs14wxxjsovhrE3idXs",
                  authDomain: "kelime-avla.firebaseapp.com",
                  projectId: "kelime-avla",
                  storageBucket: "kelime-avla.firebasestorage.app",
                  messagingSenderId: "557108031682",
                  appId: "1:557108031682:web:a0738215100b2c6b864b5b",
                  measurementId: "G-XYCB5BS8SR"
                };

                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                }
                const db = firebase.firestore();
                const ALL_SAVES_KEY = 'wordHuntAllSaves';

                window.onerror = function (msg, url, lineNo, columnNo, error) { console.error(`Global error: ${msg}\nURL: ${url}\nLine: ${lineNo}\nColumn: ${columnNo}\nError:`, error); const root = document.getElementById('root'); if (root) root.innerHTML = `<div class="p-4 text-red-600">Beklenmedik bir hata oluştu. Lütfen sayfayı yenileyin. Hata: ${msg}</div>`; return false; };
                function customToUpperCase(str) { if (typeof str !== 'string') return ''; try { return str.replace(/i/g, 'İ').replace(/ı/g, 'I').replace(/ğ/g, 'Ğ').replace(/ü/g, 'Ü').replace(/ş/g, 'Ş').replace(/ö/g, 'Ö').replace(/ç/g, 'Ç').toUpperCase(); } catch (err) { console.error('customToUpperCase hatası:', err); return (str || '').toUpperCase(); } }
                class ErrorBoundary extends React.Component { state = { hasError: false }; static getDerivedStateFromError(error) { return { hasError: true }; } componentDidCatch(error, errorInfo) { console.error("ErrorBoundary yakaladı:", error, errorInfo); } render() { if (this.state.hasError) { return <div className="p-4 text-red-600">Beklenmedik bir hata oluştu. Lütfen sayfayı yenileyin.</div>; } return this.props.children; } }

                const vibrate = (pattern) => { if ('vibrate' in navigator) { if (pattern === 'success') navigator.vibrate(50); else if (pattern === 'error') navigator.vibrate([100, 50, 100]); else if (pattern === 'achievement') navigator.vibrate([100, 50, 100, 50, 100]); else if (typeof pattern === 'number') navigator.vibrate(pattern); } };

            const achievementsList = {
                'level_10': {icon: '🎓',title: 'Acemi Kaşif',description: '10. seviyeye ulaş.',isUnlocked: (stats) => stats.maxLevelCompleted >= 9},
                'level_25': {icon: '🗺️',title: 'Deneyimli Gezgin',description: '25. seviyeye ulaş.',isUnlocked: (stats) => stats.maxLevelCompleted >= 24},
                'level_50': {icon: '🏆',title: 'Usta Maceracı',description: '50. seviyeye ulaş.',isUnlocked: (stats) => stats.maxLevelCompleted >= 49},
                'super_easy_win': {icon: '🧸',title: 'Park Gezintisi',description: 'Aşırı Kolay modda bir seviye tamamla.',
                isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['super-easy']    },
                'easy_win': {icon: '😊',title: 'Tanıdık Yollar',description: 'Kolay modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['easy']    },
                'hard_mode_win': {icon: '🔥',title: 'Ateşle Oynayan',description: 'Zor modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['hard']},
                'timed_easy_win': {icon: '⏱️',title: 'Zamana Karşı',description: 'Süreli Kolay modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['timed-easy']},
                'timed_hard_win': {        icon: '⚡',        title: 'Şimşek Hızı',        description: 'Süreli Zor modda bir seviye tamamla.',
            isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['timed-hard']    },
                'score_10000': {
                    icon: '💰',
                    title: 'Puan Koleksiyoncusu',
                    description: 'Herhangi bir modda 10,000 puana ulaş.',
                    isUnlocked: (stats) => Object.values(stats.highScores).some(score => score >= 10000)
                },
                'gold_50': {
                    icon: '💎',
                    title: 'Altın Madencisi',
                    description: 'Toplamda 50 altın biriktir.',
                    isUnlocked: (stats) => stats.gold >= 50
                }
            };

function AchievementsList({ stats, language }) {
                const t = translations[language] || translations['en'];
                return (
                    <div className="text-left overflow-y-auto max-h-[60vh] mt-4 pr-2 scrollbar-thin">
                        <ul className="space-y-3">
                            {Object.values(achievementsList).map((ach, index) => {
                                const unlocked = ach.isUnlocked(stats);
                                return (
                                    <li
                                        key={index}
                                        className={`flex items-center p-4 rounded-lg transition-all ${unlocked ? 'bg-green-100 dark:bg-green-800/30' : 'bg-gray-100 dark:bg-gray-800 opacity-60'}`}
                                    >
                                        <span className={`text-4xl mr-4 ${unlocked ? '' : 'grayscale'}`}>{ach.icon}</span>
                                        <div className="flex-1">
                                            <p className={`font-bold text-gray-800 dark:text-gray-100 ${unlocked ? '' : 'text-gray-500'}`}>{ach.title}</p>
                                            <p className={`text-sm text-gray-600 dark:text-gray-400 ${unlocked ? '' : 'text-gray-500'}`}>{ach.description}</p>
                                        </div>
                                        {unlocked && (
                                            <span className="text-3xl text-green-500">✓</span>
                                        )}
                                    </li>
                                );
                            })}
                        </ul>
                    </div>
                );
            }

            const translations = {
                tr: {
                    title: "Kelime Avı",
                    easyMode: "KOLAY (NORMAL)",
                    leaderboard: "Liderlik",
                    çok: "ÇOK",
                    aşırı: "AŞIRI",
                    kolay: "KOLAY",
                    normal: "NORMAL",
                    zor: "ZOR",
                    süreli: "SÜRELİ",
                    hardMode: "ZOR (NORMAL)",
                    timedEasyMode: "SÜRELİ KOLAY",
                    timedHardMode: "SÜRELİ ZOR",
                    superEasyMode: "ÇOK KOLAY",
                    randomMode: "RASTGELE",
                    continueGame: (level) => `Devam Et (Seviye ${level})`,
                    level: "Seviye",
                    words: "Kelimeler",
                    hiddenWord: "Gizli Sözcük",
                    hiddenWordPlaceholder: "Gizli sözcüğü girin",
                    checkButton: "Kontrol Et",
                    homeButton: "Anasayfa",
                    footer: `© ${new Date().getFullYear()} Ozcelik Inc. Tüm hakları saklıdır.`,
                    congrats: "Tebrikler!",
                    error: "Hata!",
                    successMessage: (word) => `Harika! Gizli sözcüğü buldunuz: ${word}`,
                    allWordsRequired: "Önce tüm kelimeleri bulmalısınız!",
                    wrongGuess: "Yanlış tahmin! Tekrar deneyin.",
                    gameCompleted: "Tebrikler! Oyunu başarıyla tamamladınız!",
                    timeUp: "Süre Bitti!",
                    finalScore: (score) => `Skorunuz: ${score}`,
                    continueButton: "Devam Et",
                    tryAgainButton: "Tekrar Dene",
                    language: "Dil",
                    turkish: "Türkçe",
                    english: "English",
                    achievements: "Başarılar",
                    highScore: "Yüksek Skor",
                    score: "Puan",
                    gold: "Altın",
                    randomGameTitle: "🐟 Rastgele 🐟",
                    randomGameBody: (mode, level) => `Sizin için <span class="font-bold">${mode}</span> modunda, <span class="font-bold">Seviye ${level}</span> hazırlandı. Bu oyun kaydedilmez.`,
                    startButton: "Başla!",
                    savedGameFoundTitle: "Kayıtlı Oyun Bulundu",
                    savedGameFoundBody: (level) => `Bu modda <span class="font-bold">Seviye ${level}</span>'de kayıtlı bir oyununuz mevcut. Ne yapmak istersiniz?`,
                    noStartNewButton: "Hayır, Yeni Oyun Başlat",
                    yesContinueButton: "Evet, Devam Et",
                    returnToHomeButton: "Anasayfa",
                    nextLevelButton: "Devam→",
                    loadingLevel: (level) => `Seviye ${level} Yükleniyor...`,
                    levelLoadError: "Üzgünüz, bu seviye yüklenirken bir sorun oluştu."
                }, en: { leaderboard: "Leaderboard", aşırı: "SUPER", kolay: "EASY", normal: "NORMAL", zor: "HARD", süreli: "TIMED", title: "Word Hunt", easyMode: "EASY (NORMAL)", hardMode: "HARD (NORMAL)", timedEasyMode: "TIMED EASY", timedHardMode: "TIMED HARD", superEasyMode: "SUPER EASY", randomMode: "RANDOM", continueGame: (level) => `Continue (Level ${level})`, level: "Level", words: "Words", hiddenWord: "Hidden Word", hiddenWordPlaceholder: "Enter the hidden word", checkButton: "Check", homeButton: "Homepage", footer: `© ${new Date().getFullYear()} Ozcelik Inc. All rights reserved.`, congrats: "Congratulations!", error: "Error!", successMessage: (word) => `Awesome! You found the hidden word: ${word}`, allWordsRequired: "You must find all the words first!", wrongGuess: "Wrong guess! Try again.", gameCompleted: "Congratulations! You have successfully completed the game!", timeUp: "Time's Up!", finalScore: (score) => `Your Score: ${score}`, continueButton: "Continue", tryAgainButton: "Try Again", language: "Language", turkish: "Türkçe", english: "English", achievements: "Achievements", highScore: "High Score", score: "Score", gold: "Gold", randomGameTitle: "🎁 Random Game 🎁", randomGameBody: (mode, level) => `A game in <span class="font-bold">${mode}</span> mode, <span class="font-bold">Level ${level}</span> has been prepared for you. This game will not be saved.`, startButton: "Start!", savedGameFoundTitle: "Saved Game Found", savedGameFoundBody: (level) => `You have a saved game in this mode at <span class="font-bold">Level ${level}</span>. What would you like to do?`, noStartNewButton: "No, Start New Game", yesContinueButton: "Yes, Continue", returnToHomeButton: "Return to Homepage", nextLevelButton: "Next Level →", loadingLevel: (level) => `Loading Level ${level}...`, levelLoadError: "Sorry, a problem occurred while loading this level." } };

            const charSets = { tr: 'ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ'.split(''), en: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('') };
            const wordLists = { tr: typeof wordListTr !== 'undefined' ? wordListTr : [], en: typeof wordListEn !== 'undefined' ? wordListEn : [] };
            const wordLists_2letters = { tr: typeof wordListTr_2letters !== 'undefined' ? wordListTr_2letters : [], en: [] };
                const boardSizes = [];
                const initialRowsConfig = [9, 11, 13, 15, 17, 19];
                const initialColsConfig = [8, 10, 12, 14, 16, 18];
                for (let level = 0; level < 90; level++) {
                    const stage = Math.floor(level / 6);
                    const maxConfigIndex = initialRowsConfig.length - 1;
                    const configIndex = Math.min(Math.floor(stage / 2), maxConfigIndex);
                    const levelInStage = level % 6;
                    let baseRows = initialRowsConfig[configIndex];
                    let baseCols = initialColsConfig[configIndex];
                    let r = baseRows + Math.floor(levelInStage / 2);
                    let c = baseCols + Math.floor(levelInStage / 3);
                    r = Math.max(8, Math.min(14, r));
                    c = Math.max(7, Math.min(12, c));
                    if (r <= c && c > 7) r = c + 1;
                    boardSizes.push({ rows: r, cols: c });
                }

                const directions = { diagonal: [ { name: 'down-right', dx: 1, dy: 1 }, { name: 'down-left', dx: 1, dy: -1 }, { name: 'up-right', dx: -1, dy: 1 }, { name: 'up-left', dx: -1, dy: -1 } ], horizontal: [ { name: 'right', dx: 0, dy: 1 }, { name: 'left', dx: 0, dy: -1 } ], vertical: [ { name: 'down', dx: 1, dy: 0 }, { name: 'up', dx: -1, dy: 0 } ] };
                const allDirections = [...directions.diagonal, ...directions.horizontal, ...directions.vertical];
                const GAME_STATS_KEY = 'wordHuntGameStats';
                const USED_WORDS_KEY = 'wordHuntUsedWords';
                const loadUsedWords = () => { try { const data = localStorage.getItem(USED_WORDS_KEY); return data ? JSON.parse(data) : {}; } catch (e) { console.error("Kullanılmış kelimeler yüklenemedi:", e); return {}; } };
                const saveUsedWord = (mode, word) => { try { if (!mode || !word) return; const usedWords = loadUsedWords(); if (!usedWords[mode]) { usedWords[mode] = []; } if (!usedWords[mode].includes(word)) { usedWords[mode].push(word); localStorage.setItem(USED_WORDS_KEY, JSON.stringify(usedWords)); } } catch (e) { console.error("Kullanılmış kelime kaydedilemedi:", e); } };


            const loadGameStats = () => {
                try {
                    const stats = localStorage.getItem(GAME_STATS_KEY);
                    if (stats) {
                        const parsedStats = JSON.parse(stats);
                        if (!parsedStats.modesCompleted) {
                            parsedStats.modesCompleted = {};
                        }
                        return parsedStats;
                    }
                } catch (e) {
                    console.error("İstatistikler yüklenemedi:", e);
                }
                return { totalWordsFound: 0, maxLevelCompleted: -1, highScores: {}, modesCompleted: {} };
            };

            const saveGameStats = (stats) => { try { localStorage.setItem(GAME_STATS_KEY, JSON.stringify(stats)); } catch (e) { console.error("İstatistikler kaydedilemedi:", e); } };

            function createBoard(level, language, mode, boardSize = null) {
                const usedWordsForMode = (loadUsedWords()[mode] || []);
                try {
                    let rows, cols;
                    let targetTotalWordCount;
                    let targetHiddenWordLength = null;
                    if (boardSize) {
                        const sizes = {
                            small: { r: 8, c: 7 },
                            medium: { r: 12, c: 10 },
                            large: { r: 15, c: 12 }
                        };
                        rows = sizes[boardSize].r;
                        cols = sizes[boardSize].c;

                        if(boardSize === 'small') targetTotalWordCount = 15;
                        else if (boardSize === 'medium') targetTotalWordCount = 30;
                        else targetTotalWordCount = 45;

                    } else {
                        if (mode === 'super-easy') {
                            const totalLevels = 60;
                            const progress = level / (totalLevels - 1);
                            const startRows = 5, endRows = 7;
                            const startCols = 4, endCols = 6;
                            rows = Math.round(startRows + (endRows - startRows) * progress);
                            cols = Math.round(startCols + (endCols - startCols) * progress);
                        } else {
                            const staticConfig = boardSizes[level];
                            if (!staticConfig) {
                                console.error(`Geçersiz seviye yapılandırması: ${level}.`);
                                return null;
                            }
                            rows = staticConfig.rows;
                            cols = staticConfig.cols;
                        }

                        if (mode === 'super-easy') {
                            targetTotalWordCount = Math.min(15, 4 + Math.floor(level / 8));
                            targetHiddenWordLength = Math.max(3, Math.min(8, 4 + Math.floor(level / 10)));
                        } else {
                    targetTotalWordCount = Math.min(80, 50 + level);
                    targetHiddenWordLength = Math.max(5, Math.min(10, 5 + Math.floor(level / 3)));
                        }
                    }

                    for (let attempt = 0; attempt < 1500; attempt++) {
                        const board = Array(rows).fill(null).map(() => Array(cols).fill(''));
                        const lockGrid = Array(rows).fill(null).map(() => Array(cols).fill(false));
                        let placedWordsInfo = [];

                        const mainWordPool = (wordLists[language] || []).filter(w => w && w.length >= 3).map(customToUpperCase);
                        let potentialWords = _.shuffle(mainWordPool);
                        let twoLetterWords = _.shuffle((wordLists_2letters[language] || []).map(customToUpperCase));

                        if (mode === 'super-easy') {
                            potentialWords = potentialWords.filter(w => w.length <= 8);
                        }

                        const placeAndLockWord = (word, r, c, dir) => {
                            const positions = [];
                            for (let i = 0; i < word.length; i++) {
                                const nr = r + i * dir.dx;
                                const nc = c + i * dir.dy;
                                board[nr][nc] = word[i];
                                lockGrid[nr][nc] = true;
                                positions.push({ row: nr, col: nc });
                            }
                            placedWordsInfo.push({ word, positions, direction: dir.name });
                        };

                        const canPlaceWithoutOverlap = (word, r, c, dir) => {
                            for (let i = 0; i < word.length; i++) {
                                const nextRow = r + i * dir.dx;
                                const nextCol = c + i * dir.dy;
                                const isOutOfBounds = nextRow < 0 || nextRow >= rows || nextCol < 0 || nextCol >= cols;
                                if (isOutOfBounds) {
                                    return false;
                                }
                                if (lockGrid[nextRow][nextCol]) {
                                    return false;
                                }
                            }
                            return true;
                        };

                        let minDiagonalWords;
                        if (mode === 'super-easy' || boardSize === 'small') { minDiagonalWords = 2; }
                        else if (boardSize === 'medium') { minDiagonalWords = 4; }
                        else { minDiagonalWords = 6; }

                        let diagonalsPlaced = 0;
                        let usedForDiagonal = [];
                        for (const word of potentialWords) {
                            if (diagonalsPlaced >= minDiagonalWords) break;
                            if (word.length > Math.min(rows, cols)) continue;
                            let availablePositions = [];
                            for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { for (const dir of directions.diagonal) { if (canPlaceWithoutOverlap(word, r, c, dir)) { availablePositions.push({ r, c, dir }); } } } }
                            if (availablePositions.length > 0) {
                                const { r, c, dir } = _.sample(availablePositions);
                                placeAndLockWord(word, r, c, dir);
                                usedForDiagonal.push(word);
                                diagonalsPlaced++;
                            }
                        }
                        if (diagonalsPlaced < minDiagonalWords) continue;

                        potentialWords = potentialWords.filter(w => !usedForDiagonal.includes(w));
                        for (const word of potentialWords) {
                            if (placedWordsInfo.length >= targetTotalWordCount) break;
                            let availablePositions = [];
                            for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { for (const dir of allDirections) { if (canPlaceWithoutOverlap(word, r, c, dir)) { availablePositions.push({ r, c, dir }); } } } }
                            if (availablePositions.length > 0) {
                                const { r, c, dir } = _.sample(availablePositions);
                                placeAndLockWord(word, r, c, dir);
                            }
                        }

                        const MAX_TWO_LETTER_WORDS = 2;
                        let twoLetterWordsPlaced = 0;
                        for (const word of twoLetterWords) {
                            if (twoLetterWordsPlaced >= MAX_TWO_LETTER_WORDS) break;
                            if (placedWordsInfo.some(p => p.word === word)) continue;
                            let availablePositions = [];
                            for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { for (const dir of allDirections) { if (canPlaceWithoutOverlap(word, r, c, dir)) { availablePositions.push({ r, c, dir }); } } } }
                            if (availablePositions.length > 0) {
                                const { r, c, dir } = _.sample(availablePositions);
                                placeAndLockWord(word, r, c, dir);
                                twoLetterWordsPlaced++;
                            }
                        }
                        let hiddenWord = null;
                        let scatteredHiddenLetterPositions = [];
                        if (!boardSize) {
                            const emptyCells = [];
                            for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { if (!lockGrid[r][c]) emptyCells.push({ r, c }); } }

                            if (emptyCells.length < targetHiddenWordLength) continue;

                            let currentHiddenWordLength = targetHiddenWordLength;
                            while (!hiddenWord && currentHiddenWordLength >= 3) {
                                const suitableHiddenWords = mainWordPool.filter(w => w.length === currentHiddenWordLength && !placedWordsInfo.some(p => p.word === w) && !usedWordsForMode.includes(w));
                                if (suitableHiddenWords.length > 0) {
                                    hiddenWord = _.sample(suitableHiddenWords);
                                } else {
                                    currentHiddenWordLength--;
                                }
                            }
                            if (!hiddenWord) continue;

                            const shuffledHiddenWordChars = _.shuffle(hiddenWord.split(''));
                            const cellsForHidden = _.sampleSize(emptyCells, hiddenWord.length);
                            cellsForHidden.forEach((cell, i) => {
                                board[cell.r][cell.c] = shuffledHiddenWordChars[i];
                                lockGrid[cell.r][cell.c] = true;
                                scatteredHiddenLetterPositions.push({ row: cell.r, col: cell.c });
                            });
                        }

                        const emptyCells = [];
                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols; c++) {
                                if (!lockGrid[r][c]) {
                                    emptyCells.push({ r, c });
                                }
                            }
                        }
                        const letterBank = placedWordsInfo.flatMap(info => info.word.split(''));
                        if (letterBank.length === 0) {
                            const randomChars = charSets[language];
                            emptyCells.forEach(cell => {
                                board[cell.r][cell.c] = _.sample(randomChars);
                            });
                            continue;
                    }
                        const shuffledLetters = _.shuffle(letterBank);
                        const shuffledEmptyCells = _.shuffle(emptyCells);
                        const numLetters = shuffledLetters.length;
                        shuffledEmptyCells.forEach((cell, index) => {
                            board[cell.r][cell.c] = shuffledLetters[index % numLetters];
                        });
                        if (board.flat().some(cell => !cell)) continue;
                        const finalWords = _.sortBy(placedWordsInfo, 'word');
                        return { board, words: finalWords, hiddenWord, scatteredHiddenLetterPositions };
                    }

                    console.error("Tahta oluşturma denemeleri 1500 denemeden sonra başarısız oldu.");
                    return null;
                } catch (e) {
                    console.error(`createBoard kritik hatası:`, e);
                    return null;
                }
            }



function Modal({ isOpen, title, children, onClose }) { if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}> <div className="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full text-center relative" onClick={e => e.stopPropagation()}> <h3 className="text-2xl font-semibold mb-4 text-gray-800">{title}</h3> <div className="text-gray-700">{children}</div> <button onClick={onClose} className="absolute top-2 right-2 text-gray-500 hover:text-gray-800 text-2xl">&times;</button> </div> </div> ); }

        const Cell = React.memo(function Cell({letter, isSelected, isFoundRequiredPart, isHiddenLetterCell, allRequiredWordsFound, isJustFound, isBonusGlow, theme, numCols }) {
            let cellClass = 'bg-white';
            let textClass = 'text-gray-800';

            if (isBonusGlow) {
                cellClass = 'animate-bonus-glow';
            }
            else if (allRequiredWordsFound) {
                if (isHiddenLetterCell) {
                    cellClass = theme.hiddenWordCell;
                    textClass = 'text-white';
                } else {
                    cellClass = theme.obscuredCell;
                }
            } else {
                if (isJustFound) {
                    cellClass = 'animate-word-found';
                } else if (isSelected) {
                    cellClass = theme.selectedCell + ' transform scale-110 shadow-lg';
                    textClass = 'text-black font-bold';
                } else if (isFoundRequiredPart) {
                    cellClass = theme.foundCell;
                    textClass = 'text-gray-600 opacity-75';
                }
            }

            const calculateFontSize = () => {
                if (!numCols) return { fontSize: '18px' };
                const maxGridWidth = 768;
                const targetRatio = 0.6;
                const minFontSize = 10;
                const preferredVw = (100 / numCols) * targetRatio;
                const maxFontSize = (maxGridWidth / numCols) * targetRatio;
                return {
                    fontSize: `clamp(${minFontSize}px, ${preferredVw.toFixed(2)}vw, ${maxFontSize.toFixed(2)}px)`
                };
            };

            const fontSizeStyle = calculateFontSize();

            return (
                <div
                    className={`flex items-center justify-center text-center font-semibold border border-gray-200/50 rounded aspect-square ${cellClass} ${textClass} transition-all duration-150 select-none`}
                    style={fontSizeStyle}
                >
                    {letter || ''}
                </div>
            );
        });

function LeaderboardDisplay({ scores, currentUser, language }) {
                const t = translations[language] || translations['en'];
                if (!scores || scores.length === 0) {
                    return <p className="text-gray-600 dark:text-gray-400 pt-10">Bu mod için henüz skor bulunmuyor.</p>;
                }
                const rankIcons = ['🥇', '🥈', '🥉'];
                return (
                    <div className="text-left overflow-y-auto max-h-[300px] mt-4 pr-2 scrollbar-thin">
                        <ul className="space-y-2">
                            {scores.map((score, index) => {
                                const isCurrentUser = score.username === currentUser;
                                return (
                                    <li
                                        key={score.id || index}
                                        className={`flex items-center p-3 rounded-lg transition-all ${isCurrentUser ? 'bg-yellow-100 dark:bg-yellow-800/20 border-2 border-yellow-400' : 'bg-gray-50 dark:bg-gray-800'}`}
                                    >
                                        <span className="font-bold text-lg w-10 text-center text-gray-500 dark:text-gray-400">
                                            {rankIcons[index] || index + 1}
                                        </span>

                                        {/* Kullanıcı adı ve seviyeyi içeren yeni sarmalayıcı */}
                                        <div className="flex-1">
                                            <p className={`font-semibold text-gray-800 dark:text-gray-200 ${isCurrentUser ? 'text-yellow-900 dark:text-yellow-300' : ''}`}>
                                                {score.username}
                                            </p>
                                            {score.level && (
                                                <p className={`text-xs text-gray-500 dark:text-gray-400 ${isCurrentUser ? 'text-yellow-800 dark:text-yellow-400' : ''}`}>
                                                    Seviye {score.level}
                                                </p>
                                            )}
                                        </div>

                                        <span className={`font-bold text-xl text-indigo-600 dark:text-indigo-400 tabular-nums ${isCurrentUser ? 'text-yellow-900 dark:text-yellow-300' : ''}`}>
                                            {score.score}
                                        </span>
                                    </li>
                                );
                            })}
                        </ul>
                    </div>
                );
            }

function LeaderboardModal({ isOpen, onClose, currentUser, language }) { const t = translations[language] || translations['en']; const [activeTab, setActiveTab] = React.useState('super-easy'); const [scores, setScores] = React.useState({ 'super-easy': [], easy: [], hard: [], 'timed-easy': [], 'timed-hard': [] }); const [loading, setLoading] = React.useState(true);

            const tabs = [

            { key: 'super-easy', line1Key: 'çok', line2Key: 'kolay', activeBg: 'bg-green-500' },
                    { key: 'easy', line1Key: 'kolay', line2Key: 'normal', activeBg: 'bg-teal-500' },
                    { key: 'hard', line1Key: 'zor', line2Key: 'normal', activeBg: 'bg-red-500' },
                    { key: 'timed-easy', line1Key: 'süreli', line2Key: 'kolay', activeBg: 'bg-blue-500' },
                    { key: 'timed-hard', line1Key: 'süreli', line2Key: 'zor', activeBg: 'bg-orange-500' }
                ];

             React.useEffect(() => { if (isOpen) { setLoading(true); const fetchPromises = tabs.map(tab => db.collection("scores") .where("mode", "==", tab.key) .orderBy("score", "desc") .limit(50) .get() ); Promise.all(fetchPromises) .then(snapshots => { const newScores = {}; snapshots.forEach((snapshot, index) => { const mode = tabs[index].key; newScores[mode] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); }); setScores(newScores); }) .catch(error => console.error("Liderlik tablosu verileri çekilirken hata oluştu:", error)) .finally(() => setLoading(false)); } }, [isOpen]); if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}> <div className="bg-white dark:bg-gray-900 p-4 sm:p-6 rounded-xl shadow-2xl max-w-lg w-full text-center relative" onClick={e => e.stopPropagation()}> <h3 className="text-3xl font-bold mb-4 text-gray-800 dark:text-gray-100">🏆 {t.leaderboard} 🏆</h3> <button onClick={onClose} className="absolute top-2 right-2 text-gray-500 hover:text-gray-800 dark:hover:text-gray-200 text-3xl">&times;</button> <div className="flex items-center border-b-2 border-gray-200 dark:border-gray-700"> {tabs.map(tab => { const isActive = activeTab === tab.key; return ( <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`flex-1 flex flex-col justify-center items-center h-14 py-1 text-center transition-all duration-300 border-x border-transparent ${isActive ? `${tab.activeBg} scale-105 z-10 rounded-t-lg` : 'hover:bg-gray-100 dark:hover:bg-gray-800'}`}> <span className={`block text-xs font-bold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}> {t[tab.line1Key]} </span> <span className={`block text-xs font-semibold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}> {t[tab.line2Key]} </span> </button> ); })} </div> <div className="min-h-[300px]"> {loading ? ( <p className="text-gray-600 dark:text-gray-400 pt-10">Liderlik tablosu yükleniyor...</p> ) : ( <LeaderboardDisplay scores={scores[activeTab]} currentUser={currentUser} language={language} /> )} </div> </div> </div> ); }


function HomePage({
    startGame,
    startGameVsComputer,
    language,
    setLanguage,
    stats,
    setModalContent,
    savedGame,
    username,
    openDuelLobby,
    isInitializing,
    openFriendsPage,
    avatarId,
    openAvatarModal
}) {
    const t = translations[language] || translations['en'];
    const [isLeaderboardOpen, setIsLeaderboardOpen] = React.useState(false);

    const openAchievements = () => {
        setModalContent({
            isOpen: true,
            title: t.achievements,
            body: <AchievementsList stats={stats} language={language} />
        });
    };

    return (
        <div className="h-full w-full bg-slate-100 flex flex-col">
            <div className="container mx-auto px-4 pt-3 text-center flex flex-col flex-1 overflow-hidden">
                
                {/* --- DEĞİŞTİRİLEN BÖLÜM --- */}
                <header className="my-2 flex-shrink-0 flex items-center justify-between">
                    {/* Sol Taraf: Başlık */}
                    <div className="text-left">
                        <h1 className="text-4xl md:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 drop-shadow-sm">{t.title}</h1>
                        <p className="text-slate-500 text-sm mt-1">Kelime dehası olmaya hazır mısın?</p>
                    </div>

                    {/* Sağ Taraf: Dikey Olarak Hizalanmış Profil Alanı */}
                    {username && (
                        <div className="flex flex-col items-center gap-0.5">
                            {/* 1. Avatar Resmi */}
                            <img 
                                src={avatarId ? `avatars/${avatarId}.png` : 'avatars/default.png'} 
                                className="w-12 h-12 rounded-full object-cover bg-gray-200 border-2 border-white shadow-md"
                            />
                            {/* 2. Kullanıcı Adı */}
                            <p className="font-bold text-sm text-slate-700">{username}</p>
                            {/* 3. Değiştir Butonu */}
                            <button 
                                onClick={openAvatarModal}
                                className="text-xs text-indigo-600 font-semibold hover:underline"
                            >
                                Değiştir
                            </button>
                        </div>
                    )}
                </header>
                {/* --- DEĞİŞİKLİK SONU --- */}

                <div className="flex-1 overflow-y-auto scrollbar-thin py-4">
                    <div className="w-full max-w-md mx-auto grid grid-cols-4 auto-rows-fr gap-3">
                        <ModernModeCard
                            title="Düello"
                            icon="⚔️"
                            bgColor="bg-gradient-to-br from-purple-600 to-indigo-700"
                            className="col-span-2 h-24"
                            onClick={openFriendsPage}
                            disabled={isInitializing || !username}
                            userInfo={{username: '', status: 'Çevrimiçi'}}
                        />
                        <ModernModeCard
                            title="Bilgisayara Karşı"
                            icon="🤖"
                            bgColor="bg-gradient-to-br from-slate-500 to-slate-700"
                            className="col-span-2 h-24"
                            onClick={startGameVsComputer}
                            disabled={isInitializing}
                        />
                        <ModernModeCard title={t.superEasyMode} icon="🧸" bgColor="bg-gradient-to-br from-green-400 to-green-600" className="col-span-2 h-26" onClick={() => startGame('super-easy')} />
                        <ModernModeCard title={t.randomMode} icon="🐟" bgColor="bg-gradient-to-br from-blue-400 to-blue-600" className="col-span-2 h-26" onClick={() => startGame('random')} />
                        <ModernModeCard title={t.easyMode} icon="😊" bgColor="bg-gradient-to-br from-teal-400 to-teal-600" className="col-span-2 h-26" onClick={() => startGame('easy')} />
                        <ModernModeCard title={t.hardMode} icon="🔥" bgColor="bg-gradient-to-br from-rose-400 to-rose-600" className="col-span-2 h-26" onClick={() => startGame('hard')} />
                        <ModernModeCard title={t.timedEasyMode} icon="⏱️" bgColor="bg-gradient-to-br from-sky-400 to-sky-600" className="col-span-2 h-26" onClick={() => startGame('timed-easy')} />
                        <ModernModeCard title={t.timedHardMode} icon="⚡" bgColor="bg-gradient-to-br from-red-500 to-red-700" className="col-span-2 h-26" onClick={() => startGame('timed-hard')} />
                    </div>
                </div>
                <div className="w-full max-w-md mx-auto flex-shrink-0 pb-1 pt-2">
                    <div className="grid grid-cols-2 gap-2 mb-2">
                        <button onClick={() => setIsLeaderboardOpen(true)} className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-2 flex flex-row items-center justify-center gap-2 text-slate-700 shadow-sm transition-all hover:-translate-y-0.5">
                            <span className="text-xl">🎯</span>
                            <span className="font-bold text-sm">Liderlik</span>
                        </button>
                        <button onClick={openAchievements} className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-2 flex flex-row items-center justify-center gap-2 text-slate-700 shadow-sm transition-all hover:-translate-y-0.5">
                            <span className="text-xl">🏆</span>
                            <span className="font-bold text-sm">Başarılar</span>
                        </button>
                    </div>
                    <div className="bg-white/90 border border-slate-200 rounded-xl p-2 flex flex-row items-center justify-between text-slate-700 shadow-sm">
                        <div className="flex items-center gap-2">
                            <span className="text-sm font-medium text-slate-600">Toplam Altın:</span>
                            <span className="text-2xl">💰</span>
                            <span className="font-bold text-base text-amber-900">{stats.gold || 0}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <label htmlFor="language-select" className="text-sm font-medium text-slate-600">Dil:</label>
                            <select id="language-select" value={language} onChange={(e) => setLanguage(e.target.value)} className="bg-transparent border-none text-slate-800 rounded-lg focus:ring-0 p-1 text-xs font-semibold">
                                <option value="tr">{t.turkish}</option>
                                <option value="en">{t.english}</option>
                            </select>
                        </div>
                    </div>
                    <footer className="w-full text-center py-1 text-xs text-gray-400">
                        {t.footer}
                    </footer>
                </div>
                <LeaderboardModal isOpen={isLeaderboardOpen} onClose={() => setIsLeaderboardOpen(false)} currentUser={username} language={language} />
            </div>
        </div>
    );
}


 function WordHunt({ config, gameId, username, goToHome, language, stats, onStatsChange, initialSavedState }) {
            const t = translations[language] || translations['en'];
            const isRealtimeDuel = !!gameId;
            const isVsComputer = config.name === 'vs-computer';
            const [realtimeGameData, setRealtimeGameData] = React.useState(null);
            const [computerState, setComputerState] = React.useState({ score: 0, foundWords: [] });
            const [board, setBoard] = React.useState(null);
            const [isLoading, setIsLoading] = React.useState(true);
            const [error, setError] = React.useState('');
            const [level, setLevel] = React.useState(config?.level ?? initialSavedState?.level ?? 0);
            const [score, setScore] = React.useState(initialSavedState?.score ?? 0);
            const [foundWords, setFoundWords] = React.useState(initialSavedState?.foundWords ?? []);
            const [gameState, setGameState] = React.useState(null);
            const [timeLeft, setTimeLeft] = React.useState(initialSavedState?.timeLeft ?? getInitialTime(config.name, 0));
            const [modalContent, setModalContent] = React.useState({ isOpen: false });
            const [justFoundWordInfo, setJustFoundWordInfo] = React.useState(null);
            const [allRequiredWordsFound, setAllRequiredWordsFound] = React.useState(false);
            const [isShaking, setIsShaking] = React.useState(false);
            const [levelStartTime, setLevelStartTime] = React.useState(null);
            const [hiddenWordAttempts, setHiddenWordAttempts] = React.useState(0);
            const [answerSlots, setAnswerSlots] = React.useState([]);
            const [sourceLetters, setSourceLetters] = React.useState([]);
            const [hintLockedSlots, setHintLockedSlots] = React.useState([]);
            const [hiddenWordTimeLeft, setHiddenWordTimeLeft] = React.useState(null);
            const gridRef = React.useRef(null);
            const [selectedCells, setSelectedCells] = React.useState([]);
            const [isSwiping, setIsSwiping] = React.useState(false);
            const foundWordsRef = React.useRef(foundWords);
            const computerStateRef = React.useRef(computerState);
            const peerConnectionRef = React.useRef(null);
            const dataChannelRef = React.useRef(null);
            const lastHiddenTimestamp = React.useRef(null);
            const [bonusGlowCells, setBonusGlowCells] = React.useState([]);
            const [foundBonusWords, setFoundBonusWords] = React.useState([]);
            const [toastMessage, setToastMessage] = React.useState(null);
            const showExitConfirmation = React.useCallback(() => {
            const title = "Ana Menüye Dön";
            const bodyText = "Ana menüye dönmek istediğinize emin misiniz? İlerlemeniz kaydedildi.";
            const confirmButtonText = "Evet, Dön";
            const confirmButtonAction = goToHome;

                setModalContent({
                    isOpen: true,
                    title: title,
                    onClose: closeModal,
                    children: (
                        <div className="text-center text-gray-800">
                            <p className="mb-6" dangerouslySetInnerHTML={{ __html: bodyText }}></p>
                            <div className="flex justify-center gap-4">
                                <button onClick={closeModal} className="px-8 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600">Hayır</button>
                                <button onClick={confirmButtonAction} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">{confirmButtonText}</button>
                            </div>
                        </div>
                    )
                });
            }, [isRealtimeDuel, isVsComputer, setModalContent, goToHome, handleForfeit]);

    const handleCancelDuel = React.useCallback(() => {
            if (gameId) {
                db.collection('active-duels').doc(gameId).delete()
                    .then(() => console.log("Düello başarıyla iptal edildi."))
                    .catch(err => console.error("Düello iptal edilirken silinemedi:", err));
            }
            goToHome();
        }, [gameId, goToHome]);

        React.useEffect(() => {
            if (toastMessage) {
                const timer = setTimeout(() => {
                    setToastMessage(null);
                }, 3800);

                return () => clearTimeout(timer);
            }
        }, [toastMessage]);

            React.useEffect(() => {
                window.androidBridge.game_showExitConfirmation = showExitConfirmation;
                return () => {
                    window.androidBridge.game_showExitConfirmation = null;
                }
            }, [showExitConfirmation]);




            React.useEffect(() => {
                if (!isRealtimeDuel && !isVsComputer) {
                    return;
                }
                history.pushState(null, '', window.location.href);

                const handleBackButton = (event) => {
                    history.pushState(null, '', window.location.href);
                    showExitConfirmation();
                };

                const handleVisibilityChange = () => {
                    if (document.visibilityState === 'hidden') {
                        lastHiddenTimestamp.current = Date.now();
                    }
                    if (document.visibilityState === 'visible' && lastHiddenTimestamp.current && (Date.now() - lastHiddenTimestamp.current > 1000)) {
                        showExitConfirmation();
                        lastHiddenTimestamp.current = null;
                    }
                };

                window.addEventListener('popstate', handleBackButton);
                document.addEventListener('visibilitychange', handleVisibilityChange);
                return () => {
                    window.removeEventListener('popstate', handleBackButton);
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                };

            }, [isRealtimeDuel, isVsComputer, showExitConfirmation]);

            const countdownIntervalRef = React.useRef(null);
            const connectionTimeoutRef = React.useRef(null);
            const [disconnectionInfo, setDisconnectionInfo] = React.useState({ isDisconnected: false, countdown: 20, message: '' });
            const [playerColors, setPlayerColors] = React.useState({});
            const opponentName = React.useMemo(() => realtimeGameData ? Object.keys(realtimeGameData.players).find(p => p !== username) : null, [realtimeGameData, username]);

            React.useEffect(() => {
                if (isRealtimeDuel && username && opponentName) {
                    const players = [username, opponentName].sort();
                    setPlayerColors({
                        [players[0]]: 'green',
                        [players[1]]: 'red'
                    });
                }
            }, [isRealtimeDuel, username, opponentName]);

            const cellOwnerMap = React.useMemo(() => {
                const map = {};
                if (!realtimeGameData?.boardData?.words || !playerColors) return map;
                for (const playerName in realtimeGameData.players) {
                    const playerInfo = realtimeGameData.players[playerName];
                    const wordsFoundByPlayer = realtimeGameData.boardData.words.filter(w => playerInfo.foundWords.includes(w.word));
                    for (const word of wordsFoundByPlayer) {
                        for (const pos of word.positions) {
                            map[`${pos.row}-${pos.col}`] = playerName;
                        }
                    }
                }
                return map;
            }, [realtimeGameData, playerColors]);

            const endDuelByError = (reason) => {
                if (!gameId) return;
                const opponentName = realtimeGameData && Object.keys(realtimeGameData.players).find(p => p !== username);
                const winner = opponentName || 'yok';
                db.collection('active-duels').doc(gameId).update({ status: 'finished', winner: winner, reason: reason }).catch(err => console.error("Oyun sonlandırılamadı:", err));
            };

            const handleDisconnection = () => {
                if (disconnectionInfo.isDisconnected) return;
                setDisconnectionInfo({ isDisconnected: true, countdown: 20, message: 'Rakibin bağlantısı koptu. Yeniden bağlanması bekleniyor...' });
                countdownIntervalRef.current = setInterval(() => {
                    setDisconnectionInfo(prev => {
                        if (prev.countdown <= 1) {
                            clearInterval(countdownIntervalRef.current);
                            endDuelByError(`${username} tarafında, rakibin bağlantısı koptuğu için oyun sonlandırıldı.`);
                            return { ...prev, isDisconnected: true, countdown: 0 };
                        }
                        return { ...prev, countdown: prev.countdown - 1 };
                    });
                }, 1000);
            };
            const handleReconnection = () => {
                if (countdownIntervalRef.current) {
                    clearInterval(countdownIntervalRef.current);
                }
                setDisconnectionInfo({ isDisconnected: false, countdown: 20, message: '' });
            };

            const closeModal = () => setModalContent({ isOpen: false });
            const playSound = React.useCallback((soundId) => { const sound = document.getElementById(soundId); if (sound) { sound.currentTime = 0; sound.play().catch(e => {}); } }, []);
            const triggerConfetti = () => confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });

            const handleDataChannelMessage = (event) => {
                const incomingData = JSON.parse(event.data);
                if (incomingData.foundWord && typeof incomingData.score !== 'undefined') {
                    setRealtimeGameData(prevData => {
                        if (!prevData) return null;
                        const newGameData = JSON.parse(JSON.stringify(prevData));
                        const opponentName = Object.keys(newGameData.players).find(p => p !== username);
                        if (opponentName) {
                            newGameData.players[opponentName].score += incomingData.score;
                            newGameData.players[opponentName].foundWords.push(incomingData.foundWord);
                        }
                        return newGameData;
                    });
                }
            };

            const handleForfeit = () => {
                const opponentName = realtimeGameData && Object.keys(realtimeGameData.players).find(p => p !== username);
                if (gameId && opponentName) {
                    db.collection('active-duels').doc(gameId).update({ status: 'finished', winner: opponentName, reason: `${username} oyundan ayrıldı.` }).finally(() => { goToHome(); });
                } else {
                    goToHome();
                }
            };

            const handleExitClick = () => {
                setModalContent({
                    isOpen: true,
                    title: 'Emin misiniz?',
                    onClose: closeModal,
                    children: (
                        <div className="text-center text-gray-800">
                            <p className="mb-6">Oyundan çıkıp ana sayfaya dönmek istediğinize emin misiniz? <br /><strong className="text-red-600">Bu işlem maçı kaybettiğiniz anlamına gelecektir.</strong></p>
                            <div className="flex justify-center gap-4">
                                <button onClick={closeModal} className="px-8 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600">Hayır</button>
                                <button onClick={handleForfeit} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Evet</button>
                            </div>
                        </div>
                    )
                });
            };

            const getCellFromCoordinates = React.useCallback((clientX, clientY) => { const grid = gridRef.current; if (!grid || !board || !board[0]) return null; const rect = grid.getBoundingClientRect(); const cols = board[0].length; const rows = board.length; const cellWidth = rect.width / cols; const cellHeight = rect.height / rows; const x = clientX - rect.left; const y = clientY - rect.top; const col = Math.floor(x / cellWidth); const row = Math.floor(y / cellHeight); if (row < 0 || row >= rows || col < 0 || col >= cols) return null; return { row, col }; }, [board]);
            const isCellSelected = React.useCallback((r, c) => selectedCells.some(cell => cell.row === r && cell.col === c), [selectedCells]);

            const isCellFound = React.useCallback((r, c) => {
                if (isRealtimeDuel) {
                    if (!realtimeGameData || !realtimeGameData.boardData) return false;
                    for (const player of Object.values(realtimeGameData.players)) {
                        const foundWordInfo = realtimeGameData.boardData.words.filter(w => player.foundWords.includes(w.word));
                        for (const word of foundWordInfo) {
                            if (word.positions.some(p => p.row === r && p.col === c)) return true;
                        }
                    }
                    return false;
                } else {
                    return gameState?.words?.some(w => foundWords.includes(w.word) && w.positions.some(p => p.row === r && p.col === c));
                }
            }, [isRealtimeDuel, realtimeGameData, gameState, foundWords]);

            const handleInteractionStart = React.useCallback((clientX, clientY) => { const canPlay = isRealtimeDuel ? true : !allRequiredWordsFound; if (!canPlay || !board) return; const cell = getCellFromCoordinates(clientX, clientY); if (cell && !isCellFound(cell.row, cell.col)) { setIsSwiping(true); setSelectedCells([cell]); } }, [board, getCellFromCoordinates, isCellFound, isRealtimeDuel, allRequiredWordsFound]);
            const throttledMove = React.useMemo(() => _.throttle((clientX, clientY) => { if (!isSwiping || !board || selectedCells.length === 0) return; const startCell = selectedCells[0]; const currentCell = getCellFromCoordinates(clientX, clientY); if (!currentCell) return; const dx = Math.sign(currentCell.col - startCell.col); const dy = Math.sign(currentCell.row - startCell.row); if (dx === 0 && dy === 0) return; if (!((dx !== 0 && dy !== 0) || (dx === 0 || dy === 0))) return; const distance = Math.max(Math.abs(currentCell.row - startCell.row), Math.abs(currentCell.col - startCell.col)); const newSelection = [startCell]; for (let i = 1; i <= distance; i++) { const nextRow = startCell.row + i * dy; const nextCol = startCell.col + i * dx; if (nextRow >= 0 && nextRow < board.length && nextCol >= 0 && nextCol < board[0].length) { const cellToAdd = { row: nextRow, col: nextCol }; if (!isCellFound(cellToAdd.row, cellToAdd.col)) { newSelection.push(cellToAdd); } else { break; } } else { break; } } setSelectedCells(newSelection); }, 30), [isSwiping, board, selectedCells, getCellFromCoordinates, isCellFound]);

            const getScoreMultiplier = (startTime) => {
                if (!startTime) return 1;
                const elapsedSeconds = (Date.now() - startTime) / 1000;
                if (elapsedSeconds <= 20) return 5;
                if (elapsedSeconds <= 40) return 4;
                if (elapsedSeconds <= 60) return 3;
                if (elapsedSeconds <= 80) return 2;
                return 1;
            };

       const handleInteractionEnd = () => {
        if (!isSwiping || !board || selectedCells.length <= 1) {
            setIsSwiping(false);
            setSelectedCells([]);
            return;
        }
        throttledMove.flush();
        setIsSwiping(false);
        const rawWord = selectedCells.map(c => board?.[c.row]?.[c.col] || '').join('');
        const word = customToUpperCase(rawWord);

        if (isRealtimeDuel) {
            const targetWord = realtimeGameData.boardData.words.find(w => w.word === word);
            const alreadyFoundByAnyPlayer = Object.values(realtimeGameData.players).some(p => p.foundWords.includes(word));

            if (targetWord && !alreadyFoundByAnyPlayer) {
                playSound('correctSound');
                vibrate('success');

                const points = word.length * 10;
                const gameRef = db.collection('active-duels').doc(gameId);
                const scoreUpdateKey = `players.${username}.score`;
                const scoreUpdate = { [scoreUpdateKey]: firebase.firestore.FieldValue.increment(points) };
                const wordsUpdateKey = `players.${username}.foundWords`;
                const wordsUpdate = { [wordsUpdateKey]: firebase.firestore.FieldValue.arrayUnion(word) };
                gameRef.update(scoreUpdate).catch(err => console.error("Skor güncellenirken hata:", err));
                gameRef.update(wordsUpdate).catch(err => console.error("Kelime güncellenirken hata:", err));

            } else {
                playSound('wrongSound');
                vibrate('error');
            }
        }
        else {
            const targetWord = gameState.words.find(w => w.word === word);

            if (targetWord && !foundWords.includes(word)) {
                setFoundWords(prev => [...prev, word]);
                let wordScore = 0;
                if (isVsComputer) {
                    wordScore = word.length * 5;
                } else {
                    const multiplier = getScoreMultiplier(levelStartTime);
                    wordScore = word.length * multiplier;
                }
                setScore(s => s + wordScore);
                playSound('correctSound');
                vibrate('success');
                setJustFoundWordInfo({ word, positions: targetWord.positions });
                setTimeout(() => setJustFoundWordInfo(null), 600);
            }
            else {
                const masterWordList = (wordLists[language] || []).map(customToUpperCase);
                const isBonusWord = masterWordList.includes(word);
                const alreadyFound = foundWords.includes(word) || foundBonusWords.includes(word);

                if (isBonusWord && !alreadyFound && word.length >= 3) {
                    setFoundBonusWords(prev => [...prev, word]);
                    const bonusScore = word.length * 2;
                    setScore(s => s + bonusScore);
                    playSound('correctSound');
                    vibrate('success');
                    setJustFoundWordInfo({ word, positions: selectedCells });
                    setTimeout(() => setJustFoundWordInfo(null), 600);
                    setToastMessage(`Listede olmayan (${word}) kelimesini buldun, +${bonusScore} puan`);
                } else {
                    playSound('wrongSound');
                    vibrate('error');
                }
            }
        }

        setSelectedCells([]);
    };

            const handleAnswerSlotClick = (letter, index) => { if (hintLockedSlots.includes(index) || !letter) return; const newAnswerSlots = [...answerSlots]; newAnswerSlots[index] = null; setAnswerSlots(newAnswerSlots); setSourceLetters([...sourceLetters, letter]); };
            const handleSourceLetterClick = (letter) => { const firstEmptyIndex = answerSlots.findIndex(slot => slot === null); if (firstEmptyIndex === -1) return; const newAnswerSlots = [...answerSlots]; newAnswerSlots[firstEmptyIndex] = letter; setAnswerSlots(newAnswerSlots); setSourceLetters(sourceLetters.filter(l => l.id !== letter.id)); };

            const goToNextLevel = () => {
                const newStats = { ...stats };
                newStats.maxLevelCompleted = Math.max(stats.maxLevelCompleted, level);
                if (!newStats.modesCompleted) newStats.modesCompleted = {};
                newStats.modesCompleted[config.name] = true;
                const currentModeHighScore = newStats.highScores[config.name] || 0;
                newStats.highScores[config.name] = Math.max(currentModeHighScore, score);
                onStatsChange(newStats);
                closeModal();
                setLevel(prevLevel => prevLevel + 1);
            };

            const handleCheckHiddenWord = () => {
                const getHiddenWordMultiplier = (attempts) => {
                    const attemptNumber = attempts + 1;
                    if (attemptNumber === 1) return 5; if (attemptNumber === 2) return 4; if (attemptNumber === 3) return 3; if (attemptNumber === 4) return 2;
                    return 1;
                };
                const guessedWord = customToUpperCase(answerSlots.map(l => l && l.char).join(''));
                const correctWord = gameState.hiddenWord;
                if (guessedWord === correctWord) {
                    playSound('achievementSound');
                    vibrate('achievement');
                    triggerConfetti();
                    const newStats = { ...stats };
                    if (!newStats.modesCompleted) newStats.modesCompleted = {};
                    newStats.modesCompleted[config.name] = true;
                    let goldEarned = 0;
                    if (config.name === 'easy' || config.name === 'super-easy') goldEarned = 1;
                    else if (config.name === 'hard') goldEarned = 3;
                    else if (config.name === 'timed-easy') goldEarned = 5;
                    else if (config.name === 'timed-hard') goldEarned = 8;
                    newStats.gold = (stats.gold || 0) + goldEarned;
                    const attemptMultiplier = getHiddenWordMultiplier(hiddenWordAttempts);
                    const hiddenWordBaseScore = (correctWord.length * 50);
                    const finalHiddenWordScore = hiddenWordBaseScore * attemptMultiplier;
                    const finalScore = score + finalHiddenWordScore;
                    setScore(finalScore);
                    const currentHighScore = newStats.highScores[config.name] || 0;
                    newStats.highScores[config.name] = Math.max(currentHighScore, finalScore);
                    onStatsChange(newStats);
                    setModalContent({
                        isOpen: true,
                        title: '🎉 Harika İş! 🎉',
                        onClose: goToNextLevel,
                        children: ( <div className="flex flex-col items-center gap-4 p-2"> <p className="text-lg font-medium text-gray-800 text-center"> Bravo! Gizli kelime <b className="text-green-600">{correctWord}</b> idi. (Deneme: {hiddenWordAttempts + 1}, Çarpan: x{attemptMultiplier}) </p> <div className="bg-amber-100 border-2 border-amber-300 rounded-full px-6 py-2 flex items-center gap-3 shadow-inner"> <span className="text-3xl">💰</span> <div className="text-left"> <p className="text-sm font-semibold text-amber-800">Kazanılan Altın</p> <p className="text-2xl font-bold text-amber-900">+{goldEarned}</p> </div> </div> <div className="w-full text-center bg-slate-100 p-3 rounded-lg"> <p className="text-sm font-semibold text-gray-600 uppercase">Seviye Skoru</p> <p className="text-4xl font-bold text-green-600">{finalScore}</p> </div> <button onClick={goToNextLevel} className="w-full mt-2 px-4 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg"> {t.nextLevelButton} </button> </div> )
                    });
                } else {
                    playSound('wrongSound');
                    vibrate('error');
                    setIsShaking(true);
                    setTimeout(() => setIsShaking(false), 400);
                    setHiddenWordAttempts(prev => prev + 1);
                    const lettersToReturn = [];
                    const newAnswerSlots = Array(gameState.hiddenWord.length).fill(null);
                    answerSlots.forEach((letter, index) => {
                        if (letter) {
                            if (hintLockedSlots.includes(index)) {
                                newAnswerSlots[index] = letter;
                            } else {
                                lettersToReturn.push(letter);
                            }
                        }
                    });
                    setSourceLetters(prevSource => _.shuffle([...prevSource, ...lettersToReturn]));
                    setAnswerSlots(newAnswerSlots);
                }
            };

            const getModeDisplayName = (modeKey, translations) => {
                const keyMap = { 'super-easy': 'superEasyMode', 'easy': 'easyMode', 'hard': 'hardMode', 'timed-easy': 'timedEasyMode', 'timed-hard': 'timedHardMode' };
                const translationKey = keyMap[modeKey] || 'randomMode';
                return translations[translationKey] || modeKey;
            };

            const handleRevealWordHint = () => {
                const unfoundWords = gameState.words.filter(w => !foundWords.includes(w.word));
                if (stats.gold < 1 || unfoundWords.length === 0) return;
                const wordToReveal = _.sample(unfoundWords);
                onStatsChange({ ...stats, gold: stats.gold - 1 });
                setFoundWords(prev => [...prev, wordToReveal.word]);
                setJustFoundWordInfo({ word: wordToReveal.word, positions: wordToReveal.positions });
                setTimeout(() => setJustFoundWordInfo(null), 600);
                playSound('correctSound');
                vibrate('success');
            };

            const handleHiddenWordHint = () => {
                if (stats.gold < 1 || !gameState) return;
                const hintIndex = answerSlots.findIndex((slot, index) => slot === null && !hintLockedSlots.includes(index));
                if (hintIndex === -1) return;
                const correctChar = gameState.hiddenWord[hintIndex];
                let letterToMove = null;
                const newAnswerSlots = [...answerSlots];
                let newSourceLetters = [...sourceLetters];
                const sourceIdx = newSourceLetters.findIndex(l => l.char === correctChar);
                if (sourceIdx > -1) {
                    letterToMove = newSourceLetters[sourceIdx];
                    newSourceLetters.splice(sourceIdx, 1);
                } else {
                    const wrongSlotIdx = newAnswerSlots.findIndex((l, i) => l?.char === correctChar && !hintLockedSlots.includes(i));
                    if (wrongSlotIdx > -1) {
                        letterToMove = newAnswerSlots[wrongSlotIdx];
                        newAnswerSlots[wrongSlotIdx] = null;
                    }
                }
                if (!letterToMove) return;
                if (newAnswerSlots[hintIndex]) {
                    newSourceLetters.push(newAnswerSlots[hintIndex]);
                }
                newAnswerSlots[hintIndex] = letterToMove;
                setAnswerSlots(newAnswerSlots);
                setSourceLetters(_.shuffle(newSourceLetters));
                setHintLockedSlots(prev => [...prev, hintIndex]);
                onStatsChange({ ...stats, gold: stats.gold - 1 });
                playSound('correctSound');
            };

            const handleGoHomeClick = () => {
                if (config?.isOneShot) {
                    setModalContent({ isOpen: true, title: "Emin misiniz?", children: ( <div> <p className="mb-4 text-gray-700"> Bu modda ilerleme kaydedilmeyecektir. Yine de ana sayfaya dönülsün mü? </p> <div className="flex justify-center gap-4 mt-4"> <button onClick={goToHome} className="px-8 py-2 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700">Evet, Dön</button> <button onClick={closeModal} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Hayır</button> </div> </div> ) });
                } else {
                    setModalContent({ isOpen: true, title: "Ana Sayfaya Dön", children: ( <div> <p className="mb-4 text-gray-700"> Ana sayfaya dönmek istediğinize emin misiniz? <br /> <strong>İlerlemeniz kaydedildi</strong>, istediğiniz zaman devam edebilirsiniz. </p> <div className="flex justify-center gap-4 mt-4"> <button onClick={goToHome} className="px-8 py-2 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700">Evet</button> <button onClick={closeModal} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Hayır</button> </div> </div> ) });
                }
            };

           React.useEffect(() => {
        if (isRealtimeDuel) {
            setIsLoading(true);
            setError('');

            const connectionTimeout = setTimeout(() => {
                setError("Rakiple bağlantı kurulamadı veya rakip oyundan ayrıldı.");
                handleCancelDuel();
            }, 20000);

            const gameRef = db.collection('active-duels').doc(gameId);

            const unsubGameState = gameRef.onSnapshot(doc => {
                if (!doc.exists) {
                    setError('Oyun bulunamadı veya rakip tarafından iptal edildi.');
                    setIsLoading(false);
                    clearTimeout(connectionTimeout);
                    setTimeout(goToHome, 3000);
                    return;
                }

                const data = doc.data();
                setRealtimeGameData(data);

                const selfIsCaller = username === gameId.split('_').sort()[0];

                if (!data.boardData && selfIsCaller) {
                    const newBoardData = createBoard(null, language, null, data.boardSize);
                    if (newBoardData) {
                        const boardAsMap = {};
                        newBoardData.board.forEach((row, index) => {
                            boardAsMap[index] = row;
                        });
                        gameRef.update({ boardData: { ...newBoardData, board: boardAsMap } });
                    }
                }

                if (data.boardData?.board) {
                    setBoard(Object.values(data.boardData.board));
                }

                if (data.boardData && data.players[username]) {
                    setIsLoading(false);
                    clearTimeout(connectionTimeout);
                }
            });

            return () => {
                clearTimeout(connectionTimeout);
                unsubGameState();
            };
        }
        else {
            setIsLoading(true);
            const modeName = config.name;
            const t = translations[language] || translations['en'];
            const savedStateForCurrentLevel = (initialSavedState && initialSavedState.level === level) ? initialSavedState : null;
            setScore(savedStateForCurrentLevel ? savedStateForCurrentLevel.score : 0);
            setFoundWords(savedStateForCurrentLevel ? savedStateForCurrentLevel.foundWords : []);
            setTimeLeft(savedStateForCurrentLevel ? savedStateForCurrentLevel.timeLeft : getInitialTime(modeName, level));
            setHiddenWordTimeLeft(null);
            setAllRequiredWordsFound(false);
            setLevelStartTime(Date.now());
            setHiddenWordAttempts(0);
            setSelectedCells([]);
            setJustFoundWordInfo(null);
            setGameState(null);
            setBoard(null);
            const newGameState = savedStateForCurrentLevel ? savedStateForCurrentLevel.gameState : createBoard(level, language, modeName, config.boardSize);
            if (newGameState && newGameState.board) {
                const boardData = newGameState.board;
                const finalBoard = Array.isArray(boardData) ? boardData : Object.values(boardData);
                const finalGameState = { ...newGameState, board: finalBoard };
                setGameState(finalGameState);
                setBoard(finalBoard);
                setError('');
            } else {
                setError(t.levelLoadError);
            }
            setIsLoading(false);
        }
    }, [gameId, isRealtimeDuel, language, username, level, handleCancelDuel, config, initialSavedState]);
        React.useEffect(() => {
            foundWordsRef.current = foundWords;
            computerStateRef.current = computerState;
        }, [foundWords, computerState]);


        React.useEffect(() => {
            if (isLoading || !isVsComputer || !gameState) {
                return;
            }

            const difficulty = config.difficulty || 'medium';
            const intervalTime = {
                easy: 15000,
                medium: 9000,
                hard: 5000
            }[difficulty];

            const computerMoveInterval = setInterval(() => {
                const currentFoundWords = foundWordsRef.current;
                const currentComputerState = computerStateRef.current;

                const allCurrentlyFound = [...currentFoundWords, ...currentComputerState.foundWords];
                const totalWords = gameState.words.length;
                if (totalWords > 0 && allCurrentlyFound.length >= totalWords) {
                    clearInterval(computerMoveInterval);
                    return;
                }

                const availableWords = gameState.words.filter(w => !allCurrentlyFound.includes(w.word));

                if (availableWords.length > 0) {
                    const wordToFind = _.sample(availableWords);
                    setComputerState(prev => ({
                        score: prev.score + (wordToFind.word.length * 5),
                        foundWords: [...prev.foundWords, wordToFind.word]
                    }));
                    playSound('correctSound');
                }
            }, intervalTime);

            return () => clearInterval(computerMoveInterval);
        }, [isLoading, isVsComputer, gameState, config.difficulty, playSound, setComputerState]);


        React.useEffect(() => {
            if (isLoading || !isVsComputer || !gameState) {
                return;
            }

            const totalWords = gameState.words.length;
            const totalFoundCount = foundWords.length + computerState.foundWords.length;
            if (totalWords > 0 && totalFoundCount >= totalWords) {
                const finalPlayerScore = score;
                const finalComputerScore = computerState.score;
                let resultTitle = '';
                let resultIcon = '🤝';

                if (finalPlayerScore > finalComputerScore) {
                    resultTitle = 'Tebrikler, Kazandın!';
                    resultIcon = '🏆';
                } else if (finalComputerScore > finalPlayerScore) {
                    resultTitle = 'Kaybettin!';
                    resultIcon = '😔';
                } else {
                    resultTitle = 'Berabere!';
                }

                setModalContent({
                    isOpen: true,
                    title: resultIcon + " " + resultTitle,
                    onClose: goToHome,
                    children: (
                        <div className="text-center">
                            <p className="text-xl mb-4 font-semibold">{`Sen: ${finalPlayerScore}`}</p>
                            <p className="text-xl mb-6 font-semibold">{`Bilgisayar: ${finalComputerScore}`}</p>
                            <button onClick={goToHome} className="bg-blue-600 text-white px-5 py-2 rounded-lg font-medium">Ana Menüye Dön</button>
                        </div>
                    )
                });
            }
        }, [foundWords, computerState, score, isVsComputer, isLoading, gameState, setModalContent, goToHome]);

            React.useEffect(() => {
                if (isRealtimeDuel || !gameState) return;
                const areAllFound = gameState.words.length > 0 && foundWords.length === gameState.words.length;
                setAllRequiredWordsFound(areAllFound);
            }, [foundWords, gameState, isRealtimeDuel]);

        React.useEffect(() => {
            if (isRealtimeDuel || config?.isOneShot) return;
            if (gameState && !isLoading) {
                const gameStateToSave = {
                    level,
                    score,
                    foundWords,
                    timeLeft,
                    gameState,
                    mode: config.name,
                    language: language,
                    difficulty: config.difficulty,
                    boardSize: config.boardSize,
                };
                try {
                    const currentSaves = JSON.parse(localStorage.getItem(ALL_SAVES_KEY)) || {};
                    currentSaves[config.name] = gameStateToSave;
                    currentSaves.lastPlayed = config.name;
                    localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
                } catch (e) {
                    console.error("Oyun kaydedilirken hata:", e);
                }
            }
        }, [gameState, isLoading, level, config, language, score, foundWords, timeLeft, isRealtimeDuel]);

            React.useEffect(() => {
                if (allRequiredWordsFound && gameState && !isRealtimeDuel && gameState.scatteredHiddenLetterPositions) {
                    const letters = gameState.scatteredHiddenLetterPositions.map((pos) => ({ id: `letter-${pos.row}-${pos.col}`, char: gameState.board[pos.row][pos.col], }));
                    const wordLength = gameState.hiddenWord.length;
                    setAnswerSlots(Array(wordLength).fill(null));
                    setHintLockedSlots([]);
                    if (wordLength >= 8) {
                        const firstChar = gameState.hiddenWord[0];
                        const hintLetterIndex = letters.findIndex(l => l.char === firstChar);
                        if (hintLetterIndex > -1) {
                            const hintLetter = letters.splice(hintLetterIndex, 1)[0];
                            const finalAnswerSlots = Array(wordLength).fill(null);
                            finalAnswerSlots[0] = hintLetter;
                            setAnswerSlots(finalAnswerSlots);
                            setHintLockedSlots([0]);
                        }
                    }
                    setSourceLetters(_.shuffle(letters));
                }
           }, [allRequiredWordsFound, gameState, isRealtimeDuel, isVsComputer]);

            React.useEffect(() => {
                if (!config.name?.startsWith('timed') || !gameState || modalContent.isOpen || isRealtimeDuel) return;
                if (allRequiredWordsFound) {
                    if (hiddenWordTimeLeft === 0) {
                        vibrate('error');
                        setModalContent({ isOpen: true, title: "Süre Bitti!", onClose: goToHome, children: ( <div className="flex flex-col items-center gap-4"> <p className="text-lg text-gray-700 text-center">Tüh! Süre bitti.<br/>Bulman gereken gizli kelime <b className="text-red-600">{gameState.hiddenWord}</b> idi.</p> <button onClick={goToHome} className="bg-blue-600 text-white px-6 py-2 rounded-lg font-medium">{t.homeButton}</button> </div> ) });
                        return;
                    }
                    const timerId = setInterval(() => setHiddenWordTimeLeft(t => t > 0 ? t - 1 : 0), 1000);
                    return () => clearInterval(timerId);
                } else {
                    if (timeLeft === 0) {
                        vibrate('error');
                        setModalContent({ isOpen: true, title: t.timeUp, onClose: goToHome, children: ( <div> <p className="text-xl mb-4">{t.finalScore(score)}</p> <button onClick={goToHome} className="bg-blue-600 text-white px-5 py-2 rounded-lg font-medium">{t.homeButton}</button> </div> ) });
                        return;
                    }
                    const timerId = setInterval(() => setTimeLeft(t => t > 0 ? t - 1 : 0), 1000);
                    return () => clearInterval(timerId);
                }
            }, [timeLeft, hiddenWordTimeLeft, config, gameState, modalContent.isOpen, allRequiredWordsFound, isRealtimeDuel]);

            React.useEffect(() => {
                if (allRequiredWordsFound && config.name?.startsWith('timed') && hiddenWordTimeLeft === null && !isRealtimeDuel && !isVsComputer) {
                const wordLength = gameState?.hiddenWord?.length || 5;
                const duration = 15 + (wordLength * 5);
                setHiddenWordTimeLeft(duration);
            }
        }, [allRequiredWordsFound, config, hiddenWordTimeLeft, gameState, isRealtimeDuel, isVsComputer]);


        React.useEffect(() => {
                if (isRealtimeDuel && realtimeGameData?.status === 'finished') {
                    const isWinner = realtimeGameData.winner === username;
                    const isDraw = realtimeGameData.winner === 'draw';
                    if (isWinner) {
                        triggerConfetti();
                    }
                    const myInfo = realtimeGameData.players[username];
                    const opponentInfo = realtimeGameData.players[Object.keys(realtimeGameData.players).find(p => p !== username)];
                    if (isWinner && realtimeGameData.reason) {
                        setModalContent({
                            isOpen: true,
                            title: "Tebrikler, Kazandınız!",
                            onClose: goToHome,
                            children: (
                                <div className="text-center text-gray-800">
                                    <div className="text-6xl mb-4">🎉</div>
                                    <p className="text-gray-700 text-lg mb-6">Rakibiniz oyundan ayrıldığı için galibiyet sizin.</p>
                                    <button
                                        onClick={goToHome}
                                        className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg"
                                    >
                                        Ana Sayfaya Dön
                                    </button>
                                </div>
                            )
                        });
                        return;
                    }

                    let cardClass = 'from-gray-700 to-gray-900';
                    let title = 'KAYBETTİNİZ';
                    let icon = '😔';
                    if (isWinner) {
                        cardClass = 'from-green-500 to-teal-600';
                        title = 'KAZANDINIZ!';
                        icon = '🏆';
                    } else if (isDraw) {
                        cardClass = 'from-blue-500 to-indigo-600';
                        title = 'BERABERE!';
                        icon = '🤝';
                    }

                    setModalContent({
                        isOpen: true,
                        title: title,
                        onClose: goToHome,
                        children: (
                             <div className={`relative w-full max-w-sm text-white bg-gradient-to-br ${cardClass} rounded-2xl shadow-2xl p-6 text-center`}>
                                <div className="text-6xl mb-4">{icon}</div>
                                <h2 className="text-4xl font-black tracking-tighter mb-2">{title}</h2>
                                <div className="bg-black/20 rounded-lg py-2 px-4 inline-block mb-4">
                                    <p className="text-3xl font-bold tabular-nums tracking-wide">
                                        {myInfo?.score || 0} - {opponentInfo?.score || 0}
                                    </p>
                                </div>
                                <button onClick={goToHome} className="w-full mt-4 bg-white/90 hover:bg-white text-gray-800 font-bold py-3 px-8 rounded-lg shadow-lg">
                                    Ana Sayfaya Dön
                                </button>
                            </div>
                        )
                    });
                }
            }, [realtimeGameData]);

        React.useEffect(() => {
            if (!isRealtimeDuel || !realtimeGameData || realtimeGameData.status !== 'active') {
                return;
            }

            const allWordsInLevel = realtimeGameData.boardData?.words;
            if (!allWordsInLevel || allWordsInLevel.length === 0) {
                return;
            }

            const myInfo = realtimeGameData.players[username];
            const opponentName = Object.keys(realtimeGameData.players).find(p => p !== username);
            const opponentInfo = opponentName ? realtimeGameData.players[opponentName] : null;

            if (!myInfo || !opponentInfo) return; // Rakip bilgisi henüz yoksa bekle

            const allFoundWords = new Set([...myInfo.foundWords, ...opponentInfo.foundWords]);
            if (allFoundWords.size >= allWordsInLevel.length) {
                let winner;
                if (myInfo.score > opponentInfo.score) {
                    winner = username;
                } else if (opponentInfo.score > myInfo.score) {
                    winner = opponentName;
                } else {
                    winner = 'draw';
                }
                db.collection('active-duels').doc(gameId).update({
                    status: 'finished',
                    winner: winner
                }).catch(err => {
                    console.error("Düello durumu güncellenirken hata oluştu:", err);
                });
            }
        }, [realtimeGameData, gameId, isRealtimeDuel, username]); // Bu hook, oyun verisi her değiştiğinde çalışır

        if (isRealtimeDuel) {
            if (isLoading || !realtimeGameData || !board) {
                return (
                    <div className="flex flex-col items-center justify-center h-full bg-indigo-50 text-center p-4">
                        {/* Yüklenme animasyonu */}
                        <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-indigo-600 mb-6"></div>

                        <h2 className="text-2xl font-bold text-indigo-800">Oyun Yükleniyor...</h2>
                        <p className="text-lg text-gray-600 mt-2">Rakip bekleniyor, lütfen sabırlı olun.</p>

                        {/* Hata mesajı alanı */}
                        {error && <p className="text-red-500 font-semibold mt-4">{error}</p>}

                        {/* İptal Et Butonu */}
                        <button
                            onClick={handleCancelDuel}
                            className="mt-10 px-8 py-3 bg-red-600 text-white font-bold rounded-lg shadow-md hover:bg-red-700 transition-all"
                        >
                            İptal Et ve Geri Dön
                        </button>
                    </div>
                );
            }
            if (error) return <div className="flex flex-col items-center justify-center h-full bg-red-50 text-red-600 text-lg p-4">{error}</div>;

            const opponentName = Object.keys(realtimeGameData.players).find(p => p !== username);
            const myInfo = realtimeGameData.players[username];
            const opponentInfo = opponentName ? realtimeGameData.players[opponentName] : { score: 0, foundWords: [] };
            const allFoundWordsCombined = new Set([...myInfo.foundWords, ...(opponentInfo.foundWords || [])]);
            const allWordsInLevel = realtimeGameData.boardData ? realtimeGameData.boardData.words : [];

            return (
                 <div className="h-full w-full flex flex-col items-center py-2 sm:py-4 bg-indigo-50">
        <div className="container w-full h-full flex flex-col gap-1 text-center text-gray-800 p-1">
                         {disconnectionInfo.isDisconnected && ( <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-[100] text-center p-4"><div className="animate-spin rounded-full h-16 w-16 border-b-2 border-sky-400 mb-6"></div><h2 className="text-2xl font-bold text-slate-100 mb-2">Bağlantı Sorunu</h2><p className="text-slate-300 mb-4">{disconnectionInfo.message}</p><p className="text-4xl font-mono font-bold text-white">{disconnectionInfo.countdown}</p><button onClick={goToHome} className="mt-8 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-lg transition-all">Beklemeyi İptal Et & Lobiye Dön</button></div> )}
                         {realtimeGameData.status === 'finished' && (()=>{/*...oyun sonu modalı olduğu gibi kalır...*/})()}

                        <div className="flex-shrink-0 w-full">
                            <div className="flex justify-between items-center bg-white p-1.5 rounded-lg shadow-sm">
                                <div className="flex items-center gap-2"><span className="font-semibold text-sm truncate text-indigo-700">{username} (Siz)</span><span className="text-lg font-bold text-green-600">{myInfo.score}</span></div>
                                <span className="text-sm font-bold text-gray-400">VS</span>
                                <div className="flex items-center gap-2"><span className="font-semibold text-sm truncate text-gray-600">{opponentName || 'Rakip...'}</span><span className="text-lg font-bold text-red-600">{opponentInfo.score}</span></div>
                            </div>
                        </div>

                        <div
                            ref={gridRef}
                            className="flex-shrink-0 grid gap-0.5 p-1 rounded-lg bg-indigo-100 w-full max-w-2xl mx-auto aspect-square shadow-inner"
                            style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }}
                            onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)} onMouseMove={(e) => { if (isSwiping) throttledMove(e.clientX, e.clientY); }} onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd} onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)} onTouchMove={(e) => { if (isSwiping) throttledMove(e.touches[0].clientX, e.touches[0].clientY); }} onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd}
                        >
                            {board.map((row, r) => row.map((letter, c) => {
                                const isSelected = isCellSelected(r, c);
                                const owner = cellOwnerMap[`${r}-${c}`];
                                let cellClass = 'bg-white hover:bg-gray-200';
                                if (isSelected) { cellClass = 'bg-yellow-300 text-black transform scale-110 shadow-lg'; }
                                else if (owner) { const color = playerColors[owner]; if (color === 'green') { cellClass = 'bg-green-300 text-green-800'; } else if (color === 'red') { cellClass = 'bg-red-300 text-red-800'; } }
                                return (<div key={`${r}-${c}`} className={`flex items-center justify-center aspect-square text-center font-semibold rounded-sm text-sm sm:text-base transition-all duration-150 select-none ${cellClass}`}>{letter}</div>);
                            }))}
                        </div>

                        <div className="flex-1 min-h-0 w-full max-w-2xl mx-auto">
                            <div className="bg-white rounded-lg p-1 shadow h-full overflow-y-auto scrollbar-thin">
                                <div className="flex flex-wrap justify-center content-start gap-x-1.5 gap-y-1 p-1">
                                    {allWordsInLevel.map(({ word }) => {
                                        const isFound = allFoundWordsCombined.has(word);
                                        const isHidden = realtimeGameData.difficulty === 'hard' && !isFound;
                                        return ( <span key={word} className={`font-medium transition-all duration-300 rounded-md px-2 py-1 text-xs ${isFound ? 'bg-gray-300 text-gray-500 line-through opacity-50' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : 'bg-indigo-100 text-gray-800'}`}> {isHidden ? '???' : word} </span> );
                                    })}
                                </div>
                            </div>
                        </div>

                         <div className="flex-shrink-0 w-full">
                            <button onClick={showExitConfirmation} className="w-full py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition-all text-sm">Oyundan Çık (Terk Et)</button>
                         </div>

                         <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.children}</Modal>
        {toastMessage && (
            <div className="toast-notification fixed bottom-24 left-1/2 -translate-x-1/2 bg-indigo-600 text-white font-bold py-3 px-6 rounded-full shadow-lg z-50">
                {toastMessage}
            </div>
        )}



                    </div>
                </div>
            );
        }

        if (isVsComputer) {
            if (isLoading || !gameState || !board) {
                return <div className="flex items-center justify-center h-full bg-indigo-50 text-indigo-700 text-lg font-semibold">Oyun Yükleniyor...</div>;
            }

            const allWordsInLevel = gameState.words;
            const allFoundWordsCombined = new Set([...foundWords, ...computerState.foundWords]);

            return (
                <div className="h-full w-full flex flex-col items-center py-2 sm:py-4 bg-indigo-50">
        <div className="container w-full h-full flex flex-col gap-1 text-center text-gray-800 p-1">
                        <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.children}</Modal>

                        <div className="flex-shrink-0 w-full">
                            <div className="flex justify-between items-center bg-white p-1.5 rounded-lg shadow-sm">
                                <div className="flex items-center gap-2 w-2/5 justify-start"><span className="font-semibold text-sm truncate text-indigo-700">Siz</span><span className="text-lg font-bold text-green-600">{score}</span></div>
                                <span className="text-sm font-bold text-gray-400">VS</span>
                                <div className="flex items-center gap-2 w-2/5 justify-end"><span className="font-semibold text-sm truncate text-gray-600">Bilgisayar ({config.difficulty})</span><span className="text-lg font-bold text-red-600">{computerState.score}</span></div>
                            </div>
                        </div>

                        <div
                            ref={gridRef}
                            className="flex-shrink-0 grid gap-0.5 p-1 rounded-lg bg-indigo-100 w-full max-w-2xl mx-auto aspect-square shadow-inner"
                            style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }}
                            onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)} onMouseMove={(e) => { if (isSwiping) throttledMove(e.clientX, e.clientY); }} onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd} onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)} onTouchMove={(e) => { if (isSwiping) throttledMove(e.touches[0].clientX, e.touches[0].clientY); }} onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd}
                        >
                            {board.map((row, r) => row.map((letter, c) => {
                                const isSelected = isCellSelected(r, c);
                                const isFoundByPlayer = gameState.words.some(w => foundWords.includes(w.word) && w.positions.some(p => p.row === r && p.col === c));
                                const isFoundByComputer = gameState.words.some(w => computerState.foundWords.includes(w.word) && w.positions.some(p => p.row === r && p.col === c));
                                let cellClass = 'bg-white hover:bg-gray-200';
                                if (isSelected) { cellClass = 'bg-yellow-300 text-black transform scale-110 shadow-lg'; }
                                else if (isFoundByPlayer) { cellClass = 'bg-green-300 text-green-800'; }
                                else if (isFoundByComputer) { cellClass = 'bg-red-300 text-red-800'; }
                                return (<div key={`${r}-${c}`} className={`flex items-center justify-center aspect-square text-center font-semibold rounded-sm text-sm sm:text-base transition-all duration-150 select-none ${cellClass}`}>{letter}</div>);
                            }))}
                        </div>

                        <div className="flex-1 min-h-0 w-full max-w-2xl mx-auto">
                            <div className="bg-white rounded-lg p-1 shadow h-full overflow-y-auto scrollbar-thin">
                                <div className="flex flex-wrap justify-center content-start gap-x-1.5 gap-y-1 p-1">
                                    {allWordsInLevel.map(({ word }) => {
                                        const isFound = allFoundWordsCombined.has(word);
                                        const isHidden = config.difficulty === 'hard' && !isFound;
                                        return (<span key={word} className={`font-medium transition-all duration-300 rounded-md px-2 py-1 text-xs ${isFound ? 'bg-gray-300 text-gray-500 line-through opacity-50' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : 'bg-indigo-100 text-gray-800'}`}>{isHidden ? '???' : word}</span>);
                                    })}
                                </div>
                            </div>
                        </div>

                        <div className="flex-shrink-0 w-full">
                            <button onClick={showExitConfirmation} className="w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition-all text-sm">Ana Menüye Dön</button>
                        </div>

                    </div>
                </div>
            );
        }
            if (isLoading || !gameState || !board) { return <div className="flex items-center justify-center h-full text-lg font-semibold text-indigo-700">{t.loadingLevel(level + 1)}</div>; }
            if (error) { return (<div className="flex flex-col items-center justify-center h-full p-4 text-center"><p className="text-lg font-semibold text-red-600">{error}</p><button onClick={goToHome} className="mt-4 bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600">Ana Sayfaya Dön</button></div>); }
            const theme = (config.name === 'hard' || config.name === 'timed-hard') ? { bg: 'bg-red-50', foundCell: 'bg-red-200', hiddenWordCell: 'bg-blue-400 text-white font-bold', wordBg: 'bg-red-100', gridBg: 'bg-red-100', button: 'bg-red-600 hover:bg-red-700', inputBorder: 'border-red-300 focus:border-red-500', selectedCell: 'bg-yellow-400', obscuredCell: 'bg-gray-400 text-transparent opacity-50' } : { bg: 'bg-indigo-50', foundCell: 'bg-green-200', hiddenWordCell: 'bg-blue-400 text-white font-bold', wordBg: 'bg-indigo-100', gridBg: 'bg-indigo-100', button: 'bg-indigo-600 hover:bg-indigo-700', inputBorder: 'border-indigo-300 focus:border-indigo-500', selectedCell: 'bg-yellow-300', obscuredCell: 'bg-gray-400 text-transparent opacity-50' };

return (
    <div className={`h-screen w-full flex flex-col p-2 gap-2 text-center overflow-hidden ${theme.bg}`}>

        {/* 1. ÜST İSTATİSTİK BARI (Sabit) */}
        <div className="w-full flex-shrink-0 grid grid-cols-4 gap-2">
            <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm" title={t.level}><span className="text-xl">🏆</span><span className="font-bold text-sm text-indigo-600">{level + 1}</span></div>
            <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm" title={t.score}><span className="text-xl">⭐</span><span className="font-bold text-sm text-green-600">{score}</span></div>
            <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm" title={t.gold}><span className="text-xl">💰</span><span className="font-bold text-sm text-amber-600">{stats.gold || 0}</span></div>
            <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm">
                {(config.name?.startsWith('timed') && !allRequiredWordsFound) ? ( <div key={timeLeft} className="animate-timer-pulse flex items-center justify-center gap-1 text-blue-600 tabular-nums" title="Kalan Süre"> <span className="text-xl">⏱️</span> <span className="font-bold text-sm">{Math.floor(timeLeft / 60)}:{(timeLeft % 60).toString().padStart(2, '0')}</span> </div> ) : ( <div className="flex items-center justify-center gap-1 text-slate-400" title="Bu modda süre yoktur"> <span className="text-xl">⏱️</span> <span className="font-bold text-sm">-:--</span> </div> )}
            </div>
        </div>

        {/* --- YER DEĞİŞİKLİĞİ BAŞLANGICI --- */}

        {/* 3. KELİME LİSTESİ ALANI (Artık üstte ve esnek, kaydırılabilir) */}
        {!allRequiredWordsFound && (
            <div className="flex-1 min-h-0 p-2 bg-gray-100 rounded-lg overflow-y-auto scrollbar-thin flex justify-center items-start">
                <div className="flex flex-wrap justify-center items-center gap-x-2 gap-y-1">
                    {gameState.words.map(({ word }) => {
                        const isFound = foundWords.includes(word);
                        const isHidden = (config.name === 'hard' || config.name === 'timed-hard') && !isFound;
                        const sizeClasses = config.name === 'super-easy'
                            ? 'px-2 py-0.3 text-lg'
                            : 'px-1 py-0.3 text-base';
                        return (
                            <span
                                key={word}
                                className={`font-bold transition-all duration-500 rounded-lg ${sizeClasses} ${isFound ? 'bg-gray-300 text-gray-500 line-through opacity-50' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : theme.wordBg + ' text-gray-800'}`}
                            >
                                {isHidden ? '?????' : word}
                            </span>
                        );
                    })}
                </div>
            </div>
        )}

        {/* 2. OYUN ALANI (HARF TABLOSU) (Artık altta ve sabit) */}
        <div className="w-full flex-shrink-0">
            {
                !allRequiredWordsFound ? (
                    <div ref={gridRef} onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)} onMouseMove={(e) => { if (isSwiping) throttledMove(e.clientX, e.clientY); }} onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd} onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)} onTouchMove={(e) => { if (isSwiping) throttledMove(e.touches[0].clientX, e.touches[0].clientY); }} onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd}
                         className={`grid gap-0.5 content-start rounded-lg shadow-md w-full max-w-full mx-auto aspect-square ${theme.gridBg}`} style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }}>
                       {(() => {
                            const numCols = board[0] ? board[0].length : 1;
                            return board.map((row, rowIndex) => row.map((letter, colIndex) => { const isSelected = isCellSelected(rowIndex, colIndex); const isFoundPart = isCellFound(rowIndex, colIndex); const isJustFound = justFoundWordInfo?.positions.some(p => p.row === rowIndex && p.col === colIndex); const isBonusGlowCell = bonusGlowCells.some(cell => cell.row === rowIndex && cell.col === colIndex); return <Cell key={`${rowIndex}-${colIndex}`} letter={letter} isSelected={isSelected} isFoundRequiredPart={isFoundPart} allRequiredWordsFound={false} isJustFound={isJustFound} isBonusGlow={isBonusGlowCell} theme={theme} numCols={numCols} />; }) );
                        })()}
                    </div>
                ) : (
                    <div className="w-full h-full flex items-center justify-center overflow-y-auto overflow-x-hidden scrollbar-thin bg-white rounded-lg">
                        <div className="w-full max-w-2xl mx-auto p-2">
                            <p className="font-bold text-lg text-indigo-700">{t.hiddenWord}</p>
                            {hiddenWordTimeLeft !== null && <div key={hiddenWordTimeLeft} className="animate-timer-pulse text-xl font-bold text-red-600 my-2">Kalan Süre: {hiddenWordTimeLeft}s</div>}
                            <div id="answer-area-container" className={`my-2 p-1 bg-gray-200 rounded-lg w-full flex flex-wrap justify-center gap-2 ${isShaking ? 'shake-animation' : ''}`}>{answerSlots.map((letter, index) => ( <div key={index} onClick={() => handleAnswerSlotClick(letter, index)} className={`w-12 h-12 aspect-square flex items-center justify-center rounded-md text-4xl leading-none font-bold transition-all ${hintLockedSlots.includes(index) ? 'bg-amber-300 cursor-not-allowed' : 'bg-white shadow-inner cursor-pointer hover:bg-red-100'} text-gray-800`}>{letter ? letter.char : ''}</div> ))}</div>
                            <p className="text-sm text-gray-600 mt-4 mb-2">Kalan Harfler</p>
                            <div className="p-2 bg-gray-200 rounded-lg w-full flex flex-wrap justify-center gap-2 min-h-[64px]">{sourceLetters.map(letter => ( <button key={letter.id} onClick={() => handleSourceLetterClick(letter)} className="w-12 h-12 flex items-center justify-center rounded-md bg-sky-500 text-white text-2xl font-bold shadow-md hover:bg-sky-600 active:scale-90 transition-all">{letter.char}</button> ))}</div>
                            <button onClick={handleCheckHiddenWord} disabled={answerSlots.some(l => l === null)} className="mt-4 w-full bg-green-500 text-white rounded-lg py-3 font-bold hover:bg-green-600 transition-transform active:scale-95 disabled:bg-gray-400 disabled:cursor-not-allowed">{t.checkButton}</button>
                        </div>
                    </div>
                )
            }
        </div>
        {/* --- YER DEĞİŞİKLİĞİ SONU --- */}

        {/* 4. ALT BUTONLAR (Sabit) */}
        <div className="w-full flex-shrink-0 grid grid-cols-2 gap-2">
            <button onClick={handleGoHomeClick} title={t.homeButton} className="w-full rounded-xl p-2 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-white/80 hover:bg-white border border-slate-200 text-slate-700"><span className="text-xl">🏠</span><span>Anasayfa</span></button>
            {allRequiredWordsFound ? ( <button onClick={handleHiddenWordHint} disabled={stats.gold < 1} className="w-full rounded-xl p-2 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-sky-500 hover:bg-sky-600 text-white disabled:bg-slate-400 disabled:text-white/80 disabled:cursor-not-allowed"> <span className="text-xl">🔑</span> <span>İpucu</span> <span className="opacity-80 font-normal">(-1💰)</span> </button> ) : ( <button onClick={handleRevealWordHint} disabled={stats.gold < 1 || (gameState && foundWords.length === gameState.words.length)} className="w-full rounded-xl p-2 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-amber-500 hover:bg-amber-600 text-white disabled:bg-slate-400 disabled:text-white/80 disabled:cursor-not-allowed"> <span className="text-xl">🔎</span> <span>Aç</span> <span className="opacity-80 font-normal">(-1💰)</span> </button> )}
        </div>

        <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.children}</Modal>
        {toastMessage && (
            <div className="toast-notification fixed bottom-24 left-1-2 -translate-x-1/2 bg-indigo-600 text-white font-bold py-3 px-6 rounded-full shadow-lg z-[9999]">
                {toastMessage}
            </div>
        )}
    </div>
);

        }
        const getInitialTime = (currentMode, currentLevel) => {
            if (!currentMode.startsWith('timed')) return 120;
            let baseTime = currentMode === 'timed-hard' ? 180 : 120;
            return baseTime + (currentLevel * 4);
        };
        function DuelModeModal({ isOpen, onClose, duelProgress, startGame, currentUser, goToHome }) {
            if (!isOpen || !duelProgress) return null;
            const t = translations['tr'] || translations['en'];
            const [activeTab, setActiveTab] = React.useState('super-easy');
            const [scores, setScores] = React.useState({});
            const [loading, setLoading] = React.useState(true);

            const duelModes = [
                { key: 'super-easy', title: t.superEasyMode, icon: '🧸', color: 'from-sky-500 to-cyan-400' },
                { key: 'easy', title: t.easyMode, icon: '😊', color: 'from-blue-500 to-indigo-500' },
                { key: 'hard', title: t.hardMode, icon: '🔥', color: 'from-purple-600 to-violet-600' },
                { key: 'timed-easy', title: t.timedEasyMode, icon: '⏱️', color: 'from-emerald-500 to-teal-500' },
                { key: 'timed-hard', title: t.timedHardMode, icon: '⚡', color: 'from-slate-700 to-gray-800' }
            ];

            const leaderboardTabs = [
                { key: 'super-easy', line1Key: 'çok', line2Key: 'kolay', activeBg: 'bg-green-500' },
                { key: 'easy', line1Key: 'kolay', line2Key: 'normal', activeBg: 'bg-teal-500' },
                { key: 'hard', line1Key: 'zor', line2Key: 'normal', activeBg: 'bg-red-500' },
                { key: 'timed-easy', line1Key: 'süreli', line2Key: 'kolay', activeBg: 'bg-blue-500' },
                { key: 'timed-hard', line1Key: 'süreli', line2Key: 'zor', activeBg: 'bg-orange-500' }
            ];

            React.useEffect(() => {
                if (isOpen) {
                    setLoading(true);
                    const fetchPromises = leaderboardTabs.map(tab =>
                        db.collection("duel-scores")
                            .where("mode", "==", tab.key)
                            .orderBy("score", "desc")
                            .limit(50)
                            .get()
                    );
                    Promise.all(fetchPromises)
                        .then(snapshots => {
                            const newScores = {};
                            snapshots.forEach((snapshot, index) => {
                                const mode = leaderboardTabs[index].key;
                                newScores[mode] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            });
                            setScores(newScores);
                        })
                        .catch(error => console.error("Düello liderlik tablosu verileri çekilirken hata oluştu:", error))
                        .finally(() => setLoading(false));
                }
            }, [isOpen]);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-2 sm:p-4" onClick={onClose}>
                    <div className="bg-white dark:bg-gray-900 p-4 sm:p-6 rounded-2xl shadow-2xl max-w-4xl w-full text-center relative max-h-[95vh] overflow-y-auto scrollbar-thin" onClick={e => e.stopPropagation()}>
                        <h3 className="text-3xl sm:text-4xl font-black mb-6 text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-indigo-600">🏆 DÜELLO MEYDANI 🏆</h3>
                        <button onClick={onClose} className="absolute top-3 right-3 text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 text-4xl">&times;</button>

                        <div className="grid grid-cols-2 gap-3 sm:gap-4 mb-8">
                            {duelModes.map(modeInfo => {
                                const progress = duelProgress[modeInfo.key] || { currentLevel: 0, cumulativeScore: 0 };
                                return (
                                    <div key={modeInfo.key} className={`flex flex-col text-white rounded-2xl shadow-lg bg-gradient-to-br ${modeInfo.color} transform hover:-translate-y-1 transition-transform`}>
                                         <div className="flex justify-between items-start p-3 rounded-t-lg bg-black/20">
                                            <h4 className="text-lg sm:text-xl font-bold">{modeInfo.title}</h4>
                                            <span className="text-3xl sm:text-4xl opacity-80">{modeInfo.icon}</span>
                                        </div>
                                        <div className="bg-black/10 p-3 text-xs sm:text-sm space-y-1 text-left">
                                            <p>Mevcut Seviye: <span className="font-bold sm:text-base">{progress.currentLevel + 1}</span></p>
                                            <p>Toplam Puan: <span className="font-bold sm:text-base">{progress.cumulativeScore}</span></p>
                                        </div>
                                        <button onClick={() => startGame(modeInfo.key)} className="w-full bg-white/30 hover:bg-white/40 backdrop-blur-sm font-bold py-2 sm:py-3 rounded-b-lg transition-all text-base sm:text-lg">
                                            {progress.currentLevel > 0 ? 'DEVAM ET' : 'BAŞLA'}
                                        </button>
                                     </div>
                                );
                            })}
                        </div>

                        <hr className="my-6 border-gray-300 dark:border-gray-700"/>

                        <div>
                             <div className="flex justify-between items-center mb-4 px-1">
                                <h4 className="text-2xl font-bold text-gray-800 dark:text-gray-100 uppercase">DÜELLO LİDERLERİ</h4>
                                <button onClick={onClose} className="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all text-sm flex items-center gap-2">
            🏠 <span>Anasayfa</span>
        </button>
                            </div>
                            <div className="flex items-center border-b-2 border-gray-200 dark:border-gray-700">
                                 {leaderboardTabs.map(tab => {
                                     const isActive = activeTab === tab.key;
                                     return (
                                         <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`flex-1 flex flex-col justify-center items-center h-14 py-1 text-center transition-all duration-300 border-x border-transparent ${isActive ? `${tab.activeBg} scale-105 z-10 rounded-t-lg` : 'hover:bg-gray-100 dark:hover:bg-gray-800'}`}>
                                             <span className={`block text-xs font-bold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}>
                                                 {t[tab.line1Key]}
                                             </span>
                                             <span className={`block text-xs font-semibold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}>
                                                 {t[tab.line2Key]}
                                             </span>
                                         </button>
                                     );
                                 })}
                             </div>
                            <div className="min-h-[250px]">
                            {loading
                                ? <p className="text-gray-600 dark:text-gray-400 pt-10">Liderlik tablosu yükleniyor...</p>
                                : <DuelLeaderboardDisplay scores={scores[activeTab]} currentUser={currentUser} />
                            }
                        </div>
                    </div>
                </div>
            </div>
        );
        }
            function UsernamePrompt({ onSave }) { const [name, setName] = React.useState(''); const [isLoading, setIsLoading] = React.useState(false); const [error, setError] = React.useState(''); const handleSave = async () => { if (!name.trim()) return; setIsLoading(true); setError(''); const success = await onSave(name.trim()); if (!success) { setError('Bu kullanıcı adı zaten alınmış. Lütfen başka bir tane deneyin.'); setIsLoading(false); } }; return ( <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4"> <div className="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm text-center"> <h3 className="text-2xl font-bold mb-4 text-gray-800">Oyuna Hoş Geldin!</h3> <p className="text-gray-600 mb-5">Liderlik tablosu için benzersiz bir kullanıcı adı belirle.</p> <input type="text" value={name} onChange={(e) => setName(e.target.value)} className="w-full border-2 border-gray-300 p-2 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-indigo-400" placeholder="Kullanıcı adınız..." maxLength={15} disabled={isLoading} /> {error && <p className="text-red-500 text-sm mt-2">{error}</p>} <button onClick={handleSave} disabled={!name.trim() || isLoading} className="w-full mt-4 bg-indigo-600 text-white font-bold px-6 py-3 rounded-lg hover:bg-indigo-700 transition-all shadow-lg disabled:bg-gray-400 disabled:cursor-not-allowed" > {isLoading ? 'Kontrol ediliyor...' : 'Kaydet ve Başla'} </button> </div> </div> ); }

            function DuelLeaderboardDisplay({ scores, currentUser }) {
                if (!scores || scores.length === 0) {
                    return <p className="text-gray-600 dark:text-gray-400 pt-10">Bu düello kategorisinde henüz skor bulunmuyor.</p>;
                }
                const rankIcons = ['🥇', '🥈', '🥉'];
                return (
                    <div className="text-left overflow-y-auto max-h-[250px] mt-4 pr-2 scrollbar-thin">
                        <ul className="space-y-2">
                            {scores.map((score, index) => {
                                const isCurrentUser = score.username === currentUser;
                                return (
                                    <li key={score.id || index} className={`flex items-center p-3 rounded-lg transition-all ${isCurrentUser ? 'bg-purple-100 dark:bg-purple-800/20 border-2 border-purple-400' : 'bg-gray-50 dark:bg-gray-800'}`}>
                                        <span className="font-bold text-lg w-10 text-center text-gray-500 dark:text-gray-400">{rankIcons[index] || index + 1}</span>
                                        <div className="flex-1">
                                            <p className={`font-semibold text-gray-800 dark:text-gray-200 ${isCurrentUser ? 'text-purple-900 dark:text-purple-300' : ''}`}>{score.username}</p>
                                            <p className={`text-xs text-gray-500 dark:text-gray-400 ${isCurrentUser ? 'text-purple-800 dark:text-purple-400' : ''}`}>Seviye {score.level}</p>
                                        </div>
                                        <span className={`font-bold text-xl text-indigo-600 dark:text-indigo-400 tabular-nums ${isCurrentUser ? 'text-purple-900 dark:text-purple-300' : ''}`}>{score.score}</span>
                                    </li>
                                );
                            })}
                        </ul>
                    </div>
                );
            }


            function LobbyPage({ username, goToHome, startGame, language }) {
                const [players, setPlayers] = React.useState([]);
                const [invitedPlayer, setInvitedPlayer] = React.useState(null);
                const [selectedSizes, setSelectedSizes] = React.useState({});
                const [selectedDifficulties, setSelectedDifficulties] = React.useState({});
                const handleDifficultyChange = (playerUsername, difficulty) => {
                    setSelectedDifficulties(prev => ({ ...prev, [playerUsername]: difficulty }));};
                const [lobbyStatus, setLobbyStatus] = React.useState('idle');
                const handleSizeChange = (playerUsername, size) => {
                    setSelectedSizes(prev => ({ ...prev, [playerUsername]: size }));
                };

            React.useEffect(() => {
                    const heartbeatInterval = setInterval(() => {
                        if (username) {
                            db.collection('lobby').doc(username).update({
                                last_active: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                    }, 15000);

                    return () => clearInterval(heartbeatInterval);
                }, [username]);

                React.useEffect(() => {
                    if (!username) return;
                    const userDocRef = db.collection('lobby').doc(username);

                    const unsubscribe = userDocRef.onSnapshot(doc => {
                        const data = doc.data();
                        if (data) {
                            setLobbyStatus(data.status || 'idle');
                        }
                    });

                    return () => unsubscribe();
                }, [username]);


                React.useEffect(() => {
                    const onbeforeunload = () => {
                         if (username) db.collection('lobby').doc(username).delete();
                    };
                    window.addEventListener('beforeunload', onbeforeunload);
                    return () => window.removeEventListener('beforeunload', onbeforeunload);
                }, [username]);


            React.useEffect(() => {
                const cutoff = new Date(Date.now() - 30000);
                const unsubscribe = db.collection('lobby')
                    .where('last_active', '>', cutoff)
                    .onSnapshot(snapshot => {
                        const lobbyPlayers = snapshot.docs
                            .map(doc => doc.data())
                            .filter(player => player.username !== username && player.status === 'idle');
                        const sortedPlayers = lobbyPlayers.sort((a, b) => b.joinedAt.toMillis() - a.joinedAt.toMillis());
                        setPlayers(sortedPlayers);
                    });

                return () => unsubscribe();
            }, [username]);


            const sendInvitation = async (targetPlayer) => {
                    if (!username || !targetPlayer || invitedPlayer) return;
                    setInvitedPlayer(targetPlayer.username);
                    const gameId = [username, targetPlayer.username].sort().join('_');
                    const gameRef = db.collection('active-duels').doc(gameId);
                    await gameRef.set({
                        gameId: gameId,
                        status: 'pending',
                        boardSize: selectedSizes[targetPlayer.username] || 'small',
                        difficulty: selectedDifficulties[targetPlayer.username] || 'easy',
                         invitedBy: username,
                        players: { [username]: { score: 0, foundWords: [] }, [targetPlayer.username]: { score: 0, foundWords: [] } },
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    const myLobbyRef = db.collection('lobby').doc(username);
                    const opponentLobbyRef = db.collection('lobby').doc(targetPlayer.username);
                    db.runTransaction(async (transaction) => {
                       transaction.update(myLobbyRef, { status: 'waiting_for_opponent', gameId: gameId });
                       transaction.update(opponentLobbyRef, { status: 'invited', gameId: gameId, invitedBy: username });
                    });
                };

                const sizeOptions = [
                    { value: 'small', label: 'Küçük' },
                    { value: 'medium', label: 'Orta' },
                    { value: 'large', label: 'Büyük' },
                ];

                if (lobbyStatus === 'waiting_for_opponent') {
                    return (
                        <div className="h-full w-full bg-gradient-to-br from-gray-800 to-slate-900 text-white flex flex-col items-center justify-center text-center p-4">
                            <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-sky-400 mb-6"></div>
                            <h1 className="text-3xl font-black text-slate-100 mb-2">Rakibin Onayı Bekleniyor</h1>
                            <p className="text-slate-400">Lütfen bekleyin...</p>
                             <button onClick={goToHome} className="mt-12 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all text-sm">
                                İptal Et ve Geri Dön
                            </button>
                        </div>
                    );
                }

                return (
                    <div className="h-full w-full bg-gradient-to-br from-gray-800 to-slate-900 text-white overflow-y-auto">
                        <div className="container mx-auto px-4 py-8 text-center">
                            <h1 className="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-indigo-400 drop-shadow-lg mb-2">
                                ONLINE DÜELLO LOBİSİ
                            </h1>
                            <p className="text-slate-400 mb-8">Yarışmak için bir oyuncu ve oyun alanı boyutu seçin.</p>
                            <div className="max-w-md mx-auto">
                                <h2 className="text-xl font-bold text-slate-300 border-b-2 border-slate-700 pb-2 mb-4">Bekleyen Oyuncular</h2>
                                {players.length > 0 ? (
                                    <ul className="space-y-3">
                                        {players.map(player => (
            <li key={player.username} className="p-3 bg-slate-800/50 rounded-lg flex flex-col sm:flex-row items-center justify-between transition-all gap-3">
                <span className="font-bold text-lg">{player.username}</span>
                <div className="flex items-center gap-2">
                    {/* Boyut Seçimi */}
                    <div className="flex items-center bg-slate-700/50 rounded-full p-1">
                        {sizeOptions.map(opt => (
                            <button key={opt.value} onClick={() => handleSizeChange(player.username, opt.value)} className={`text-xs font-semibold px-3 py-1 rounded-full transition-colors ${(selectedSizes[player.username] || 'small') === opt.value ? 'bg-indigo-600 text-white' : 'text-slate-300 hover:bg-slate-600'}`}>
                                {opt.label}
                            </button>
                        ))}
                    </div>
                    {/* Zorluk Seçimi */}
                    <div className="flex items-center bg-slate-700/50 rounded-full p-1">
                        {[{ value: 'easy', label: 'Kolay' }, { value: 'hard', label: 'Zor' }].map(opt => (
                            <button key={opt.value} onClick={() => handleDifficultyChange(player.username, opt.value)} className={`text-xs font-semibold px-3 py-1 rounded-full transition-colors ${(selectedDifficulties[player.username] || 'easy') === opt.value ? 'bg-rose-600 text-white' : 'text-slate-300 hover:bg-slate-600'}`}>
                                {opt.label}
                            </button>
                        ))}
                    </div>
                    {/* Yarış Butonu */}
                    <button onClick={() => sendInvitation(player)} disabled={!!invitedPlayer} className="text-sm font-semibold text-green-400 bg-green-900/50 px-3 py-2 rounded-full hover:bg-green-800/80 transition-colors disabled:opacity-50 disabled:cursor-wait">
                        {invitedPlayer === player.username ? '...' : 'Yarış'}
                    </button>
                </div>
            </li>
                                        ))}
                                    </ul>
                                ) : (
                                    <p className="text-slate-500 mt-10">LOBİDE KİMSE YOK...</p>
                                )}
                            </div>
                             <button onClick={goToHome} className="mt-12 bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all text-sm flex items-center gap-2 mx-auto">
                                🏠 <span>Ana Sayfaya Dön</span>
                            </button>
                        </div>
                    </div>
                );
            }






window.androidBridge = {
    // Geri tuşu fonksiyonunuz aynı kalıyor
    onBackPress: () => {
        if (typeof window.androidBridge.registered_onBackPress === 'function') {
            window.androidBridge.registered_onBackPress();
        }
    },
    registered_onBackPress: null,

    // Token alma fonksiyonunuz aynı kalıyor
    receiveFCMToken: (token) => {
        console.log("WebAppLog: Android'den receiveFCMToken çağrıldı. Token:", token);
        pendingFCMToken = token;
        const currentUser = localStorage.getItem('wordHuntUsername');
        if (currentUser) {
            console.log("WebAppLog: Mevcut kullanıcı bulundu. Token kaydediliyor:", currentUser);
            saveTokenForUser(currentUser, token);
        } else {
            console.log("WebAppLog: Mevcut kullanıcı YOK. Token, giriş yapıldığında kaydedilmek üzere bekletiliyor.");
        }
    },

    // YENİ: Bildirimden gelen düello davetini karşılayan fonksiyon
    handleIncomingDuel: (duelId) => {
        console.log(`WebAppLog: Android'den düello daveti geldi! Düello ID: ${duelId}`);

        // BURADA KULLANICIYA BİR POPUP (MODAL) GÖSTERMELİSİNİZ.
        // Örnek:
        // showDuelInvitationModal(duelId);

        alert(`Bir düello davetiniz var! ID: ${duelId}\nBu daveti kabul veya reddetme arayüzünü burada oluşturmalısınız.`);

        // Kullanıcı bu modal'da "Kabul Et" butonuna tıklarsa,
        // o 'duelId' ile oyun sayfasına yönlendirme işlemini yaparsınız.
    }
};

let pendingFCMToken = null;

const saveTokenForUser = (username, token) => {
    if (username && token) {
        console.log(`WebAppLog: saveTokenForUser fonksiyonu çalıştı. Kullanıcı: ${username}`);
        const userRef = db.collection("users").doc(username);

        // Firestore'a yazma işlemi. merge:true, diğer alanları silmeden güncelleme yapar.
        userRef.set({ fcmToken: token }, { merge: true })
            .then(() => {
                console.log("WebAppLog: FCM token başarıyla Firestore'a kaydedildi.");
                pendingFCMToken = null;
            })
            .catch((err) => { // DÜZELTME BURADA: 'err' parametresini parantez içine ekleyin.
                console.error("WebAppLog: FCM token Firestore'a KAYDEDİLİRKEN HATA OLUŞTU:", err);
            });
    }
};



function App() {
    const [page, setPage] = React.useState('home');
    const [language, setLanguage] = React.useState('tr');
    const [modeConfig, setModeConfig] = React.useState({ name: 'easy' });
    const [gameStats, setGameStats] = React.useState(loadGameStats);
    const [modalContent, setModalContent] = React.useState({ isOpen: false, title: '', body: null });
    const [allSaves, setAllSaves] = React.useState(null);
    const [username, setUsername] = React.useState('');
    const [gold, setGold] = React.useState(0);
    const [showUsernamePrompt, setShowUsernamePrompt] = React.useState(false);
    const [isInitializing, setIsInitializing] = React.useState(true);
    const [gameId, setGameId] = React.useState(null);
    const [invitation, setInvitation] = React.useState(null);
    const [showAppExitModal, setShowAppExitModal] = React.useState(false);
    const [toastMessage, setToastMessage] = React.useState(null);
    const [incomingInvitation, setIncomingInvitation] = React.useState(null);
    const [isAvatarModalOpen, setIsAvatarModalOpen] = React.useState(false);
    const [avatarId, setAvatarId] = React.useState(null);

    const loadUserData = async (user) => {
    const userRef = db.collection("users").doc(user);
    const doc = await userRef.get();
    if (doc.exists) {
        const userData = doc.data();
        setUsername(user);
        setGold(userData.gold || 0);
        setAvatarId(userData.avatarId || null); // Hata artık burada oluşmayacak.

    } else {
        localStorage.removeItem('wordHuntUsername');
        setShowUsernamePrompt(true);
    }
	};

    const handleSaveUsername = async (name) => {
        const userRef = db.collection("users").doc(name);
        const doc = await userRef.get();
        if (doc.exists) {
            return false;
        } else {
            await userRef.set({ gold: 0, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            localStorage.setItem('wordHuntUsername', name);
            setUsername(name);
            setGold(0);
            setShowUsernamePrompt(false);
            if (pendingFCMToken) {
                saveTokenForUser(name, pendingFCMToken);
            }
            return true;
        }
    };

    const handleStatsChange = (newStats) => {
        saveGameStats(newStats);
        setGameStats(newStats);
        if (username && typeof newStats.gold !== 'undefined' && newStats.gold !== gold) {
            setGold(newStats.gold);
            db.collection("users").doc(username).update({ gold: newStats.gold }).catch(error => console.error("Altın güncellenirken hata:", error));
        }
    };


 const handleAvatarSelect = async (avatarId) => {
    if (!username) return;

    try {
        await db.collection("users").doc(username).update({
            avatarId: avatarId
        });
        setAvatarId(avatarId); 
        setToastMessage("Avatarın başarıyla güncellendi!");
        setIsAvatarModalOpen(false); // Modalı kapat

    } catch (error) {
        console.error("Avatar güncellenirken hata oluştu:", error);
        setToastMessage("Hata: Avatar güncellenemedi.");
    }
};



    const goToHome = React.useCallback(() => {
        if (page === 'lobby' && username) {
            db.collection('lobby').doc(username).delete().catch(() => {});
        } else if (page === 'game' && gameId) {
            db.collection('lobby').doc(username).update({ status: 'idle', gameId: null, invitedBy: null }).catch(() => {});
        }
        setPage('home');
        setGameId(null);
        setInvitation(null);
    }, [username, page, gameId]);

    const handleAndroidBack = React.useCallback(() => {
        if (page === 'game' && typeof window.androidBridge.game_showExitConfirmation === 'function') {
            window.androidBridge.game_showExitConfirmation();
        } else if (page === 'home') {
            setShowAppExitModal(true);
        } else {
            goToHome();
        }
    }, [page, goToHome]);

    window.androidBridge.handleIncomingDuel = async (duelId) => {
        if (!duelId) return;
        const duelRef = db.collection('active-duels').doc(duelId);
        const duelDoc = await duelRef.get();
        if (duelDoc.exists) {
            setIncomingInvitation({ id: duelDoc.id, ...duelDoc.data() });
        } else {
            console.log("Davet bulunamadı veya iptal edilmiş.");
        }
    };
// App fonksiyonunuzun içine, diğer useEffect'lerin yanına bu bloğu ekleyin

React.useEffect(() => {
    // Oyun ve lobi gibi kaydırma istenmeyen sayfalarda,
    // body etiketine 'no-scroll' sınıfını ekliyoruz.
    if (page === 'game' || page === 'lobby') {
        document.body.classList.add('no-scroll');
    } else {
        // FriendsPage gibi kaydırma istenen sayfalarda bu sınıfı kaldırıyoruz.
        document.body.classList.remove('no-scroll');
    }
}, [page]); // Bu kod sadece 'page' state'i değiştiğinde çalışır.
    React.useEffect(() => {
        window.androidBridge.registered_onBackPress = handleAndroidBack;
        const initializeApp = async () => {
            setIsInitializing(true);
            try {
                const savedUser = localStorage.getItem('wordHuntUsername');
                if (savedUser) {
                    await loadUserData(savedUser);
                    if (pendingFCMToken) {
                        saveTokenForUser(savedUser, pendingFCMToken);
                    }
                } else {
                    setShowUsernamePrompt(true);
                }
            } catch (error) {
                console.error("Uygulama başlatılırken bir hata oluştu:", error);
            } finally {
                setIsInitializing(false);
            }
        };
        initializeApp();
        return () => {
            window.androidBridge.registered_onBackPress = null;
        };
    }, [handleAndroidBack]);

    React.useEffect(() => {
        if (!username) return;
        const userLobbyRef = db.collection('lobby').doc(username);
        const unsubscribe = userLobbyRef.onSnapshot(doc => {
            const data = doc.data();
            if (data) {
                if (data.status === 'in-game' && data.gameId) {
                    setInvitation(null);
                    setGameId(data.gameId);
                    setPage('game');
                } else if (data.status === 'invited' && data.gameId && data.invitedBy) {
                    setInvitation({ gameId: data.gameId, invitedBy: data.invitedBy });
                }
            }
        });
        return () => unsubscribe();
    }, [username]);

    React.useEffect(() => {
        if (page === 'home') {
            try {
                const saves = localStorage.getItem(ALL_SAVES_KEY);
                setAllSaves(saves ? JSON.parse(saves) : { lastPlayed: null });
            } catch (e) {
                setAllSaves({ lastPlayed: null });
            }
        }
    }, [page]);

    React.useEffect(() => {
        if (toastMessage) {
            const timer = setTimeout(() => setToastMessage(null), 3800);
            return () => clearTimeout(timer);
        }
    }, [toastMessage]);

    const startSinglePlayerGame = (selectedMode) => {
        const t = translations[language] || translations['en'];
        if (selectedMode === 'random') {
            const playableModes = ['super-easy', 'easy', 'hard', 'timed-easy', 'timed-hard'];
            const randomModeKey = _.sample(playableModes);
            const keyForTranslation = randomModeKey.replace(/-(\w)/g, (m, l) => l.toUpperCase()) + 'Mode';
            const randomModeName = t[keyForTranslation] || randomModeKey;
            const randomLevel = _.random(0, 89);
            setModalContent({
                isOpen: true,
                title: t.randomGameTitle,
                body: (<div><p className="text-gray-700 text-lg mb-6" dangerouslySetInnerHTML={{ __html: t.randomGameBody(randomModeName, randomLevel + 1) }} /><button onClick={() => { setModeConfig({ name: randomModeKey, level: randomLevel, isOneShot: true }); setPage('game'); setModalContent({ isOpen: false }); }} className="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg">{t.startButton}</button></div>)
            });
            return;
        }
        const savedGameForMode = allSaves?.[selectedMode];
        if (!savedGameForMode) {
            setModeConfig({ name: selectedMode });
            setPage('game');
        } else {
            const handleContinue = () => {
                setModeConfig({ name: savedGameForMode.mode, level: savedGameForMode.level });
                setLanguage(savedGameForMode.language);
                setModalContent({ isOpen: false });
                setPage('game');
            };
            const handleNewGame = () => {
                const currentSaves = { ...allSaves };
                delete currentSaves[selectedMode];
                localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
                setAllSaves(currentSaves);
                setModeConfig({ name: selectedMode });
                setModalContent({ isOpen: false });
                setPage('game');
            };
            setModalContent({
                isOpen: true,
                title: t.savedGameFoundTitle,
                body: (<div><p className="text-gray-700 text-lg mb-6" dangerouslySetInnerHTML={{ __html: t.savedGameFoundBody(savedGameForMode.level + 1) }} /><div className="flex flex-col sm:flex-row gap-4"><button onClick={handleNewGame} className="w-full px-4 py-3 bg-red-600 text-white font-bold rounded-lg">{t.noStartNewButton}</button><button onClick={handleContinue} className="w-full px-4 py-3 bg-green-600 text-white font-bold rounded-lg">{t.yesContinueButton}</button></div></div>)
            });
        }
    };

    const launchVsComputerGame = (difficulty, boardSize) => {
        setModalContent({ isOpen: false });
        setModeConfig({ name: 'vs-computer', difficulty: difficulty, boardSize: boardSize });
        setPage('game');
    };

    const openVsComputerSetupModal = () => {
        const VsComputerSetupModal = ({ onStart }) => {
            const [difficulty, setDifficulty] = React.useState('medium');
            const [size, setSize] = React.useState('medium');
            const difficultyOptions = [{ key: 'easy', label: 'Kolay', icon: '🧸', activeClass: 'bg-green-500 border-green-400' }, { key: 'medium', label: 'Orta', icon: '😊', activeClass: 'bg-sky-500 border-sky-400' }, { key: 'hard', label: 'Zor', icon: '🔥', activeClass: 'bg-red-500 border-red-400' },];
            const sizeOptions = [{ key: 'small', label: 'Küçük' }, { key: 'medium', label: 'Orta' }, { key: 'large', label: 'Büyük' },];
            return (<div className="flex flex-col gap-5 mt-2 text-white"><div><h4 className="font-semibold text-base text-gray-700 dark:text-gray-300 mb-3 text-left">Zorluk Seç</h4><div className="grid grid-cols-3 gap-3">{difficultyOptions.map(opt => { const isActive = difficulty === opt.key; return (<button key={opt.key} onClick={() => setDifficulty(opt.key)} className={`flex flex-col items-center justify-center p-3 rounded-xl border-2 transition-all duration-200 transform ${isActive ? `${opt.activeClass} text-white shadow-lg scale-105` : 'bg-gray-200 dark:bg-gray-700 border-transparent text-gray-700 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600'}`}><span className="text-3xl">{opt.icon}</span><span className="mt-1 font-bold text-sm">{opt.label}</span></button>); })}</div></div><div><h4 className="font-semibold text-base text-gray-700 dark:text-gray-300 mb-3 text-left">Oyun Alanı Boyutu</h4><div className="grid grid-cols-3 gap-2 bg-gray-200 dark:bg-gray-900 rounded-lg p-1">{sizeOptions.map(opt => { const isActive = size === opt.key; return (<button key={opt.key} onClick={() => setSize(opt.key)} className={`w-full font-bold py-2 rounded-md transition-all text-sm ${isActive ? 'bg-indigo-600 text-white shadow' : 'text-gray-600 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-700'}`}>{opt.label}</button>); })}</div></div><button onClick={() => onStart(difficulty, size)} className="w-full mt-4 px-4 py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-bold rounded-lg hover:from-blue-600 hover:to-indigo-700 transition-all transform hover:scale-105 shadow-lg">Oyuna Başla</button></div>);
        };
        setModalContent({ isOpen: true, title: '🤖 Yapay Zekaya Meydan Oku 🤖', body: <VsComputerSetupModal onStart={launchVsComputerGame} /> });
    };

    const startGameVsComputer = () => {
        const t = translations[language] || translations['en'];
        const modeKey = 'vs-computer';
        const savedGameForMode = allSaves?.[modeKey];
        if (savedGameForMode) {
            const difficultyMap = { easy: 'Kolay', medium: 'Orta', hard: 'Zor' };
            const sizeMap = { small: 'Küçük', medium: 'Orta', large: 'Büyük' };
            const gameDifficulty = savedGameForMode.difficulty || 'medium';
            const gameBoardSize = savedGameForMode.boardSize || 'medium';
            const savedDifficultyText = difficultyMap[gameDifficulty] || gameDifficulty;
            const savedSizeText = sizeMap[gameBoardSize] || gameBoardSize;
            const customMessage = `'<span class="font-bold">${savedDifficultyText}</span>' zorlukta ve '<span class="font-bold">${savedSizeText}</span>' boyutta kayıtlı bir oyununuz var. Devam edilsin mi?`;
            const handleContinue = () => {
                setModeConfig({ name: savedGameForMode.mode, level: savedGameForMode.level, difficulty: gameDifficulty, boardSize: gameBoardSize });
                setLanguage(savedGameForMode.language);
                setModalContent({ isOpen: false });
                setPage('game');
            };
            const handleNewGame = () => {
                const currentSaves = { ...allSaves };
                delete currentSaves[modeKey];
                localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
                setAllSaves(currentSaves);
                openVsComputerSetupModal();
            };
            setModalContent({
                isOpen: true,
                title: t.savedGameFoundTitle,
                body: (<div><p className="text-gray-700 text-lg mb-6" dangerouslySetInnerHTML={{ __html: customMessage }} /><div className="flex flex-col sm:flex-row gap-4"><button onClick={handleNewGame} className="w-full px-4 py-3 bg-red-600 text-white font-bold rounded-lg">{t.noStartNewButton}</button><button onClick={handleContinue} className="w-full px-4 py-3 bg-green-600 text-white font-bold rounded-lg">{t.yesContinueButton}</button></div></div>)
            });
        } else {
            openVsComputerSetupModal();
        }
    };

    const handleAcceptInvitation = async () => {
        if (!incomingInvitation) return;
        const duelId = incomingInvitation.id;
        const gameRef = db.collection('active-duels').doc(duelId);
        await gameRef.update({ status: 'active' });
        const playerUsernames = Object.keys(incomingInvitation.players);
        const player1Ref = db.collection('lobby').doc(playerUsernames[0]);
        const player2Ref = db.collection('lobby').doc(playerUsernames[1]);
        await player1Ref.update({ status: 'in-game', gameId: duelId });
        await player2Ref.update({ status: 'in-game', gameId: duelId });
        setIncomingInvitation(null);
        setGameId(duelId);
        setPage('game');
    };

    const handleDeclineInvitation = async () => {
        if (!incomingInvitation) return;
        await db.collection('active-duels').doc(incomingInvitation.id).delete();
        setIncomingInvitation(null);
    };

    const handleAcceptOldInvitation = async () => {
        if (!invitation || !username) return;
        const { gameId, invitedBy } = invitation;
        const gameRef = db.collection('active-duels').doc(gameId);
        const myLobbyRef = db.collection('lobby').doc(username);
        const opponentLobbyRef = db.collection('lobby').doc(invitedBy);
        db.runTransaction(async (transaction) => {
            transaction.update(gameRef, { status: 'active' });
            transaction.update(myLobbyRef, { status: 'in-game' });
            transaction.update(opponentLobbyRef, { status: 'in-game' });
        });
        setInvitation(null);
    };

    const handleRejectOldInvitation = () => {
        if (!invitation || !username) return;
        const { gameId, invitedBy } = invitation;
        const gameRef = db.collection('active-duels').doc(gameId);
        const myLobbyRef = db.collection('lobby').doc(username);
        const opponentLobbyRef = db.collection('lobby').doc(invitedBy);
        gameRef.delete();
        myLobbyRef.update({ status: 'idle', gameId: null, invitedBy: null });
        opponentLobbyRef.update({ status: 'idle', gameId: null });
        setInvitation(null);
    };

    const goToLobby = () => {
        if (username) {
            const lobbyData = {
                username: username,
                status: 'idle',
                joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                last_active: firebase.firestore.FieldValue.serverTimestamp()
            };
            db.collection('lobby').doc(username).set(lobbyData);
            setPage('lobby');
        } else {
            setShowUsernamePrompt(true);
        }
    };

    const openFriendsPage = () => {
        setPage('friends');
    };

    // App fonksiyonu içinde
const sendInvitationFromFriendsPage = (targetPlayer) => {
    if (!username || !targetPlayer) {
        console.error("Davet gönderen veya davet edilen kullanıcı bilgisi eksik.");
        return;
    }

    setToastMessage(`${targetPlayer.username} kullanıcısına davet gönderildi!`);

    const gameId = [username, targetPlayer.username].sort().join('_');
    const gameRef = db.collection('active-duels').doc(gameId);
    const myLobbyRef = db.collection('lobby').doc(username);
    const opponentLobbyRef = db.collection('lobby').doc(targetPlayer.username);

    // 1. Düello kaydını oluştur
    gameRef.set({
        gameId: gameId,
        status: 'pending',
        boardSize: 'medium',
        difficulty: 'easy',
        invitedBy: username,
        players: {
            [username]: { score: 0, foundWords: [] },
            [targetPlayer.username]: { score: 0, foundWords: [] }
        },
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
    }).then(() => {
        console.log(`Düello daveti başarıyla oluşturuldu: ${gameId}`);

        // 2. Hem kendi durumunu hem de rakibin durumunu güncelle
        // Bu işlem, canlı dinleyicileri (onSnapshot) tetikleyecektir.
        const batch = db.batch();
        batch.set(myLobbyRef, {
            username: username,
            status: 'waiting_for_opponent',
            gameId: gameId,
            last_active: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        batch.set(opponentLobbyRef, {
            username: targetPlayer.username,
            status: 'invited',
            gameId: gameId,
            invitedBy: username,
            last_active: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        return batch.commit();

    }).then(() => {
        // 3. Seni bekleme ekranının olduğu lobi sayfasına yönlendir
        setPage('lobby');
    }).catch(error => {
        console.error("Düello daveti oluşturulurken hata:", error);
        setToastMessage("Davet gönderilirken bir hata oluştu.");
    });
};

    return (
        <ErrorBoundary>
            <div className="h-full w-full overflow-hidden">
                {page === 'home' && (
                    <HomePage
                        startGame={startSinglePlayerGame}
                        startGameVsComputer={startGameVsComputer}
                        language={language}
                        setLanguage={setLanguage}
                        stats={{ ...gameStats, gold: gold, username: username }}
                        setModalContent={setModalContent}
                        savedGame={allSaves && allSaves.lastPlayed ? allSaves[allSaves.lastPlayed] : null}
                        username={username}
                        openDuelLobby={goToLobby}
avatarId={avatarId}
        openAvatarModal={() => setIsAvatarModalOpen(true)}
                        isInitializing={isInitializing}
                        openFriendsPage={openFriendsPage}
                    />
                )}
                {page === 'friends' && (
                    <FriendsPage
                        username={username}
                        onInvite={sendInvitationFromFriendsPage}
                        onBack={goToHome}
                        db={db}
                    />
                )}
                {page === 'lobby' && (
                    <LobbyPage
                        username={username}
                        goToHome={goToHome}
                        startGame={(newGameId) => { setGameId(newGameId); setPage('game'); }}
                        language={language}
                    />
                )}
                {page === 'game' && (
                    <WordHunt
                        config={modeConfig}
                        gameId={gameId}
                        username={username}
                        goToHome={goToHome}
                        language={language}
                        stats={{ ...gameStats, gold: gold, username: username }}
                        onStatsChange={handleStatsChange}
                        initialSavedState={allSaves && !gameId ? allSaves[modeConfig.name] : null}
                    />
                )}
            </div>
            <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={() => setModalContent({ isOpen: false })}>
                {modalContent.body}
            </Modal>
            {showUsernamePrompt && <UsernamePrompt onSave={handleSaveUsername} />}
            {invitation && (
                <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
                    <div className="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-sm text-center transform transition-all animate-pulse-once">
                        <h3 className="text-3xl font-bold mb-4 text-gray-800">⚔️ Düello Daveti ⚔️</h3>
                        <p className="text-gray-600 text-lg mb-8">
                            <span className="font-bold text-indigo-600">{invitation.invitedBy}</span> sizi bir düelloya davet ediyor!
                        </p>
                        <div className="flex justify-center gap-4 mt-4">
                            <button onClick={handleRejectOldInvitation} className="px-8 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-all transform hover:scale-105 shadow-lg">Reddet</button>
                            <button onClick={handleAcceptOldInvitation} className="px-8 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition-all transform hover:scale-105 shadow-lg">Kabul Et</button>
                        </div>
                    </div>
                </div>
            )}
            <InvitationModal
                isOpen={!!incomingInvitation}
                invitationDetails={incomingInvitation}
                onAccept={handleAcceptInvitation}
                onDecline={handleDeclineInvitation}
            />
            {showAppExitModal && (
                <Modal isOpen={true} title="Oyundan Çık" onClose={() => setShowAppExitModal(false)}>
                    <div className="text-center">
                        <p className="text-lg text-gray-700 mb-6">Uygulamadan çıkmak istediğinize emin misiniz?</p>
                        <div className="flex justify-center gap-4">
                            <button onClick={() => setShowAppExitModal(false)} className="px-8 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600">Hayır</button>
                            <button onClick={() => { if (window.Android && window.Android.closeApp) { window.Android.closeApp(); } }} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Evet</button>
                        </div>
                    </div>
                </Modal>
            )}
<AvatarSelectionModal
                isOpen={isAvatarModalOpen}
                onClose={() => setIsAvatarModalOpen(false)}
                onAvatarSelect={handleAvatarSelect}
            />



            {toastMessage && (
                <div className="toast-notification fixed bottom-24 left-1/2 -translate-x-1/2 bg-indigo-600 text-white font-bold py-3 px-6 rounded-full shadow-lg z-[9999]">
                    {toastMessage}
                </div>
            )}
        </ErrorBoundary>
    );
}

window.handleAndroidBackPress = function() {
            if (window.appNavigator && window.appNavigator.getCurrentPage() === 'game') {
                window.appNavigator.goToHome();
                return true;
            }
            return false;
        };
        ReactDOM.render(<App />, document.getElementById('root'));
        }

        initializeGame();
</script>

</body>
</html>