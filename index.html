<!DOCTYPE html>
<html lang="tr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Kelime Avı - Tam Sürüm</title>
	<script src="libs/react.production.min.js"></script>
	<script src="libs/react-dom.production.min.js"></script>
	<script src="libs/lodash.min.js"></script>
	<script src="libs/tailwindcss.js"></script>
	<script src="libs/confetti.browser.min.js"></script>
	<script src="libs/firebase-app.js"></script>
	<script src="libs/firebase-firestore.js"></script>
	<script src="libs/firebase-auth.js"></script>
    <script src="libs/firebase-remote-config.js"></script>
	<script src="libs/babel.min.js"></script>
	<script src="wordstr.js?v=1.0"></script>
	<script src="words_tr_2letters.js?v=1.0"></script>
	<script src="wordsen.js?v=1.0"></script>

	<style>
	body {overscroll-behavior-y: none;-webkit-user-select: none;user-select: none;height: 100vh;font-family: 'Inter', sans-serif;background-color: #f3f4f6;    }
	body.no-scroll {overflow: hidden;touch-action: none;}
    body.no-scroll #root {overflow: hidden;}
    .grid { -webkit-tap-highlight-color: transparent; }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    .scrollbar-thin { scrollbar-width: thin; scrollbar-color: #9CA3AF #E5E7EB; }
    .scrollbar-thin::-webkit-scrollbar { width: 5px; }
    .scrollbar-thin::-webkit-scrollbar-track { background: #E5E7EB; border-radius: 10px;}
    .scrollbar-thin::-webkit-scrollbar-thumb { background-color: #9CA3AF; border-radius: 10px; border: 1px solid #E5E7EB; }
    .shake-animation {  animation: shake 0.3s ease-in-out;}
    .toast-notification { animation: toast-in-out 4s forwards; }
    .hidden-word-start-letter { color: #0d6efd !important; font-weight: 900; }
    .animate-hint-pulse {animation: pulse-hint 1.5s infinite ease-in-out;color: #713f12 !important;font-weight: 900;}
    .animate-word-found { animation: word-found-animation 0.6s ease-out; }
	.dynamic-grid {display: grid; grid-template-columns: repeat(var(--grid-cols, 6), 1fr);  }
    @keyframes word-found-animation {
    0% { transform: scale(1); background-color: #6ee7b7; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
    50% { transform: scale(1.1); background-color: #34d399; box-shadow: 0 0 15px 5px rgba(16, 185, 129, 0.5); }
    100% { transform: scale(1); background-color: #6ee7b7; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }	}
    .animate-bonus-glow {animation: bonus-double-glow-animation 1.2s ease-out;}

    @keyframes bonus-double-glow-animation {    0% {        transform: scale(1);    }
    25% {        transform: scale(1.15);        background-color: #fde047;        box-shadow: 0 0 15px #facc15;    }
    50% {        transform: scale(1);    }
    75% {        transform: scale(1.15);        background-color: #fde047;         box-shadow: 0 0 15px #facc15;    }
    100% {       transform: scale(1);    }    }	


    #loader.hidden {        opacity: 0;        visibility: hidden;        transition: opacity 0.5s ease-out, visibility 0.5s ease-out;    }
    #loader-progress {        animation: loading-progress 1.5s ease-in-out forwards;    }
    @keyframes loading-progress {        0% { width: 0%; }        100% { width: 100%; }    }
	.animate-timer-pulse {	animation: pulse-timer 0.5s ease-out;}

    @keyframes pulse-timer {      0% { transform: scale(1); }
      40% { transform: scale(1.15); color: #ef4444; }
      100% { transform: scale(1); }}

    @keyframes toast-in-out {
    0% { transform: translateY(100%); opacity: 0; }
    15% { transform: translateY(0); opacity: 1; }
    85% { transform: translateY(0); opacity: 1; }
    100% { transform: translateY(100%); opacity: 0; }}

    @keyframes shake {
    0% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    50% { transform: translateX(5px); }
    75% { transform: translateX(-5px); }
    100% { transform: translateX(0); }}

    @keyframes pulse-hint {  0%, 100% { background-color: #fef08a; transform: scale(1); }50% { background-color: #fde047; 	transform: scale(1.05); box-shadow: 0 0 8px #facc15; } }
</style>

</head>

<body class="h-[100vh] flex flex-col">
<div id="loader" class="fixed inset-0 bg-slate-800 flex flex-col items-center justify-center z-[9999]">
	<img src="logo.png" alt="Oyun Logosu" class="w-32 h-32 mb-6 animate-pulse" />

	<div class="w-48 bg-slate-700 rounded-full h-2.5">
		<div id="loader-progress" class="bg-indigo-500 h-2.5 rounded-full" style="width: 0%"></div>
	</div>
	<p class="text-slate-400 mt-4 text-lg font-semibold">Yükleniyor...</p>

	<p id="version-display" class="absolute bottom-4 text-white/60 text-sm font-mono"></p></div>
</div>

<div id="root" class="flex-1"></div>

<audio id="correctSound" preload="auto" src="sounds/correct.mp3">Tarayıcınız ses etiketini desteklemiyor.</audio>
<audio id="wrongSound" preload="auto" src="sounds/wrong.mp3">Tarayıcınız ses etiketini desteklemiyor.</audio>
<audio id="achievementSound" preload="auto" src="sounds/achievement.mp3">Tarayıcınız ses etiketini desteklemiyor.</audio>

<script type="text/babel">

	window.setAppVersion = function(version) {
      const versionElement = document.getElementById('version-display');

      if (versionElement) {
        versionElement.innerText = `v${version}`;
      } else {
        console.error("JS: HATA! 'version-display' elementi HTML'de bulunamadı!");
      }
    };

   function DuelInviteModal({ isOpen, onClose, player, onInvite }) {
    if (!isOpen || !player) return null;

    const [boardSize, setBoardSize] = React.useState('medium');
    const [difficulty, setDifficulty] = React.useState('easy');

    const difficultyOptions = [
        { key: 'easy', label: 'Kolay', icon: '🧸', desc: 'Kelimeler görünür', color: 'from-green-400 to-emerald-500' },
        { key: 'hard', label: 'Zor', icon: '🔥', desc: 'Kelimeler gizli', color: 'from-red-500 to-rose-600' }
    ];

    const sizeOptions = [
        { key: 'small', label: 'Küçük Alan', icon: '🤏' },
        { key: 'medium', label: 'Orta Alan', icon: '👌' },
        { key: 'large', label: 'Geniş Alan', icon: '👐' }
    ];

    const handleSendInvite = () => {
        onInvite(player, boardSize, difficulty);
        onClose();
    };

    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className="bg-slate-50 p-6 rounded-2xl shadow-2xl w-full max-w-sm" onClick={e => e.stopPropagation()}>
                <h3 className="text-2xl font-bold mb-6 text-gray-800 text-center">
                    <span className="font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-indigo-600">{player.username}</span> için oyun kur
                </h3>
                <div className="space-y-6">
                    <div>
                        <h4 className="font-bold text-lg text-slate-700 mb-3">Zorluk Seviyesi</h4>
                        <div className="grid grid-cols-2 gap-3">
                            {difficultyOptions.map(opt => (
                                <button
                                    key={opt.key}
                                    onClick={() => setDifficulty(opt.key)}
                                    className={`p-3 h-28 rounded-xl text-white font-bold flex flex-col items-center justify-center text-center transition-all transform bg-gradient-to-br ${opt.color} ${difficulty === opt.key ? 'ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'opacity-80 hover:opacity-100'}`}
                                >
                                    <span className="text-4xl drop-shadow-lg">{opt.icon}</span>
                                    <span className="mt-1 text-base">{opt.label}</span>
                                    <span className="mt-1 text-xs font-normal opacity-90">{opt.desc}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                    <div>
                        <h4 className="font-bold text-lg text-slate-700 mb-3">Oyun Alanı Boyutu</h4>
                        <div className="grid grid-cols-3 gap-3">
                            {sizeOptions.map(opt => (
                                 <button
                                    key={opt.key}
                                    onClick={() => setBoardSize(opt.key)}
                                    className={`p-3 h-24 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${boardSize === opt.key ? 'bg-indigo-600 text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}
                                >
                                    <span className="text-3xl">{opt.icon}</span>
                                    <span className="mt-1 text-sm">{opt.label}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
                <button onClick={handleSendInvite} className="w-full mt-8 bg-green-500 text-white font-bold py-3 rounded-lg hover:bg-green-600 transition-all text-lg shadow-lg">
                    Meydan Oku
                </button>
            </div>
        </div>
    );
}



function ConfirmationModal({ isOpen, onClose, onConfirm, title, bodyText }) {
    if (!isOpen) return null;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
            <div className="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm text-center">
                <h3 className="text-xl font-bold mb-4 text-gray-800">{title}</h3>
                <p className="text-gray-600 mb-6" dangerouslySetInnerHTML={{ __html: bodyText }}></p>
                <div className="flex justify-center gap-4">
                    <button onClick={onClose} className="px-6 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600">İptal</button>
                    <button onClick={onConfirm} className="px-6 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Onayla</button>
                </div>
            </div>
        </div>
    );
}


function DirectInviteModal({ isOpen, invitationDetails, onAccept, onDecline }) {
    if (!isOpen || !invitationDetails) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
            <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-sm text-center transform transition-all animate-pulse-once">
                <h3 className="text-3xl font-bold mb-2 text-gray-800">⚔️ Meydan Okuma ⚔️</h3>
                <p className="text-gray-600 text-lg mb-6">
                    <span className="font-bold text-indigo-600">{invitationDetails.invitedBy}</span> seni özel bir oyuna davet ediyor!
                </p>
                <div className="flex justify-center gap-4 mt-4">
                    <button
                        onClick={onDecline}
                        className="px-8 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-all transform hover:scale-105 shadow-lg">
                        Reddet
                    </button>
                    <button
                        onClick={onAccept}
                        className="px-8 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition-all transform hover:scale-105 shadow-lg">
                        Kabul Et
                    </button>
                </div>
            </div>
        </div>
    );
}









// MEVCUT RoomLobbyPage FONKSİYONUNU TAMAMEN SİLİP, BUNU YAPIŞTIRIN:
function RoomLobbyPage({ username, gameId, db, onBack, startGame, setPage, setToastMessage, setModeConfig }) {
    const [roomData, setRoomData] = React.useState(null);

    React.useEffect(() => {
        if (!gameId) {
            onBack();
            return;
        }

        const roomRef = db.collection('game_rooms').doc(gameId);
        const unsubscribe = roomRef.onSnapshot(doc => {
            if (doc.exists) {
                const data = doc.data();
                setRoomData(data);
                
                // DÜZELTME:
                // Sadece oyunun başladığını değil, tahta verisinin de hazır ve dolu olduğunu kontrol et.
                // Bu, "oyun kuruluyor" ekranında takılma sorununu çözer.
                if (data.status === 'in-progress' && data.boardData && data.boardData.board && Object.keys(data.boardData.board).length > 0) {
                    // 1. Önce oyun modunu doğru şekilde ayarla.
                    const newConfig = {
                        name: 'multiplayer',
                        boardSize: data.gameSettings.boardSize,
                        difficulty: data.gameSettings.difficulty,
                        modeType: 'avi' 
                    };
                    setModeConfig(newConfig);
                    // 2. Sonra oyun ekranına geçiş yap.
                    setPage('game');
                }
            } else {
                setToastMessage("Oda kapatıldı veya bulunamadı.");
                onBack();
            }
        });

        return () => unsubscribe();
    }, [gameId, db, onBack, setPage, setToastMessage, setModeConfig]);

    const leaveRoom = async () => {
        if (!roomData) return;
        const roomRef = db.collection('game_rooms').doc(gameId);
        
        try {
            if (Object.keys(roomData.players).length <= 1) {
                // Odada kimse kalmadıysa odayı sil
                await roomRef.delete();
            } else {
                const updates = {
                    [`players.${username}`]: firebase.firestore.FieldValue.delete()
                };
                // Eğer ayrılan kişi kurucuysa, yeni bir kurucu ata
                if (roomData.host === username) {
                    updates.host = Object.keys(roomData.players).find(p => p !== username) || null;
                }
                await roomRef.update(updates);
            }
        } catch (error) {
            console.error("Odadan ayrılırken hata:", error);
            // Hata olsa bile kullanıcıyı ana menüye gönder
        } finally {
            onBack();
        }
    };

    if (!roomData) {
        return <div className="flex items-center justify-center h-screen bg-gray-800 text-white text-lg">Oda bilgileri yükleniyor...</div>;
    }

    const isHost = roomData.host === username;
    const players = Object.values(roomData.players);
    const playerUsernames = Object.keys(roomData.players);
    const canStart = playerUsernames.length >= 2;

    return (
        <div className="h-screen w-full bg-gradient-to-br from-gray-800 to-slate-900 text-white flex flex-col items-center justify-center p-4">
            <div className="text-center mb-8">
                <h1 className="text-4xl font-black mb-2 tracking-tight">{roomData.host}'un Odası</h1>
                <p className="text-indigo-300 animate-pulse">{isHost ? 'Oyuncuların katılmasını bekliyorsun...' : 'Oyunun başlaması bekleniyor...'}</p>
            </div>

            <div className="w-full max-w-lg grid grid-cols-2 gap-4 mb-8">
                {playerUsernames.map((name, index) => {
                    const pData = roomData.players[name];
                    return (
                        <div key={name} className="bg-white/10 p-3 rounded-lg flex flex-col items-center gap-2 text-center shadow-lg">
                           <div className="relative">
                             <img src={pData.avatarId ? `avatars/${pData.avatarId}.png` : 'avatars/default.png'} className="w-16 h-16 rounded-full object-cover border-2 border-slate-500" />
                             {roomData.host === name && <span className="absolute -top-1 -right-1 text-2xl" title="Oda Kurucusu">👑</span>}
                           </div>
                           <p className="font-bold text-sm">{name}</p>
                        </div>
                    );
                })}
            </div>

            {isHost && (
                <button
                    onClick={() => startGame(gameId)}
                    disabled={!canStart}
                    className="bg-green-600 text-white font-bold py-4 px-10 rounded-lg shadow-lg text-xl hover:bg-green-700 disabled:bg-gray-500 disabled:cursor-not-allowed transform hover:scale-105 transition-all"
                >
                    {canStart ? 'Oyunu Başlat' : 'Oyuncu Bekleniyor'}
                </button>
            )}

            <button onClick={leaveRoom} className="absolute top-6 right-6 bg-red-500/50 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-500/80 transition-colors">
                Odadan Ayrıl
            </button>
        </div>
    );
}








function initializeGame() {
        if (window.firebase && window._ && window.React && window.ReactDOM) {
            runApp();
        } else {
            setTimeout(initializeGame, 100);
        }
    }

    const playerCardColors = [
    { id: 'teal', name: 'Turkuaz', class: 'bg-gradient-to-br from-teal-400 to-cyan-500' },
    { id: 'blue', name: 'Mavi', class: 'bg-gradient-to-br from-blue-400 to-indigo-500' },
    { id: 'purple', name: 'Mor', class: 'bg-gradient-to-br from-purple-500 to-violet-600' },
    { id: 'pink', name: 'Pembe', class: 'bg-gradient-to-br from-pink-400 to-rose-500' },
    { id: 'orange', name: 'Turuncu', class: 'bg-gradient-to-br from-orange-400 to-amber-500' },
    { id: 'lime', name: 'Misket Limonu', class: 'bg-gradient-to-br from-lime-400 to-emerald-500' },
    { id: 'sky', name: 'Gök Mavisi', class: 'bg-gradient-to-br from-sky-400 to-cyan-400' },
    { id: 'red', name: 'Kırmızı', class: 'bg-gradient-to-br from-red-500 to-rose-600' },
    { id: 'green', name: 'Yeşil', class: 'bg-gradient-to-br from-green-500 to-lime-600' },
    { id: 'gray', name: 'Gri', class: 'bg-gradient-to-br from-slate-500 to-gray-600' },
    { id: 'yellow', name: 'Sarı', class: 'bg-gradient-to-br from-yellow-400 to-amber-500' },
    { id: 'cyan', name: 'Cam Göbeği', class: 'bg-gradient-to-br from-cyan-400 to-sky-500' },
    { id: 'emerald', name: 'Zümrüt', class: 'bg-gradient-to-br from-emerald-500 to-green-600' },
    { id: 'fuchsia', name: 'Galibarda', class: 'bg-gradient-to-br from-fuchsia-500 to-pink-600' },
    { id: 'indigo', name: 'Çivit Mavisi', class: 'bg-gradient-to-br from-indigo-500 to-purple-600' }
];

    const ModernModeCard = ({ title, icon, bgColor, className, onClick, disabled, userInfo, buttonText = "Oyna" }) =>
        {const handleClick = () => {
            if (!disabled) {onClick();}};

        return (
            <div
                onClick={handleClick}
                role="button"
                tabIndex={disabled ? -1 : 0}
                className={`relative group w-full rounded-2xl text-white overflow-hidden transition-opacity duration-200 border border-white/20 will-change-transform ${bgColor} ${className} ${disabled ? 'opacity-60 cursor-not-allowed' : 'cursor-pointer'}`}
            >
                <div className="absolute -right-2 -bottom-2 text-8xl opacity-40 drop-shadow-lg">
                    {icon}
                </div>

                {userInfo && userInfo.username && (
                    <div className="absolute bottom-2 right-3 bg-black/30 backdrop-blur-sm text-white text-[10px] font-bold px-2 py-0.5 rounded-full flex items-center gap-1">
                        <div className={`w-1.5 h-1.5 ${userInfo.status === 'Çevrimiçi' ? 'bg-green-400' : 'bg-gray-400'} rounded-full`}></div>
                        {userInfo.username}
                    </div>
                )}

                <div className="p-3 h-full flex flex-col justify-between text-left pointer-events-none">
                    <h3 className="text-lg font-bold leading-tight">{title}</h3>
                    <div className={`mt-2 self-start bg-white/20 backdrop-blur-sm text-white text-xs font-bold uppercase tracking-wider rounded-full px-4 py-1.5 flex items-center gap-2`}>
                        <span>{disabled ? '...' : buttonText}</span>
                        {!disabled && <span>→</span>}
                    </div>
                </div>
            </div>
        );
    };

    const availableAvatars = [
        { id: 'avatar1', url: 'avatars/avatar1.png' },
        { id: 'avatar2', url: 'avatars/avatar2.png' },
        { id: 'avatar3', url: 'avatars/avatar3.png' },
        { id: 'avatar4', url: 'avatars/avatar4.png' },
        { id: 'avatar5', url: 'avatars/avatar5.png' },
        { id: 'avatar6', url: 'avatars/avatar6.png' },
        { id: 'avatar7', url: 'avatars/avatar7.png' },
        { id: 'avatar8', url: 'avatars/avatar8.png' },
        { id: 'avatar9', url: 'avatars/avatar9.png' },
        { id: 'avatar10', url: 'avatars/avatar10.png' },
        { id: 'avatar11', url: 'avatars/avatar11.png' },
        { id: 'avatar12', url: 'avatars/avatar12.png' },
        { id: 'avatar13', url: 'avatars/avatar13.png' },
        { id: 'avatar14', url: 'avatars/avatar14.png' },
        { id: 'avatar15', url: 'avatars/avatar15.png' },
        { id: 'avatar16', url: 'avatars/avatar16.png' }

    ];
    function runApp() {
        const loader = document.getElementById('loader');

        const firebaseConfig = {
          apiKey: "AIzaSyC9qRRHO-m3e_2Kfs14wxxjsovhrE3idXs",
          authDomain: "kelime-avla.firebaseapp.com",
          projectId: "kelime-avla",
          storageBucket: "kelime-avla.firebasestorage.app",
          messagingSenderId: "557108031682",
          appId: "1:557108031682:web:a0738215100b2c6b864b5b",
          measurementId: "G-XYCB5BS8SR"
        };

        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }

        ReactDOM.render(<App />, document.getElementById('root'));

        setTimeout(() => {
            if (loader) {
                loader.classList.add('hidden');
            }
        }, 1800);
    }


    function AvatarSelectionModal({ isOpen, onClose, onAvatarSelect }) {
        if (!isOpen) return null;

        return (
            <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}>
                <div
                    className="bg-gradient-to-br from-slate-50 to-gray-100 p-6 rounded-2xl shadow-2xl w-full max-w-md text-center flex flex-col max-h-[85vh] border border-gray-200"
                    onClick={e => e.stopPropagation()}
                >
                    <h3 className="text-3xl font-black mb-6 text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 flex-shrink-0">
                        Avatarını Seç
                    </h3>

                    <div className="overflow-y-auto scrollbar-thin flex-1 pr-2 -mr-2">
                        <div className="grid grid-cols-3 sm:grid-cols-4 gap-4">
                            {availableAvatars.map(avatar => (
                                <div key={avatar.id} onClick={() => onAvatarSelect(avatar.id)} className="cursor-pointer group flex flex-col items-center">
                                    <img
                                        src={avatar.url}
                                        alt={avatar.id}
                                        className="w-20 h-20 rounded-full object-cover bg-gray-200 border-4 border-transparent group-hover:border-indigo-500 group-hover:scale-110 group-hover:shadow-lg transition-all duration-200"
                                    />
                                </div>
                            ))}
                        </div>
                    </div>

                    <button
                        onClick={onClose}
                        className="mt-8 bg-slate-200 text-slate-800 font-bold py-2 px-8 rounded-lg hover:bg-slate-300 transition-all flex-shrink-0 shadow-sm"
                    >
                        Kapat
                    </button>
                </div>
            </div>
        );
    }



function ShareButtons({ text, setToastMessage }) {
    const gameUrl = "https://play.google.com/store/apps/details?id=com.ozcelikinc.kelimeavlama";

    const copyLink = () => {
        navigator.clipboard.writeText(gameUrl).then(() => {
            setToastMessage("Link panoya kopyalandı!");
        }, (err) => {
            console.error('Link kopyalanamadı', err);
            setToastMessage("Hata: Link kopyalanamadı.");
        });
    };

    const handleShare = () => {
        const shareContent = `${text} ${gameUrl}`;
        if (window.Android && typeof window.Android.shareGeneric === 'function') {
            window.Android.shareGeneric(shareContent);
        } else {
            alert("Bu özellik sadece uygulamada kullanılabilir.");
        }
    };

    return (
        <div className="w-full mt-6 pt-4 border-t border-white/20 text-center">
            <h4 className="font-bold text-sm text-white/80 mb-3">Sonucu Paylaş</h4>
            <div className="flex justify-center items-center gap-3">

                {/* YENİ VE DAHA GÜZEL PAYLAŞ BUTONU */}
                <button onClick={handleShare} title="Paylaş"
                        className="h-12 flex-1 flex items-center justify-center gap-2 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-bold rounded-full transition-all transform hover:scale-105 shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                        <path strokeLinecap="round" strokeLinejoin="round" d="M8.684 13.342C8.886 12.938 9 12.482 9 12s-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z" />
                    </svg>
                    <span>Paylaş</span>
                </button>

                {/* Linki Kopyala Butonu */}
                <button onClick={copyLink} title="Linki Kopyala"
                        className="w-12 h-12 flex-shrink-0 flex items-center justify-center bg-white/10 hover:bg-white/20 rounded-full transition-all transform hover:scale-105">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-6 h-6 text-white">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244" />
                    </svg>
                </button>
            </div>
        </div>
    );
}


const PlayerCard = ({ player, onOpenInviteModal, onSendRequest, onRemoveFriend }) => {
    const isFriend = player.isFriend;
    const onlineStatusColor = player.presence === 'online' ? 'bg-green-400' : 'bg-gray-400';
    const cardBgColor = player.cardColor
        ? playerCardColors.find(c => c.id === player.cardColor)?.class || 'bg-white'
        : 'bg-white';

    return (
        <div className={`p-2 rounded-xl shadow-sm flex items-center gap-3 transition-all hover:shadow-md ${cardBgColor}`}>
            
            <div className="relative flex-shrink-0">
                <img
                    src={player.avatarId ? `avatars/${player.avatarId}.png` : 'avatars/default.png'}
                    alt={player.username}
                    className="w-12 h-12 rounded-full object-cover border-2 border-white shadow"
                />
                <div className={`absolute bottom-0 right-0 w-3 h-3 ${onlineStatusColor} rounded-full border-2 border-white`} title={player.presence}></div>
            </div>

            <div className="flex-1 min-w-0">
                <p className="font-bold text-sm text-slate-800 truncate">{player.username}</p>
                <p className="text-xs text-slate-500">{player.presence === 'online' ? 'Çevrimiçi' : 'Çevrimdışı'}</p>
            </div>

            {/* === BUTON İKONLARI EMOJI/KARAKTER İLE YENİLENDİ === */}
            <div className="flex-shrink-0 flex items-center gap-2">
                {isFriend ? (
                    <button
                        onClick={() => onRemoveFriend(player)}
                        className="w-9 h-9 flex items-center justify-center bg-slate-200 text-slate-600 text-xl font-black rounded-full transition-all duration-200 transform hover:scale-110 hover:bg-red-500 hover:text-white shadow-sm"
                        title="Arkadaşlıktan Çıkar"
                    >
                        -
                    </button>
                ) : (
                    <button
                        onClick={() => onSendRequest(player)}
                        className="w-9 h-9 flex items-center justify-center bg-slate-200 text-slate-600 text-xl font-black rounded-full transition-all duration-200 transform hover:scale-110 hover:bg-indigo-500 hover:text-white shadow-sm"
                        title="Arkadaş Ekle"
                    >
                       +
                    </button>
                )}
                <button
                    onClick={() => onOpenInviteModal(player)}
                    className="w-9 h-9 flex items-center justify-center bg-slate-200 text-slate-600 text-xl rounded-full transition-all duration-200 transform hover:scale-110 hover:bg-green-500 hover:text-white shadow-sm"
                    title="Oyuna Davet Et"
                >
                    ⚔️
                </button>
            </div>
        </div>
    );
};

function ProfileModal({ isOpen, onClose, username, avatarId, cardColor, gold, unlockedAvatars, unlockedColors, onAvatarSelect, onUsernameUpdate, onColorSelect, onPurchaseItem }) {
    if (!isOpen) return null;

    const [newUsername, setNewUsername] = React.useState(username);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div
                className="bg-gradient-to-br from-slate-50 to-gray-100 p-6 rounded-2xl shadow-2xl w-full max-w-md text-center flex flex-col max-h-[90vh]"
                onClick={e => e.stopPropagation()}
            >
                <h3 className="text-3xl font-black mb-4 text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 flex-shrink-0">Profilin</h3>

                <div className="mb-6 flex-shrink-0">
                    <label className="block text-sm font-bold text-slate-700 mb-2">Kullanıcı Adını Değiştir</label>
                    <div className="flex gap-2">
                        <input
                            type="text"
                            value={newUsername}
                            onChange={(e) => setNewUsername(e.target.value)}
                            className="flex-1 border-2 border-slate-300 p-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400"
                            maxLength={15}
                            placeholder="Yeni kullanıcı adın..."
                        />
                        <button
                            onClick={() => onUsernameUpdate(newUsername)}
                            className="px-4 py-2 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition-colors shadow-md"
                        >
                            Kaydet
                        </button>
                    </div>
                </div>

                <div className="flex-1 min-h-0 overflow-y-auto scrollbar-thin pr-2 -mr-4">
                    <div className="mb-6 border-t pt-4">
                        <label className="block text-sm font-bold text-slate-700 mb-3">Kart Rengini Seç</label>
                        <div className="flex flex-wrap justify-center gap-3">
                            {playerCardColors.map(color => {
                                const isUnlocked = (unlockedColors || []).includes(color.id);
                                const cost = 2;

                                return (
                                    <div key={color.id} className="flex flex-col items-center gap-1">
                                        <div
                                            onClick={() => isUnlocked ? onColorSelect(color.id) : onPurchaseItem('color', color.id, cost)}
                                            title={isUnlocked ? color.name : `Kilidi açmak için ${cost} altın`}
                                            className={`relative w-10 h-10 rounded-full cursor-pointer ${color.class} border-4 transition-all hover:scale-110 shadow-md ${cardColor === color.id ? 'border-green-500 scale-110 ring-2 ring-offset-2 ring-green-500' : 'border-transparent'}`}
                                        >
                                            {/* DEĞİŞİKLİK: Koyu katman kaldırıldı, sadece kilit ikonu kaldı */}
                                            {!isUnlocked && (
                                                <div className="absolute inset-0 rounded-full flex items-center justify-center bg-black/20">
                                                    <span className="text-2xl text-white drop-shadow-md">🔒</span>
                                                </div>
                                            )}
                                        </div>
                                        {!isUnlocked && <span className="text-xs font-bold text-amber-600 bg-amber-100 px-1.5 py-0.5 rounded-full">{cost}💰</span>}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    <div className="border-t pt-4">
                        <label className="block text-sm font-bold text-slate-700 mb-4">Avatarını Değiştir</label>
                        <div className="grid grid-cols-4 sm:grid-cols-5 gap-4">
                            {availableAvatars.map(avatar => {
                                const isUnlocked = (unlockedAvatars || []).includes(avatar.id);
                                const cost = 5;

                                return (
                                    <div key={avatar.id} onClick={() => isUnlocked ? onAvatarSelect(avatar.id) : onPurchaseItem('avatar', avatar.id, cost)} className="cursor-pointer group flex flex-col items-center gap-1">
                                        <div className="relative" title={isUnlocked ? '' : `Kilidi açmak için ${cost} altın`}>
                                            <img
                                                src={avatar.url}
                                                alt={avatar.id}
                                                className={`w-16 h-16 rounded-full object-cover bg-gray-200 border-4 transition-all duration-200 shadow-md ${avatarId === avatar.id ? 'border-green-500 scale-110' : 'border-transparent'} group-hover:border-indigo-500 group-hover:scale-110`}
                                            />
                                            {/* DEĞİŞİKLİK: Koyu katman kaldırıldı, sadece kilit ikonu kaldı */}
                                            {!isUnlocked && (
                                                <div className="absolute inset-0 rounded-full flex items-center justify-center bg-black/20">
                                                    <span className="text-3xl text-white drop-shadow-md">🔒</span>
                                                </div>
                                            )}
                                        </div>
                                        {!isUnlocked && <span className="text-xs font-bold text-amber-600 bg-amber-100 px-1.5 py-0.5 rounded-full mt-1">{cost}💰</span>}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>

                <button onClick={onClose} className="mt-6 bg-slate-200 text-slate-800 font-bold py-2 px-8 rounded-lg hover:bg-slate-300 transition-all shadow-sm flex-shrink-0">
                    Kapat
                </button>
            </div>
        </div>
    );
}


function FriendRequestModal({ isOpen, requestDetails, onAccept, onDecline }) {
        if (!isOpen || !requestDetails) return null;

        return (
            <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
                <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-sm text-center">
                    <h3 className="text-2xl font-bold mb-2 text-gray-800">Arkadaşlık İsteği</h3>
                    <p className="text-gray-600 text-lg mb-6">
                        <span className="font-bold text-indigo-600">{requestDetails.from}</span> seni arkadaş olarak eklemek istiyor.
                    </p>
                    <div className="flex justify-center gap-4 mt-4">
                        <button onClick={onDecline} className="px-8 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Reddet</button>
                        <button onClick={onAccept} className="px-8 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700">Kabul Et</button>
                    </div>
                </div>
            </div>
        );
    }

function RoomCreateModal({ isOpen, onClose, onCreate }) {
    if (!isOpen) return null;

    const [maxPlayers, setMaxPlayers] = React.useState(3);
    const [boardSize, setBoardSize] = React.useState('medium');
    const [difficulty, setDifficulty] = React.useState('easy');

    const handleCreateClick = () => {
        onCreate({ maxPlayers, boardSize, difficulty });
        onClose();
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-sm" onClick={e => e.stopPropagation()}>
                <h3 className="text-2xl font-bold mb-6 text-gray-800 text-center">Yeni Oda Kur</h3>
                <div className="space-y-6">
                    <div>
                        <label className="block text-lg font-semibold text-slate-700 mb-3">Oyuncu Sayısı</label>
                        <div className="grid grid-cols-2 gap-3">
                            <button onClick={() => setMaxPlayers(3)} className={`p-4 font-bold rounded-xl transition-all transform ${maxPlayers === 3 ? 'bg-indigo-600 text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 hover:bg-slate-300'}`}>3 Oyuncu</button>
                            <button onClick={() => setMaxPlayers(4)} className={`p-4 font-bold rounded-xl transition-all transform ${maxPlayers === 4 ? 'bg-indigo-600 text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 hover:bg-slate-300'}`}>4 Oyuncu</button>
                        </div>
                    </div>
                    <div>
                        <h4 className="font-semibold text-lg text-slate-700 mb-3">Zorluk Seviyesi</h4>
                        <div className="grid grid-cols-2 gap-3">
                            <button onClick={() => setDifficulty('easy')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${difficulty === 'easy' ? 'bg-gradient-to-br from-green-400 to-emerald-500 text-white ring-4 ring-offset-2 ring-green-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">🧸</span> <span className="mt-1 text-sm">Kolay</span> </button>
                            <button onClick={() => setDifficulty('hard')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${difficulty === 'hard' ? 'bg-gradient-to-br from-red-500 to-rose-600 text-white ring-4 ring-offset-2 ring-red-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">🔥</span> <span className="mt-1 text-sm">Zor</span> </button>
                        </div>
                    </div>
                    <div>
                        <h4 className="font-semibold text-lg text-slate-700 mb-3">Oyun Alanı Boyutu</h4>
                        <div className="grid grid-cols-3 gap-3">
                            <button onClick={() => setBoardSize('small')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${boardSize === 'small' ? 'bg-gradient-to-br from-gray-400 to-gray-500 text-white ring-4 ring-offset-2 ring-gray-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">🤏</span> <span className="mt-1 text-xs">Küçük</span> </button>
                            <button onClick={() => setBoardSize('medium')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${boardSize === 'medium' ? 'bg-gradient-to-br from-sky-500 to-blue-600 text-white ring-4 ring-offset-2 ring-sky-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">👌</span> <span className="mt-1 text-xs">Orta</span> </button>
                            <button onClick={() => setBoardSize('large')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${boardSize === 'large' ? 'bg-gradient-to-br from-purple-500 to-violet-600 text-white ring-4 ring-offset-2 ring-purple-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">👐</span> <span className="mt-1 text-xs">Geniş</span> </button>
                        </div>
                    </div>
                </div>
                <button onClick={handleCreateClick} className="w-full mt-8 bg-green-500 text-white font-bold py-3 rounded-lg hover:bg-green-600 transition-all text-lg">Odayı Oluştur</button>
            </div>
        </div>
    );
}


function AccordionSection({ title, isOpen, onToggle, children, badgeCount, icon, colorClasses }) {
    const headerColor = colorClasses || 'bg-white';

    return (
        <div className="rounded-xl bg-white/70 backdrop-blur-sm shadow-md overflow-hidden transition-all duration-300">
            <button onClick={onToggle} className={`w-full flex justify-between items-center p-4 text-left font-bold transition-colors ${headerColor}`}>
                <span className="flex items-center gap-3">
                    {/* İkonun yazı boyutu büyütüldü */}
                    {icon && <div className="w-8 h-8 flex items-center justify-center rounded-lg bg-white/50 text-xl">{icon}</div>}
                    <span className="text-lg">{title}</span>
                </span>
                <span className="flex items-center gap-3">
                    {badgeCount > 0 && <span className="bg-indigo-500 text-white text-xs font-bold px-2.5 py-1 rounded-full">{badgeCount}</span>}
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={`w-6 h-6 transition-transform ${isOpen ? 'transform rotate-180' : ''}`}>
                        <path fillRule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clipRule="evenodd" />
                    </svg>
                </span>
            </button>
            {isOpen && (
                <div className="relative p-4 border-t border-slate-200/50">
                    <button onClick={onToggle} className="absolute top-2 right-2 text-slate-400 hover:text-slate-600 p-1 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-5 h-5"><path d="M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z" /></svg>
                    </button>
                    {children}
                </div>
            )}
        </div>
    );
}


function DuelLobbyPage({ username, onBack, db, setToastMessage, joinGameRoom, createGameRoom, sendDirectInvite }) {



    const [openSection, setOpenSection] = React.useState('lobi');
    const [gameRooms, setGameRooms] = React.useState([]);
    const [onlineUsers, setOnlineUsers] = React.useState([]);
    const [allUsers, setAllUsers] = React.useState([]);
    const [friends, setFriends] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [isCreateModalOpen, setCreateModalOpen] = React.useState(false);
    const [invitePlayer, setInvitePlayer] = React.useState(null);
    const [confirmAction, setConfirmAction] = React.useState({ isOpen: false });

    React.useEffect(() => {
        if (!db || !username) return;
        const usersUnsubscribe = db.collection('users').onSnapshot(usersSnapshot => {
            const friendsSubUnsubscribe = db.collection('users').doc(username).collection('friends').onSnapshot(friendsSnapshot => {
                const lobbyUnsubscribe = db.collection('lobby').onSnapshot(lobbySnapshot => {
                    const presenceMap = new Map();
                    lobbySnapshot.docs.forEach(doc => presenceMap.set(doc.id, doc.data().presence || 'offline'));
                    const friendUsernames = new Set(friendsSnapshot.docs.map(doc => doc.id));
                    const allUsersData = usersSnapshot.docs
                        .map(doc => {
                            const data = doc.data();
                            return {
                                username: doc.id,
                                avatarId: data.avatarId,
                                cardColor: data.cardColor,
                                presence: presenceMap.get(doc.id) || 'offline',
                                isFriend: friendUsernames.has(doc.id)
                            };
                        })
                        .filter(u => u.username !== username);
                    setAllUsers(allUsersData);
                    setFriends(allUsersData.filter(u => u.isFriend));
                    setOnlineUsers(allUsersData.filter(u => u.presence === 'online'));
                    setLoading(false);
                });
                return () => lobbyUnsubscribe();
            });
            return () => friendsSubUnsubscribe();
        });
        const roomsUnsubscribe = db.collection('game_rooms').where('status', '==', 'waiting')
            .onSnapshot(snapshot => setGameRooms(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))));
        
        return () => { roomsUnsubscribe(); usersUnsubscribe(); };
    }, [db, username]);

    const handleSendFriendRequest = async (targetPlayer) => {
        const requestRef = db.collection('users').doc(targetPlayer.username).collection('friendRequests').doc(username);
        try {
            await requestRef.set({ from: username, timestamp: firebase.firestore.FieldValue.serverTimestamp() });
            setToastMessage(`${targetPlayer.username} kişisine arkadaşlık isteği gönderildi!`);
        } catch (error) {
            setToastMessage("Hata: İstek gönderilemedi.");
        }
    };

    const handleRemoveFriend = (targetPlayer) => {
        setConfirmAction({
            isOpen: true,
            title: "Arkadaşlıktan Çıkar",
            bodyText: `<b>${targetPlayer.username}</b> kişisini arkadaşlıktan çıkarmak istediğinize emin misiniz?`,
            onConfirm: async () => {
                const currentUserFriendsRef = db.collection('users').doc(username).collection('friends').doc(targetPlayer.username);
                const targetUserFriendsRef = db.collection('users').doc(targetPlayer.username).collection('friends').doc(username);
                await Promise.all([currentUserFriendsRef.delete(), targetUserFriendsRef.delete()]);
                setToastMessage(`${targetPlayer.username} arkadaşlıktan çıkarıldı.`);
                setConfirmAction({ isOpen: false });
            }
        });
    };

    const PlayerList = ({ players }) => {
        if (!players || players.length === 0) return <p className="text-center text-slate-500 py-4">Burada kimse yok.</p>;
        return (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-2 max-h-96 overflow-y-auto scrollbar-thin p-1">
                {players.map(player => (
                    <PlayerCard
                        key={player.username}
                        player={player}
                        onSendRequest={handleSendFriendRequest}
                        onRemoveFriend={handleRemoveFriend}
                        onOpenInviteModal={setInvitePlayer}
                    />
                ))}
            </div>
        );
    };

    const RoomList = ({ rooms }) => {
        if (rooms.length === 0) {
            return <p className="text-center text-slate-500 py-4">Aktif oyun odası bulunmuyor.</p>;
        }
        return (
            <div className="space-y-3 max-h-96 overflow-y-auto scrollbar-thin">
                {rooms.map(room => {
                     const playerCount = Object.keys(room.players).length;
                     const isFull = playerCount >= room.gameSettings.maxPlayers;
                     return (
                         <div key={room.id} className="bg-white p-3 rounded-lg shadow flex items-center justify-between">
                             <div>
                                <p className="font-bold text-slate-800">{room.host}'un Odası</p>
                                <p className="text-sm text-slate-500">
                                    {playerCount} / {room.gameSettings.maxPlayers} Oyuncu
                                </p>
                             </div>
                             <button onClick={() => joinGameRoom(room.id)} disabled={isFull} className="bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 disabled:bg-gray-400">
                                 {isFull ? 'Dolu' : 'Katıl'}
                             </button>
                         </div>
                     );
                })}
            </div>
        );
    };

    const handleToggle = (section) => setOpenSection(prev => (prev === section ? null : section));
    
    return (
        <>
            <div className="h-full w-full bg-gradient-to-br from-indigo-50 to-purple-100 flex flex-col">
                <div className="container mx-auto px-4 pt-3 flex flex-col flex-1">
                    <header className="my-2 flex-shrink-0 flex items-center justify-between">
                        <button onClick={onBack} className="bg-white/80 border border-slate-200 text-slate-600 px-4 py-2 rounded-lg font-semibold hover:bg-white">Geri</button>
                        <h1 className="text-3xl font-black text-slate-700">Oyun Lobisi</h1>
                        <div className="w-20"></div>
                    </header>

                     {loading ? <p className="text-center mt-10">Yükleniyor...</p> : (
                        <div className="flex-1 min-h-0 overflow-y-auto scrollbar-thin py-4 space-y-3">
                            
                            {/* İkonlar artık component değil, doğrudan emoji */}
                            <AccordionSection 
                                title="Lobi" 
                                isOpen={openSection === 'lobi'} 
                                onToggle={() => handleToggle('lobi')} 
                                badgeCount={gameRooms.length}
                                icon="🎮"
                                colorClasses="bg-gradient-to-r from-purple-200 to-indigo-200 text-indigo-900 font-extrabold"
                            >
                                <div className="text-center">
                                    <button onClick={() => setCreateModalOpen(true)} className="w-full mb-4 bg-indigo-600 text-white px-4 py-3 rounded-lg font-semibold hover:bg-indigo-700 transition-colors shadow-lg">
                                        + Yeni Oda Kur
                                    </button>
                                    <RoomList rooms={gameRooms} />
                                </div>
                            </AccordionSection>

                            <AccordionSection 
                                title="Şu Anda Online" 
                                isOpen={openSection === 'online'} 
                                onToggle={() => handleToggle('online')} 
                                badgeCount={onlineUsers.length}
                                icon="🟢"
                                colorClasses="text-green-800"
                            >
                                <PlayerList players={onlineUsers} />
                            </AccordionSection>
                            
                            <AccordionSection 
                                title="Arkadaşlar" 
                                isOpen={openSection === 'arkadaslar'} 
                                onToggle={() => handleToggle('arkadaslar')} 
                                badgeCount={friends.length}
                                icon="❤️"
                                colorClasses="text-sky-800"
                            >
                                <PlayerList players={friends} />
                            </AccordionSection>

                            <AccordionSection 
                                title="Tüm Kullanıcılar" 
                                isOpen={openSection === 'kullanicilar'} 
                                onToggle={() => handleToggle('kullanicilar')} 
                                badgeCount={allUsers.length}
                                icon="🌍"
                                colorClasses="text-slate-800"
                            >
                                <PlayerList players={allUsers} />
                            </AccordionSection>
                        </div>
                    )}
                </div>
            </div>
            <RoomCreateModal isOpen={isCreateModalOpen} onClose={() => setCreateModalOpen(false)} onCreate={createGameRoom} />
            <DuelInviteModal isOpen={!!invitePlayer} onClose={() => setInvitePlayer(null)} player={invitePlayer} onInvite={sendDirectInvite} />
            <ConfirmationModal 
                isOpen={confirmAction.isOpen} 
                onClose={() => setConfirmAction({ isOpen: false })} 
                onConfirm={confirmAction.onConfirm}
                title={confirmAction.title}
                bodyText={confirmAction.bodyText}
            />
        </>
    );
}


    

    

    const servers = {
          iceServers: [
            {
              urls: [
                'stun:stun1.l.google.com:19302',
                'stun:stun2.l.google.com:19302',
              ],
            },
          ],
          iceCandidatePoolSize: 10,
        };

    let peerConnection = null;
    let dataChannel = null;

    const firebaseConfig = {
      apiKey: "AIzaSyC9qRRHO-m3e_2Kfs14wxxjsovhrE3idXs",
      authDomain: "kelime-avla.firebaseapp.com",
      projectId: "kelime-avla",
      storageBucket: "kelime-avla.firebasestorage.app",
      messagingSenderId: "557108031682",
      appId: "1:557108031682:web:a0738215100b2c6b864b5b",
      measurementId: "G-XYCB5BS8SR"
    };

    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }
    const db = firebase.firestore();
    const ALL_SAVES_KEY = 'wordHuntAllSaves';

    window.onerror = function (msg, url, lineNo, columnNo, error) { console.error(`Global error: ${msg}\nURL: ${url}\nLine: ${lineNo}\nColumn: ${columnNo}\nError:`, error); const root = document.getElementById('root'); if (root) root.innerHTML = `<div class="p-4 text-red-600">Beklenmedik bir hata oluştu. Lütfen sayfayı yenileyin. Hata: ${msg}</div>`; return false; };
    function customToUpperCase(str) { if (typeof str !== 'string') return ''; try { return str.replace(/i/g, 'İ').replace(/ı/g, 'I').replace(/ğ/g, 'Ğ').replace(/ü/g, 'Ü').replace(/ş/g, 'Ş').replace(/ö/g, 'Ö').replace(/ç/g, 'Ç').toUpperCase(); } catch (err) { console.error('customToUpperCase hatası:', err); return (str || '').toUpperCase(); } }
    class ErrorBoundary extends React.Component { state = { hasError: false }; static getDerivedStateFromError(error) { return { hasError: true }; } componentDidCatch(error, errorInfo) { console.error("ErrorBoundary yakaladı:", error, errorInfo); } render() { if (this.state.hasError) { return <div className="p-4 text-red-600">Beklenmedik bir hata oluştu. Lütfen sayfayı yenileyin.</div>; } return this.props.children; } }

    const vibrate = (pattern) => { if ('vibrate' in navigator) { if (pattern === 'success') navigator.vibrate(50); else if (pattern === 'error') navigator.vibrate([100, 50, 100]); else if (pattern === 'achievement') navigator.vibrate([100, 50, 100, 50, 100]); else if (typeof pattern === 'number') navigator.vibrate(pattern); } };



const wordFoundColors = [
    { bg: 'bg-rose-200', text: 'text-rose-800' },
    { bg: 'bg-amber-200', text: 'text-amber-800' },
    { bg: 'bg-emerald-200', text: 'text-emerald-800' },
    { bg: 'bg-sky-200', text: 'text-sky-800' },
    { bg: 'bg-indigo-200', text: 'text-indigo-800' },
    { bg: 'bg-violet-200', text: 'text-violet-800' },
];

    const getInitialTime = (currentMode, currentLevel) => {
        if (!currentMode.startsWith('timed')) return 120;
        let baseTime = currentMode === 'timed-hard' ? 180 : 120;
        return baseTime + (currentLevel * 4);
    };


    const achievementsList = {
        'level_10': {icon: '🎓',title: 'Acemi Kaşif',description: '10. seviyeye ulaş.',isUnlocked: (stats) => stats.maxLevelCompleted >= 9},
        'level_25': {icon: '🗺️',title: 'Deneyimli Gezgin',description: '25. seviyeye ulaş.',isUnlocked: (stats) => stats.maxLevelCompleted >= 24},
        'level_50': {icon: '🏆',title: 'Usta Maceracı',description: '50. seviyeye ulaş.',isUnlocked: (stats) => stats.maxLevelCompleted >= 49},
        'super_easy_win': {icon: '🧸',title: 'Park Gezintisi',description: 'Aşırı Kolay modda bir seviye tamamla.',
        isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['super-easy']    },
        'easy_win': {icon: '😊',title: 'Tanıdık Yollar',description: 'Kolay modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['easy']    },
        'hard_mode_win': {icon: '🔥',title: 'Ateşle Oynayan',description: 'Zor modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['hard']},
        'timed_easy_win': {icon: '⏱️',title: 'Zamana Karşı',description: 'Süreli Kolay modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['timed-easy']},
        'timed_hard_win': {        icon: '⚡',        title: 'Şimşek Hızı',        description: 'Süreli Zor modda bir seviye tamamla.',
    isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['timed-hard']    },
        'score_10000': {
            icon: '💰',
            title: 'Puan Koleksiyoncusu',
            description: 'Herhangi bir modda 10,000 puana ulaş.',
            isUnlocked: (stats) => Object.values(stats.highScores).some(score => score >= 10000)
        },
        'gold_50': {
            icon: '💎',
            title: 'Altın Madencisi',
            description: 'Toplamda 50 altın biriktir.',
            isUnlocked: (stats) => stats.gold >= 50
        }
    };

    function AchievementsList({ stats, language }) {
        const t = translations[language] || translations['en'];
        return (
            <div className="text-left overflow-y-auto max-h-[60vh] mt-4 pr-2 scrollbar-thin">
                <ul className="space-y-3">
                    {Object.values(achievementsList).map((ach, index) => {
                        const unlocked = ach.isUnlocked(stats);
                        return (
                            <li
                                key={index}
                                className={`flex items-center p-4 rounded-lg transition-all ${unlocked ? 'bg-green-100 dark:bg-green-800/30' : 'bg-gray-100 dark:bg-gray-800 opacity-60'}`}
                            >
                                <span className={`text-4xl mr-4 ${unlocked ? '' : 'grayscale'}`}>{ach.icon}</span>
                                <div className="flex-1">
                                    <p className={`font-bold text-gray-800 dark:text-gray-100 ${unlocked ? '' : 'text-gray-500'}`}>{ach.title}</p>
                                    <p className={`text-sm text-gray-600 dark:text-gray-400 ${unlocked ? '' : 'text-gray-500'}`}>{ach.description}</p>
                                </div>
                                {unlocked && (
                                    <span className="text-3xl text-green-500">✓</span>
                                )}
                            </li>
                        );
                    })}
                </ul>
            </div>
        );
    }

    const translations = {
        tr: {
            title: "Kelime Avı",
            easyMode: "KOLAY (NORMAL)",
            leaderboard: "Liderlik",
            lobbyTitle: "Çok Oyunculu",
            lobbyDescription: "Arkadaşlarınla veya diğer oyuncularla yarış",
            vsAiTitle: "Yapay Zekaya Karşı",
            vsAiDescription: "Bilgisayara karşı kelime bulma yeteneğini sına",
            wordHuntTitle: "Kelime Avı Klasik",
            wordHuntDescription: "Harflerin arasına gizlenmiş kelimeleri bul",
            wordTrackingTitle: "Kelime Takibi",
            wordTrackingDescription: "Harfleri birleştirerek yılan gibi kelimeler oluştur",
çok: "ÇOK",
            aşırı: "AŞIRI",
            kolay: "KOLAY",
            normal: "NORMAL",
            zor: "ZOR",
            süreli: "SÜRELİ",
            hardMode: "ZOR (NORMAL)",
            timedEasyMode: "SÜRELİ KOLAY",
            timedHardMode: "SÜRELİ ZOR",
            superEasyMode: "ÇOK KOLAY",
            randomMode: "RASTGELE",
            continueGame: (level) => `Devam Et (Seviye ${level})`,
            level: "Seviye",
            words: "Kelimeler",
            hiddenWord: "Gizli Sözcük",
            hiddenWordPlaceholder: "Gizli sözcüğü girin",
            checkButton: "Kontrol Et",
            homeButton: "Anasayfa",
            footer: `© ${new Date().getFullYear()} Ozcelik Inc. Tüm hakları saklıdır.`,
            congrats: "Tebrikler!",
            error: "Hata!",
            successMessage: (word) => `Harika! Gizli sözcüğü buldunuz: ${word}`,
            allWordsRequired: "Önce tüm kelimeleri bulmalısınız!",
            wrongGuess: "Yanlış tahmin! Tekrar deneyin.",
            gameCompleted: "Tebrikler! Oyunu başarıyla tamamladınız!",
            timeUp: "Süre Bitti!",
            finalScore: (score) => `Skorunuz: ${score}`,
            continueButton: "Devam Et",
            tryAgainButton: "Tekrar Dene",
            language: "Dil",
            turkish: "Türkçe",
            english: "English",
            achievements: "Başarılar",
            highScore: "Yüksek Skor",
            score: "Puan",
            gold: "Altın",
            randomGameTitle: "🐟 Rastgele 🐟",
            randomGameBody: (mode, level) => `Sizin için <span class="font-bold">${mode}</span> modunda, <span class="font-bold">Seviye ${level}</span> hazırlandı. Bu oyun kaydedilmez.`,
            startButton: "Başla!",
            savedGameFoundTitle: "Kayıtlı Oyun Bulundu",
            savedGameFoundBody: (level) => `Bu modda <span class="font-bold">Seviye ${level}</span>'de kayıtlı bir oyununuz mevcut. Ne yapmak istersiniz?`,
            noStartNewButton: "Hayır, Yeni Oyun Başlat",
            yesContinueButton: "Evet, Devam Et",
            returnToHomeButton: "Anasayfa",
            nextLevelButton: "Devam→",
            loadingLevel: (level) => `Seviye ${level} Yükleniyor...`,
            levelLoadError: "Üzgünüz, bu seviye yüklenirken bir sorun oluştu."
        }, en: { leaderboard: "Leaderboard", aşırı: "SUPER", kolay: "EASY", normal: "NORMAL", zor: "HARD", süreli: "TIMED", title: "Word Hunt", easyMode: "EASY (NORMAL)", hardMode: "HARD (NORMAL)", timedEasyMode: "TIMED EASY", timedHardMode: "TIMED HARD", superEasyMode: "SUPER EASY", randomMode: "RANDOM", continueGame: (level) => `Continue (Level ${level})`, level: "Level", words: "Words", hiddenWord: "Hidden Word", hiddenWordPlaceholder: "Enter the hidden word", checkButton: "Check", homeButton: "Homepage", footer: `© ${new Date().getFullYear()} Ozcelik Inc. All rights reserved.`, congrats: "Congratulations!", error: "Error!", successMessage: (word) => `Awesome! You found the hidden word: ${word}`, allWordsRequired: "You must find all the words first!", wrongGuess: "Wrong guess! Try again.", gameCompleted: "Congratulations! You have successfully completed the game!", timeUp: "Time's Up!", finalScore: (score) => `Your Score: ${score}`, continueButton: "Continue", tryAgainButton: "Try Again", language: "Language", turkish: "Türkçe", english: "English", achievements: "Achievements", highScore: "High Score", score: "Score", gold: "Gold", randomGameTitle: "🎁 Random Game 🎁", randomGameBody: (mode, level) => `A game in <span class="font-bold">${mode}</span> mode, <span class="font-bold">Level ${level}</span> has been prepared for you. This game will not be saved.`, startButton: "Start!", savedGameFoundTitle: "Saved Game Found", savedGameFoundBody: (level) => `You have a saved game in this mode at <span class="font-bold">Level ${level}</span>. What would you like to do?`, noStartNewButton: "No, Start New Game", yesContinueButton: "Yes, Continue", returnToHomeButton: "Return to Homepage", nextLevelButton: "Next Level →", loadingLevel: (level) => `Loading Level ${level}...`, levelLoadError: "Sorry, a problem occurred while loading this level." } };

    const charSets = { tr: 'ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ'.split(''), en: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('') };
    const wordLists = { tr: typeof wordListTr !== 'undefined' ? wordListTr : [], en: typeof wordListEn !== 'undefined' ? wordListEn : [] };
    const wordLists_2letters = { tr: typeof wordListTr_2letters !== 'undefined' ? wordListTr_2letters : [], en: [] };
        
        const directions = { diagonal: [ { name: 'down-right', dx: 1, dy: 1 }, { name: 'down-left', dx: 1, dy: -1 }, { name: 'up-right', dx: -1, dy: 1 }, { name: 'up-left', dx: -1, dy: -1 } ], horizontal: [ { name: 'right', dx: 0, dy: 1 }, { name: 'left', dx: 0, dy: -1 } ], vertical: [ { name: 'down', dx: 1, dy: 0 }, { name: 'up', dx: -1, dy: 0 } ] };
        const allDirections = [...directions.diagonal, ...directions.horizontal, ...directions.vertical];
        const nonDiagonalDirections = [...directions.horizontal, ...directions.vertical];
const GAME_STATS_KEY = 'wordHuntGameStats';
        const USED_WORDS_KEY = 'wordHuntUsedWords';
        const loadUsedWords = () => { try { const data = localStorage.getItem(USED_WORDS_KEY); return data ? JSON.parse(data) : {}; } catch (e) { console.error("Kullanılmış kelimeler yüklenemedi:", e); return {}; } };
        const saveUsedWord = (mode, word) => { try { if (!mode || !word) return; const usedWords = loadUsedWords(); if (!usedWords[mode]) { usedWords[mode] = []; } if (!usedWords[mode].includes(word)) { usedWords[mode].push(word); localStorage.setItem(USED_WORDS_KEY, JSON.stringify(usedWords)); } } catch (e) { console.error("Kullanılmış kelime kaydedilemedi:", e); } };


    const loadGameStats = () => {
        try {
            const stats = localStorage.getItem(GAME_STATS_KEY);
            if (stats) {
                const parsedStats = JSON.parse(stats);
                if (!parsedStats.modesCompleted) {
                    parsedStats.modesCompleted = {};
                }
                return parsedStats;
            }
        } catch (e) {
            console.error("İstatistikler yüklenemedi:", e);
        }
        return { totalWordsFound: 0, maxLevelCompleted: -1, highScores: {}, modesCompleted: {} };
    };

    const saveGameStats = (stats) => { try { localStorage.setItem(GAME_STATS_KEY, JSON.stringify(stats)); } catch (e) { console.error("İstatistikler kaydedilemedi:", e); } };
















function createBoard(level, language, config) {
    console.log(`[createBoard Başladı] Seviye: ${level}, Mod: ${config?.name}, Tip: ${config?.modeType}, Boyut: ${config?.boardSize}`);
    
    if (config && config.modeType === 'takip') {
        return createTakipBoard(level, language, config);
    } 

    try {
        let rows, cols;
        const modeName = config ? config.name : 'easy';

        if (modeName === 'vs-computer') {
            const sizes = { small: { r: 7, c: 7 }, medium: { r: 9, c: 9 }, large: { r: 11, c: 11 } };
            rows = sizes[config.boardSize].r; cols = sizes[config.boardSize].c;
        } else if (modeName === 'multiplayer') {
            const sizes = { small: { r: 7, c: 7 }, medium: { r: 9, c: 8 }, large: { r: 11, c: 11 } };
            rows = sizes[config.boardSize].r; cols = sizes[config.boardSize].c;
        } else {
            if (modeName === 'super-easy') {
                const stage = Math.min(Math.floor(level / 12), 4);
                rows = 6 + stage; cols = 6 + stage;
            } else {
                const stage = Math.min(Math.floor(level / 18), 4);
                rows = 8 + stage; cols = 9 + stage;
            }
        }
        
        const mainWordPool = _.shuffle((wordLists[language] || []).filter(w => w && w.length >= 3 && w.length < Math.min(rows, cols)).map(customToUpperCase));
        const twoLetterWordPool = _.shuffle((wordLists_2letters[language] || []).map(customToUpperCase));
        const selectedTwoLetterWords = twoLetterWordPool.slice(0, 2);
        
        const wordsToPlacePool = [...selectedTwoLetterWords, ...mainWordPool];
        
        for (let attempt = 1; attempt <= 100; attempt++) {
            const board = Array(rows).fill(null).map(() => Array(cols).fill(null));
            const occupied = Array(rows).fill(null).map(() => Array(cols).fill(false));
            let placedWordsInfo = [];
            let placedCellCount = 0;

            const canPlace = (word, r, c, dir) => {
                for (let i = 0; i < word.length; i++) {
                    const nextR = r + i * dir.dx; const nextC = c + i * dir.dy;
                    if (nextR < 0 || nextR >= rows || nextC < 0 || nextC >= cols || occupied[nextR][nextC]) return false;
                }
                return true;
            };

            const placeWord = (word, r, c, dir) => {
                const positions = [];
                for (let i = 0; i < word.length; i++) {
                    const currentR = r + i * dir.dx; const currentC = c + i * dir.dy;
                    board[currentR][currentC] = word[i];
                    occupied[currentR][currentC] = true;
                    positions.push({ row: currentR, col: currentC });
                }
                placedCellCount += word.length;
                placedWordsInfo.push({ word, positions, direction: dir.name });
            };
            
            // YENİ VE DÜZELTİLMİŞ KISIM: %50 Çapraz Kuralını Uygula
            const shuffledWords = _.shuffle(wordsToPlacePool);
            const midPoint = Math.ceil(shuffledWords.length / 2);
            const diagonalWords = shuffledWords.slice(0, midPoint);
            const nonDiagonalWords = shuffledWords.slice(midPoint);

            const placeWordSet = (wordSet, directionSet) => {
                for (const word of wordSet) {
                    const availablePositions = [];
                    // Her kelime için tahtadaki tüm olası yerleri ve yönleri bul
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            for (const dir of directionSet) {
                                if (canPlace(word, r, c, dir)) {
                                    availablePositions.push({ r, c, dir });
                                }
                            }
                        }
                    }
                    // Eğer yerleştirilebilecek bir yer varsa, rastgele birini seç ve yerleştir
                    if (availablePositions.length > 0) {
                        const { r, c, dir } = _.sample(availablePositions);
                        placeWord(word, r, c, dir);
                    }
                }
            };
            
            // Önce sadece çapraz yerleşebilecek kelimeleri yerleştir
            placeWordSet(diagonalWords, directions.diagonal);
            // Sonra sadece düz (yatay/dikey) yerleşebilecek kelimeleri yerleştir
            placeWordSet(nonDiagonalWords, nonDiagonalDirections);
            
            const fillRatio = placedCellCount / (rows * cols);
            if (fillRatio < 0.85 && attempt < 99) {
                if(attempt % 10 === 0) console.log(`Deneme #${attempt}: Doluluk oranı düşük (${(fillRatio * 100).toFixed(1)}%), yeniden deneniyor.`);
                continue;
            }
            
            console.log(`[createBoard] BAŞARILI! Deneme #${attempt}, Doluluk: ${(fillRatio * 100).toFixed(1)}%, Kelime Sayısı: ${placedWordsInfo.length}`);

            for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { if (board[r][c] === null) board[r][c] = _.sample(charSets[language]); } }
            
            let hiddenWord = _.sample(mainWordPool.filter(w => w.length >= 5 && w.length <= 9 && !placedWordsInfo.some(p => p.word === w))) || "TÜRKİYE";
            
            return { board, words: _.sortBy(placedWordsInfo, 'word'), hiddenWord, scatteredHiddenLetterPositions: [] };
        }
    } catch (e) {
        console.error(`[createBoard] KRİTİK HATA:`, e);
        return null;
    }

    console.error("[createBoard] UYARI: 100 denemeye rağmen istenen kurallarda bir tahta oluşturulamadı.");
    return null;
}









function createTakipBoard(level, language, config) {
    let rows, cols;
    const { boardSize, name } = config;

    if (boardSize) {
        const sizes = { small: { r: 9, c: 7 }, medium: { r: 12, c: 9 }, large: { r: 15, c: 11 } };
        rows = sizes[boardSize].r; cols = sizes[boardSize].c;
    } else if (name === 'super-easy') {
        const stage = Math.min(Math.floor(level / 12), 4);
        rows = 4 + stage; cols = 5 + stage;
    } else {
        const stage = Math.min(Math.floor(level / 18), 4);
        rows = 8 + stage; cols = 9 + stage;
    }

    const mainWordPool = (wordLists[language] || []).filter(w => w && w.length >= 3 && w.length <= 8).map(customToUpperCase);
    
    for (let attempt = 0; attempt < 50; attempt++) {
        let potentialWords = _.shuffle(mainWordPool);
        const board = Array(rows).fill(null).map(() => Array(cols).fill(null));
        let placedWordsInfo = [];
        const occupiedCoords = new Set();

        const buildWindingPath = (word) => {
            for (let i = 0; i < 200; i++) {
                const emptyCells = [];
                for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { if(!occupiedCoords.has(`${r}-${c}`)) emptyCells.push({r,c}); }}
                if (emptyCells.length < word.length) return null;
                const startCell = _.sample(emptyCells);
                if (!startCell) continue;
                let path = [{ row: startCell.r, col: startCell.c }];
                const tempOccupied = new Set(occupiedCoords);
                tempOccupied.add(`${startCell.r}-${startCell.c}`);
                let straightCount = 1;
                let lastDir = null;
                let success = true;

                for (let j = 1; j < word.length; j++) {
                    const lastPos = path[j-1];
                    let possibleDirs = [];
                    const directionsToTry = directions.horizontal.concat(directions.vertical);
                    for(const dir of _.shuffle(directionsToTry)) {
                        if (lastDir && dir.dx === -lastDir.dx && dir.dy === -lastDir.dy) continue;
                        const nextR = lastPos.row + dir.dx; const nextC = lastPos.col + dir.dy;
                        if(nextR >= 0 && nextR < rows && nextC >=0 && nextC < cols && !tempOccupied.has(`${nextR}-${nextC}`)){
                            possibleDirs.push(dir);
                        }
                    }
                    if(possibleDirs.length === 0) { success = false; break; }
                    let finalDirs = possibleDirs;
                    if(lastDir && straightCount >= 3) {
                        const nonStraightDirs = possibleDirs.filter(dir => !(dir.dx === lastDir.dx && dir.dy === lastDir.dy));
                        if(nonStraightDirs.length > 0) finalDirs = nonStraightDirs;
                    }
                    const chosenDir = _.sample(finalDirs);
                    if (!chosenDir) { success = false; break; }
                    const nextPos = { row: lastPos.row + chosenDir.dx, col: lastPos.col + chosenDir.dy };
                    path.push(nextPos);
                    tempOccupied.add(`${nextPos.row}-${nextPos.col}`);
                    if (lastDir && chosenDir.dx === lastDir.dx && chosenDir.dy === lastDir.dy) { straightCount++; } else { straightCount = 1; }
                    lastDir = chosenDir;
                }
                if(success) return path;
            }
            return null;
        };

        for(const word of potentialWords) {
            const path = buildWindingPath(word);
            if(path) {
                path.forEach((pos, k) => {
                    board[pos.row][pos.col] = word[k];
                    occupiedCoords.add(`${pos.row}-${pos.col}`);
                });
                placedWordsInfo.push({ word, positions: path, direction: 'snake' });
            }
        }
        
        const filledRatio = occupiedCoords.size / (rows * cols);
        if (filledRatio < 0.85 && attempt < 45) { // Alanın en az %85'i dolmadıysa, tekrar dene
            continue;
        }

        for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { if (board[r][c] === null) board[r][c] = _.sample(charSets[language]); } }

        let hiddenWord = _.sample(mainWordPool.filter(w => w.length >= 5 && w.length <= 9)) || "TÜRKİYE";
        const hiddenWordLetters = hiddenWord.split('');
        let currentBoardLetters = new Set();
        for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { currentBoardLetters.add(board[r][c]); } }
        
        const missingLetters = hiddenWordLetters.filter(l => !currentBoardLetters.has(l));
        if (missingLetters.length > 0) {
            const unlockedCells = [];
            for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { if(!occupiedCoords.has(`${r}-${c}`)) unlockedCells.push({r,c}); }}
            _.shuffle(unlockedCells).slice(0, missingLetters.length).forEach((cell, i) => {
                board[cell.r][cell.c] = missingLetters[i];
            });
        }
        
        const scatteredHiddenLetterPositions = [];
        const hiddenWordCharCount = _.countBy(hiddenWordLetters);
        const tempBoard = JSON.parse(JSON.stringify(board));
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const char = tempBoard[r][c];
                if (hiddenWordCharCount[char] > 0) {
                    scatteredHiddenLetterPositions.push({ row: r, col: c });
                    hiddenWordCharCount[char]--;
                    tempBoard[r][c] = null;
                }
            }
        }
        
        return { board, words: _.sortBy(placedWordsInfo, 'word'), hiddenWord, scatteredHiddenLetterPositions };
    }
    console.error("Kelime Takibi tahtası oluşturulamadı.");
    return null; 
}




















function Modal({ isOpen, title, children, onClose }) { if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}> <div className="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full text-center relative" onClick={e => e.stopPropagation()}> <h3 className="text-2xl font-semibold mb-4 text-gray-800">{title}</h3> <div className="text-gray-700">{children}</div> <button onClick={onClose} className="absolute top-2 right-2 text-gray-500 hover:text-gray-800 text-2xl">&times;</button> </div> </div> ); }

const Cell = React.memo(function Cell({letter, isSelected, isFoundRequiredPart, isHiddenLetterCell, allRequiredWordsFound, isJustFound, isBonusGlow, theme, numCols, foundWordColorInfo }) {
    let cellClass = 'bg-white';
    let textClass = 'text-gray-800';

    if (isBonusGlow) {
        cellClass = 'animate-bonus-glow';
    }
    else if (allRequiredWordsFound) {
        if (isHiddenLetterCell) {
            cellClass = theme.hiddenWordCell;
            textClass = 'text-white';
        } else {
            cellClass = theme.obscuredCell;
        }
    } else {
        if (isJustFound) {
            cellClass = 'animate-word-found';
        } else if (isSelected) {
            cellClass = theme.selectedCell + ' transform scale-110 shadow-lg';
            textClass = 'text-black font-bold';
        } else if (isFoundRequiredPart) {
            // YENİ RENK MANTIĞI
            if (foundWordColorInfo) {
                cellClass = foundWordColorInfo.bg;
                textClass = foundWordColorInfo.text;
            } else {
                cellClass = theme.foundCell; // Fallback
                textClass = 'text-gray-600 opacity-75';
            }
        }
    }

    const calculateFontSize = () => {
        if (!numCols) return { fontSize: '18px' };
        const maxGridWidth = 768;
        const targetRatio = 0.6;
        const minFontSize = 10;
        const preferredVw = (100 / numCols) * targetRatio;
        const maxFontSize = (maxGridWidth / numCols) * targetRatio;
        return {
            fontSize: `clamp(${minFontSize}px, ${preferredVw.toFixed(2)}vw, ${maxFontSize.toFixed(2)}px)`
        };
    };

    const fontSizeStyle = calculateFontSize();

    return (
        <div
            className={`flex items-center justify-center text-center font-semibold border border-gray-200/50 rounded aspect-square ${cellClass} ${textClass} transition-all duration-150 select-none`}
            style={fontSizeStyle}
        >
            {letter || ''}
        </div>
    );
});

    function LeaderboardDisplay({ scores, currentUser, language }) {
            const t = translations[language] || translations['en'];
            if (!scores || scores.length === 0) {
                return <p className="text-gray-600 dark:text-gray-400 pt-10">Bu mod için henüz skor bulunmuyor.</p>;
            }
            const rankIcons = ['🥇', '🥈', '🥉'];
            return (
                <div className="text-left overflow-y-auto max-h-[300px] mt-4 pr-2 scrollbar-thin">
                    <ul className="space-y-2">
                        {scores.map((score, index) => {
                            const isCurrentUser = score.username === currentUser;
                            return (
                                <li
                                    key={score.id || index}
                                    className={`flex items-center p-3 rounded-lg transition-all ${isCurrentUser ? 'bg-yellow-100 dark:bg-yellow-800/20 border-2 border-yellow-400' : 'bg-gray-50 dark:bg-gray-800'}`}
                                >
                                    <span className="font-bold text-lg w-10 text-center text-gray-500 dark:text-gray-400">
                                        {rankIcons[index] || index + 1}
                                    </span>

                                    <div className="flex-1">
                                        <p className={`font-semibold text-gray-800 dark:text-gray-200 ${isCurrentUser ? 'text-yellow-900 dark:text-yellow-300' : ''}`}>
                                            {score.username}
                                        </p>
                                        {score.level && (
                                            <p className={`text-xs text-gray-500 dark:text-gray-400 ${isCurrentUser ? 'text-yellow-800 dark:text-yellow-400' : ''}`}>
                                                Seviye {score.level}
                                            </p>
                                        )}
                                    </div>

                                    <span className={`font-bold text-xl text-indigo-600 dark:text-indigo-400 tabular-nums ${isCurrentUser ? 'text-yellow-900 dark:text-yellow-300' : ''}`}>
                                        {score.score}
                                    </span>
                                </li>
                            );
                        })}
                    </ul>
                </div>
            );
        }

    function LeaderboardModal({ isOpen, onClose, currentUser, language }) { const t = translations[language] || translations['en']; const [activeTab, setActiveTab] = React.useState('super-easy'); const [scores, setScores] = React.useState({ 'super-easy': [], easy: [], hard: [], 'timed-easy': [], 'timed-hard': [] }); const [loading, setLoading] = React.useState(true);

        const tabs = [

        { key: 'super-easy', line1Key: 'çok', line2Key: 'kolay', activeBg: 'bg-green-500' },
                { key: 'easy', line1Key: 'kolay', line2Key: 'normal', activeBg: 'bg-teal-500' },
                { key: 'hard', line1Key: 'zor', line2Key: 'normal', activeBg: 'bg-red-500' },
                { key: 'timed-easy', line1Key: 'süreli', line2Key: 'kolay', activeBg: 'bg-blue-500' },
                { key: 'timed-hard', line1Key: 'süreli', line2Key: 'zor', activeBg: 'bg-orange-500' }
            ];

         React.useEffect(() => { if (isOpen) { setLoading(true); const fetchPromises = tabs.map(tab => db.collection("scores") .where("mode", "==", tab.key) .orderBy("score", "desc") .limit(50) .get() ); Promise.all(fetchPromises) .then(snapshots => { const newScores = {}; snapshots.forEach((snapshot, index) => { const mode = tabs[index].key; newScores[mode] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); }); setScores(newScores); }) .catch(error => console.error("Liderlik tablosu verileri çekilirken hata oluştu:", error)) .finally(() => setLoading(false)); } }, [isOpen]); if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}> <div className="bg-white dark:bg-gray-900 p-4 sm:p-6 rounded-xl shadow-2xl max-w-lg w-full text-center relative" onClick={e => e.stopPropagation()}> <h3 className="text-3xl font-bold mb-4 text-gray-800 dark:text-gray-100">🏆 {t.leaderboard} 🏆</h3> <button onClick={onClose} className="absolute top-2 right-2 text-gray-500 hover:text-gray-800 dark:hover:text-gray-200 text-3xl">&times;</button> <div className="flex items-center border-b-2 border-gray-200 dark:border-gray-700"> {tabs.map(tab => { const isActive = activeTab === tab.key; return ( <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`flex-1 flex flex-col justify-center items-center h-14 py-1 text-center transition-all duration-300 border-x border-transparent ${isActive ? `${tab.activeBg} scale-105 z-10 rounded-t-lg` : 'hover:bg-gray-100 dark:hover:bg-gray-800'}`}> <span className={`block text-xs font-bold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}> {t[tab.line1Key]} </span> <span className={`block text-xs font-semibold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}> {t[tab.line2Key]} </span> </button> ); })} </div> <div className="min-h-[300px]"> {loading ? ( <p className="text-gray-600 dark:text-gray-400 pt-10">Liderlik tablosu yükleniyor...</p> ) : ( <LeaderboardDisplay scores={scores[activeTab]} currentUser={currentUser} language={language} /> )} </div> </div> </div> ); }




function HomePage({
        startGame,
        startGameVsComputer,
        language,
        setLanguage,
        stats,
        setModalContent,
        username,
        isInitializing,
        openLobbyPage,
        avatarId,
        openProfileModal,
        cardColor,
        playerCardColors
    }) {
        const t = translations[language] || translations['en'];
        const [expandedSection, setExpandedSection] = React.useState(null);

        const handleSectionClick = (section) => {
            setExpandedSection(prevSection => (prevSection === section ? null : section));
        };

        const MainSectionCard = ({ sectionKey, title, icon, onClick, bgColor, children, description }) => {
            const isOpen = expandedSection === sectionKey;
            return (
                <div className={`rounded-2xl shadow-lg text-white overflow-hidden ${bgColor}`}>
                    <button onClick={onClick} className="w-full p-5 flex justify-between items-center text-left">
                        <div className="flex items-center gap-4">
                            <span className="text-5xl drop-shadow-lg">{icon}</span>
                            <div>
                                <h3 className="text-2xl font-bold">{title}</h3>
                                <p className="text-sm opacity-80 font-medium">{description}</p>
                            </div>
                        </div>
                        {children && (
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={`w-8 h-8 transition-transform duration-300 ${isOpen ? 'transform rotate-180' : ''}`}>
                                <path fillRule="evenodd" d="M12.53 16.28a.75.75 0 01-1.06 0l-7-7.5a.75.75 0 011.06-1.06L12 14.69l6.97-6.97a.75.75 0 111.06 1.06l-7.5 7.5z" clipRule="evenodd" />
                            </svg>
                        )}
                         {!children && <span className="text-3xl font-bold">→</span>}
                    </button>
                    {isOpen && (
                        <div className="bg-black/20 p-4">
                            {children}
                        </div>
                    )}
                </div>
            );
        };

        const SubModeCard = ({ title, icon, onClick, disabled, bgColor }) => (
             <button onClick={onClick} disabled={disabled} className={`p-3 w-full h-full rounded-lg flex flex-col items-center justify-center text-center transition-all transform hover:scale-105 disabled:opacity-50 ${bgColor || 'bg-white/20 hover:bg-white/30'} backdrop-blur-sm`}>
                <span className="text-4xl">{icon}</span>
                <span className="font-semibold mt-1">{title}</span>
            </button>
        );
        
        const selectedCardColor = playerCardColors.find(c => c.id === cardColor) || playerCardColors.find(c => c.id === 'gray');

        return (
            <div className="h-full w-full bg-slate-100 flex flex-col">
                <div className="container mx-auto px-4 pt-3 text-center flex flex-col flex-1 overflow-hidden">
                    <header className="my-2 flex-shrink-0 flex items-center justify-between">
                         <div className="text-left">
                            <h1 className="text-4xl md:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 drop-shadow-sm">{t.title}</h1>
                            <p className="text-slate-500 text-sm mt-1">Kelime dehası olmaya hazır mısın?</p>
                        </div>
                        {username && (
                            <div 
                                onClick={openProfileModal}
                                className={`p-3 rounded-2xl shadow-sm border border-white/20 transition-all cursor-pointer hover:shadow-lg hover:scale-105 ${selectedCardColor.class}`}
                            >
                                <div className="flex flex-col items-center gap-1.5 pointer-events-none">
                                    <div className="relative">
                                        <img
                                            src={avatarId ? `avatars/${avatarId}.png` : 'avatars/default.png'}
                                            className="w-12 h-12 rounded-full object-cover bg-gray-200 border-2 border-white shadow-md"
                                        />
                                        <div
                                            className="absolute bottom-0 right-0 w-3.5 h-3.5 bg-green-400 rounded-full border-2 border-white"
                                            title={'Çevrimiçi'}
                                        ></div>
                                    </div>
                                    <p className="font-bold text-sm text-white drop-shadow">{username}</p>
                                </div>
                            </div>
                        )}
                    </header>

                    <div className="flex-1 overflow-y-auto scrollbar-thin py-4">
                        <div className="w-full max-w-md mx-auto space-y-4">
                            <MainSectionCard sectionKey="lobi" title={t.lobbyTitle} icon="⚔️" description={t.lobbyDescription} onClick={openLobbyPage} bgColor="bg-gradient-to-br from-purple-600 to-indigo-700" />
                            <MainSectionCard sectionKey="vs_ai" title={t.vsAiTitle} icon="🤖" description={t.vsAiDescription} onClick={startGameVsComputer} bgColor="bg-gradient-to-br from-slate-500 to-slate-700" />

							<MainSectionCard sectionKey="kelime_avi" title={t.wordHuntTitle} icon="🧭" description={t.wordHuntDescription} onClick={() => handleSectionClick('kelime_avi')} bgColor="bg-gradient-to-br from-sky-500 to-cyan-600">
								<div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
									<SubModeCard title={t.superEasyMode} icon="🐻" onClick={() => startGame('super-easy')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.easyMode} icon="🗺️" onClick={() => startGame('easy')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.hardMode} icon="🌋" onClick={() => startGame('hard')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.timedEasyMode} icon="⏱️" onClick={() => startGame('timed-easy')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.timedHardMode} icon="🔥" onClick={() => startGame('timed-hard')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.randomMode} icon="🎲" onClick={() => startGame('random')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
								</div>
							</MainSectionCard>

							{/* DEĞİŞİKLİK: Kelime Takibi bölümünden "Zor" ve "Süreli Zor" modları kaldırıldı. */}
							<MainSectionCard sectionKey="kelime_takibi" title={t.wordTrackingTitle} icon="🎯" description={t.wordTrackingDescription} onClick={() => handleSectionClick('kelime_takibi')} bgColor="bg-gradient-to-br from-amber-500 to-orange-600">
							   <div className="grid grid-cols-2 sm:grid-cols-2 gap-3"> {/* Grid sm:grid-cols-2 olarak değiştirildi */}
									<SubModeCard title={t.superEasyMode} icon="🐛" onClick={() => startGame('takip-super-easy')} bgColor="bg-amber-800/50 hover:bg-amber-700/60" />
									<SubModeCard title={t.easyMode} icon="🐍" onClick={() => startGame('takip-easy')} bgColor="bg-amber-800/50 hover:bg-amber-700/60" />
									<SubModeCard title={t.timedEasyMode} icon="⏳" onClick={() => startGame('takip-timed-easy')} bgColor="bg-amber-800/50 hover:bg-amber-700/60" />
									<SubModeCard title={t.randomMode} icon="❓" onClick={() => startGame('takip-random')} bgColor="bg-amber-800/50 hover:bg-amber-700/60" />
								</div>
							</MainSectionCard>
						</div>
                    </div>
                </div>
            </div>
        );
    }








function WordHunt({ config, gameId, username, goToHome, language, stats, onStatsChange, initialSavedState, setToastMessage, toastMessage }) {
    const t = translations[language] || translations['en'];
    let infoBarClass = 'from-violet-100 to-indigo-100'; 
    if (config.name === 'super-easy') {
        infoBarClass = 'from-green-100 to-emerald-200 text-green-900';
    } else if (config.name === 'easy' || config.name === 'timed-easy') {
        infoBarClass = 'from-sky-100 to-blue-200 text-sky-900';
    } else if (config.name === 'hard' || config.name === 'timed-hard') {
        infoBarClass = 'from-red-100 to-rose-200 text-red-900';
    }
    const [isGenerating, setIsGenerating] = React.useState(true); 
    const isRealtimeDuel = !!gameId;
    const isVsComputer = config.name === 'vs-computer';
    const [realtimeGameData, setRealtimeGameData] = React.useState(null);
    const [computerState, setComputerState] = React.useState({ score: 0, foundWords: [] });
    const [board, setBoard] = React.useState(null);
    const [foundWordsInOrder, setFoundWordsInOrder] = React.useState([]);
    const [foundCellColorMap, setFoundCellColorMap] = React.useState({});
    const [isLoading, setIsLoading] = React.useState(true);
    const [error, setError] = React.useState('');
    const [level, setLevel] = React.useState(config?.level ?? initialSavedState?.level ?? 0);
    const [score, setScore] = React.useState(initialSavedState?.score ?? 0);
    const [foundWords, setFoundWords] = React.useState(initialSavedState?.foundWords ?? []);
    const [gameState, setGameState] = React.useState(null);
    const [timeLeft, setTimeLeft] = React.useState(initialSavedState?.timeLeft ?? getInitialTime(config.name, 0));
    const [modalContent, setModalContent] = React.useState({ isOpen: false });
    const [justFoundWordInfo, setJustFoundWordInfo] = React.useState(null);
    const [allRequiredWordsFound, setAllRequiredWordsFound] = React.useState(false);
    const [isShaking, setIsShaking] = React.useState(false);
    const [levelStartTime, setLevelStartTime] = React.useState(null);
    const [hiddenWordAttempts, setHiddenWordAttempts] = React.useState(0);
    const [answerSlots, setAnswerSlots] = React.useState([]);
    const [sourceLetters, setSourceLetters] = React.useState([]);
    const [hintLockedSlots, setHintLockedSlots] = React.useState([]);
    const [hiddenWordTimeLeft, setHiddenWordTimeLeft] = React.useState(null);
    const gridRef = React.useRef(null);
    const [selectedCells, setSelectedCells] = React.useState([]);
    const [isSwiping, setIsSwiping] = React.useState(false);
    const foundWordsRef = React.useRef(foundWords);
    const computerStateRef = React.useRef(computerState);
    const lastHiddenTimestamp = React.useRef(null);
    const [bonusGlowCells, setBonusGlowCells] = React.useState([]);
    const [foundBonusWords, setFoundBonusWords] = React.useState([]);
    const theme = (config.name === 'hard' || config.name === 'timed-hard') ? { bg: 'bg-red-50', foundCell: 'bg-red-200', hiddenWordCell: 'bg-blue-400 text-white font-bold', wordBg: 'bg-red-100', gridBg: 'bg-red-100', button: 'bg-red-600 hover:bg-red-700', inputBorder: 'border-red-300 focus:border-red-500', selectedCell: 'bg-yellow-400', obscuredCell: 'bg-gray-400 text-transparent opacity-50' } : { bg: 'bg-indigo-50', foundCell: 'bg-green-200', hiddenWordCell: 'bg-blue-400 text-white font-bold', wordBg: 'bg-indigo-100', gridBg: 'bg-indigo-100', button: 'bg-indigo-600 hover:bg-indigo-700', inputBorder: 'border-indigo-300 focus:border-indigo-500', selectedCell: 'bg-yellow-300', obscuredCell: 'bg-gray-400 text-transparent opacity-50' };
    const lastProcessedCell = React.useRef(null);
    const cellOwnerMap = React.useMemo(() => {
        const map = {};
        if (!isRealtimeDuel || !realtimeGameData?.players || !realtimeGameData?.boardData?.words) return map;
        
        for (const playerName in realtimeGameData.players) {
            const playerInfo = realtimeGameData.players[playerName];
            if (playerInfo.foundWords && playerInfo.foundWords.length > 0) {
                const wordsFoundByPlayer = realtimeGameData.boardData.words.filter(w => playerInfo.foundWords.includes(w.word));
                for (const word of wordsFoundByPlayer) {
                    if (word.positions) {
                        for (const pos of word.positions) {
                            map[`${pos.row}-${pos.col}`] = playerName;
                        }
                    }
                }
            }
        }
        return map;
    }, [realtimeGameData, isRealtimeDuel]);

    React.useEffect(() => {
        if (isRealtimeDuel || isVsComputer) {
            setIsLoading(false);
            return;
        };
        setIsGenerating(true);
        setError('');
        setTimeout(() => {
            const newBoardData = createBoard(level, language, config);
            if (newBoardData) {
                setGameState(newBoardData);
                setBoard(newBoardData.board);
                if(initialSavedState && initialSavedState.level === level) {
                    setFoundWords(initialSavedState.foundWords || []);
                    setScore(initialSavedState.score || 0);
                    setTimeLeft(initialSavedState.timeLeft || getInitialTime(config.name, level));
                } else {
                    setFoundWords([]);
                    setScore(0);
                    setTimeLeft(getInitialTime(config.name, level));
                }
                setAllRequiredWordsFound(false);
                setHiddenWordAttempts(0);
                setJustFoundWordInfo(null);
                setAnswerSlots([]);
                setSourceLetters([]);
                setHintLockedSlots([]);
                setLevelStartTime(Date.now());
            } else {
                setError(t.levelLoadError);
            }
            setIsGenerating(false);
            setIsLoading(false);
        }, 100);
    }, [level, config.name, language, isRealtimeDuel, isVsComputer, initialSavedState]);
    
    React.useEffect(() => {
        if (!isRealtimeDuel) return;
        setIsLoading(true);
        const gameRef = db.collection('game_rooms').doc(gameId);
        const unsubscribe = gameRef.onSnapshot(doc => {
            if (!doc.exists) {
                setError('Oyun odası bulunamadı veya kapatıldı.');
                setIsLoading(false);
                setIsGenerating(false);
                setTimeout(goToHome, 3000);
                return;
            }
            const data = doc.data();
            setRealtimeGameData(data);
            if (data.boardData && data.boardData.board && Object.keys(data.boardData.board).length > 0) {
                setBoard(Object.values(data.boardData.board));
                setGameState(data.boardData);
                setIsLoading(false);
                setIsGenerating(false); 
            }
        });
        return () => unsubscribe();
    }, [isRealtimeDuel, gameId]);

    React.useEffect(() => {
        if (!isVsComputer) return;
        setIsGenerating(true);
        setError('');
        setTimeout(() => {
            const newBoardData = createBoard(null, language, config);
            if (newBoardData) {
                setGameState(newBoardData);
                setBoard(newBoardData.board);
                setFoundWords([]);
                setComputerState({ score: 0, foundWords: [] });
                setScore(0);
            } else {
                setError(t.levelLoadError);
            }
            setIsGenerating(false);
            setIsLoading(false);
        }, 100);
    }, [isVsComputer, config.name, language]);

    const handleInteractionMove = React.useCallback((clientX, clientY) => {
    const isTrackingMode = config.modeType === 'takip';

    setSelectedCells(prevSelectedCells => {
        const currentCell = getCellFromCoordinates(clientX, clientY);

        if (!currentCell || (lastProcessedCell.current && lastProcessedCell.current.row === currentCell.row && lastProcessedCell.current.col === currentCell.col)) {
            return prevSelectedCells;
        }
        lastProcessedCell.current = currentCell;
        if (!isSwiping || !board || prevSelectedCells.length === 0) {
            return prevSelectedCells;
        }

        const currentCell = getCellFromCoordinates(clientX, clientY);
        if (!currentCell) {
            return prevSelectedCells;
        }
        
        if (isTrackingMode) {
            if (prevSelectedCells.length > 1) {
                const secondToLastCell = prevSelectedCells[prevSelectedCells.length - 2];
                if (secondToLastCell.row === currentCell.row && secondToLastCell.col === currentCell.col) {
                    return prevSelectedCells.slice(0, -1);
                }
            }

            const lastCell = prevSelectedCells[prevSelectedCells.length - 1];
            const isAlreadySelected = prevSelectedCells.some(cell => cell.row === currentCell.row && cell.col === currentCell.col);
            
            // Sadece yatay ve dikey komşulara izin veren orijinal kural
            const isAdjacent = (Math.abs(currentCell.row - lastCell.row) === 1 && currentCell.col === lastCell.col) ||
                               (Math.abs(currentCell.col - lastCell.col) === 1 && currentCell.row === lastCell.row);

            if (!isAlreadySelected && isAdjacent && !isCellFound(currentCell.row, currentCell.col)) {
                return [...prevSelectedCells, currentCell];
            }
        } else { // Kelime Avı modu için (değişiklik yok)
            const startCell = prevSelectedCells[0];
            const dx = Math.sign(currentCell.col - startCell.col);
            const dy = Math.sign(currentCell.row - startCell.row);

            if (dx === 0 && dy === 0 && prevSelectedCells.length > 1) return prevSelectedCells;
            if (!((dx !== 0 && dy !== 0 && Math.abs(currentCell.col - startCell.col) === Math.abs(currentCell.row - startCell.row)) || (dx === 0 || dy === 0))) {
                 return prevSelectedCells;
            }

            const distance = Math.max(Math.abs(currentCell.row - startCell.row), Math.abs(currentCell.col - startCell.col));
            const newSelection = [];
            for (let i = 0; i <= distance; i++) {
                const nextRow = startCell.row + i * dy;
                const nextCol = startCell.col + i * dx;
                if (nextRow >= 0 && nextRow < board.length && nextCol >= 0 && nextCol < board[0].length) {
                    const cellToAdd = { row: nextRow, col: nextCol };
                    if (!isCellFound(cellToAdd.row, cellToAdd.col)) {
                        newSelection.push(cellToAdd);
                    } else { 
                        if (newSelection.length === 0) newSelection.push(startCell);
                        return newSelection;
                    }
                } else { 
                    return newSelection;
                }
            }
            return newSelection;
        }

        return prevSelectedCells;
    });
}, [isSwiping, board, config.modeType, getCellFromCoordinates, isCellFound]);
    
    React.useEffect(() => {
    const gridElement = gridRef.current;

    const throttledMove = _.throttle((e) => {
        handleInteractionMove(e.touches[0].clientX, e.touches[0].clientY);
    }, 16); // 60fps için ~16ms gecikme

    const handleTouchMoveWrapper = (e) => {
        e.preventDefault();
        throttledMove(e);
    };

    if (gridElement) {
        gridElement.addEventListener('touchmove', handleTouchMoveWrapper, { passive: false });

        return () => {
            gridElement.removeEventListener('touchmove', handleTouchMoveWrapper);
            throttledMove.cancel(); // Component kaldırıldığında throttle'ı iptal et
        };
    }
}, [board, isSwiping, handleInteractionMove]);

    React.useEffect(() => {
        if (!isRealtimeDuel || !realtimeGameData || !realtimeGameData.boardData || realtimeGameData.status !== 'in-progress') {
            return;
        }
        const allWordsInLevel = realtimeGameData.boardData.words;
        if (!allWordsInLevel || allWordsInLevel.length === 0) {
            return;
        }
        const allFoundWordsCombined = new Set(
            Object.values(realtimeGameData.players).flatMap(p => p.foundWords || [])
        );
        if (allFoundWordsCombined.size >= allWordsInLevel.length) {
            if (realtimeGameData.status === 'in-progress') {
                const gameRef = db.collection('game_rooms').doc(gameId);
                const finalSortedPlayers = Object.entries(realtimeGameData.players).sort(([, a], [, b]) => b.score - a.score);
                const winnerUsername = finalSortedPlayers.length > 0 ? finalSortedPlayers[0][0] : 'draw';
                gameRef.update({
                    status: 'finished',
                    winner: winnerUsername
                }).catch(err => {
                    console.error("Oyun durumu güncellenirken hata oluştu:", err);
                });
            }
        }
    }, [realtimeGameData, gameId, isRealtimeDuel]);
    
    

    const handleForfeit = () => {
        const opponentName = realtimeGameData && Object.keys(realtimeGameData.players).find(p => p !== username);
        if (gameId && opponentName) {
            db.collection('game_rooms').doc(gameId).update({ status: 'finished', winner: opponentName, reason: `${username} oyundan ayrıldı.` }).finally(() => { goToHome(); });
        } else {
            goToHome();
        }
    };

    React.useEffect(() => {
        if (!gameState || !gameState.words) return;
        const newColorMap = {};
        foundWordsInOrder.forEach((word, index) => {
            const wordInfo = gameState.words.find(w => w.word === word);
            if (wordInfo && wordInfo.positions) {
                const colorIndex = index % wordFoundColors.length;
                const colorClasses = wordFoundColors[colorIndex];
                wordInfo.positions.forEach(pos => {
                    newColorMap[`${pos.row}-${pos.col}`] = colorClasses;
                });
            }
        });
        setFoundCellColorMap(newColorMap);
    }, [foundWordsInOrder, gameState]);    

    const closeModal = () => setModalContent({ isOpen: false });
    const showExitConfirmation = React.useCallback(() => {
        const isDuel = isRealtimeDuel;
        const bodyText = isDuel
            ? "Oyundan çıkıp ana sayfaya dönmek istediğinize emin misiniz? <br /><strong class='text-red-500'>Bu işlem maçı kaybettiğiniz anlamına gelecektir.</strong>"
            : "Ana menüye dönmek istediğinize emin misiniz?";
        const confirmButtonText = isDuel ? "Evet, Terk Et" : "Evet, Çık";
        const confirmButtonAction = isDuel ? handleForfeit : goToHome;
        setModalContent({
            isOpen: true,
            title: '', 
            onClose: closeModal,
            body: (
                 <div className="w-full max-w-sm text-white bg-gradient-to-br from-slate-700 to-gray-800 rounded-2xl shadow-2xl p-6 text-center">
                    <div className="text-6xl mb-4">🤔</div>
                    <h2 className="text-2xl font-bold mb-2">Oyundan Ayrıl</h2>
                    <p className="text-white/80 mb-6" dangerouslySetInnerHTML={{ __html: bodyText }}></p>
                    <div className="flex justify-center gap-4">
                        <button onClick={closeModal} className="px-8 py-2 bg-white/20 text-white font-bold rounded-lg hover:bg-white/30">Hayır, Kal</button>
                        <button onClick={confirmButtonAction} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">{confirmButtonText}</button>
                    </div>
                </div>
            )
        });
    }, [isRealtimeDuel, isVsComputer, goToHome, handleForfeit, realtimeGameData]);

    const getCellFromCoordinates = React.useCallback((clientX, clientY) => {
        const grid = gridRef.current; if (!grid || !board || !board[0]) return null; const rect = grid.getBoundingClientRect(); const cols = board[0].length; const rows = board.length; const cellWidth = rect.width / cols; const cellHeight = rect.height / rows; const x = clientX - rect.left; const y = clientY - rect.top; const col = Math.floor(x / cellWidth); const row = Math.floor(y / cellHeight); if (row < 0 || row >= rows || col < 0 || col >= cols) return null; return { row, col }; 
    }, [board]);
    
    const isCellFound = React.useCallback((r, c) => {
    if (isRealtimeDuel) {
        if (!realtimeGameData || !realtimeGameData.boardData || !realtimeGameData.players) return false;
        for (const player of Object.values(realtimeGameData.players)) {
            // DÜZELTME: Buradaki 'p.foundWords' ifadesi 'player.foundWords' olarak değiştirildi.
            const foundWordInfo = realtimeGameData.boardData.words.filter(w => (player.foundWords || []).includes(w.word));
            for (const word of foundWordInfo) {
                // Not: Buradaki 'p' harfi pozisyonu (position) ifade ettiği için doğrudur ve değiştirilmemelidir.
                if (word.positions.some(p => p.row === r && p.col === c)) return true;
            }
        }
        return false;
    } else {
        if (gameState?.words?.some(w => foundWords.includes(w.word) && w.positions.some(p => p.row === r && p.col === c))) return 'player';
        if (isVsComputer && gameState?.words?.some(w => computerState.foundWords.includes(w.word) && w.positions.some(p => p.row === r && p.col === c))) return 'computer';
        return false;
    }
}, [isRealtimeDuel, realtimeGameData, gameState, foundWords, isVsComputer, computerState]);
    
    const handleInteractionStart = React.useCallback((clientX, clientY) => {
        const canPlay = isRealtimeDuel || isVsComputer ? true : !allRequiredWordsFound; if (!canPlay || !board) return; const cell = getCellFromCoordinates(clientX, clientY); if (cell && !isCellFound(cell.row, cell.col)) { setIsSwiping(true); setSelectedCells([cell]); } 
    }, [board, getCellFromCoordinates, isCellFound, isRealtimeDuel, allRequiredWordsFound, isVsComputer]);

    const throttledMouseMove = React.useMemo(() => _.throttle((clientX, clientY) => handleInteractionMove(clientX, clientY), 50), [handleInteractionMove]);

    const handleInteractionEnd = () => {
        if (!isSwiping || !board || selectedCells.length <= 1) {
            setIsSwiping(false);
            setSelectedCells([]);
            return;
        }
        setIsSwiping(false);
        const rawWord = selectedCells.map(c => board?.[c.row]?.[c.col] || '').join('');
        const word = customToUpperCase(rawWord);
        if (isRealtimeDuel) {
            const targetWord = realtimeGameData.boardData.words.find(w => w.word === word);
            const alreadyFoundByAnyPlayer = Object.values(realtimeGameData.players).some(p => (p.foundWords || []).includes(word));
            if (targetWord && !alreadyFoundByAnyPlayer) {
                playSound('correctSound');
                vibrate('success');
                const points = word.length * 10;
                const gameRef = db.collection('game_rooms').doc(gameId);
                const scoreUpdateKey = `players.${username}.score`;
                const scoreUpdate = { [scoreUpdateKey]: firebase.firestore.FieldValue.increment(points) };
                const wordsUpdateKey = `players.${username}.foundWords`;
                const wordsUpdate = { [wordsUpdateKey]: firebase.firestore.FieldValue.arrayUnion(word) };
                gameRef.update(scoreUpdate).catch(err => console.error("Skor güncellenirken hata:", err));
                gameRef.update(wordsUpdate).catch(err => console.error("Kelime güncellenirken hata:", err));
            } else {
                playSound('wrongSound');
                vibrate('error');
            }
        } else {
            const isAlreadyUsedByComputer = isVsComputer && selectedCells.some(cell =>
                gameState.words.some(w =>
                    computerState.foundWords.includes(w.word) &&
                    w.positions.some(p => p.row === cell.row && p.col === cell.col)
                )
            );
            if (isAlreadyUsedByComputer) {
                playSound('wrongSound');
                vibrate('error');
                setSelectedCells([]);
                return;
            }
            const targetWord = gameState.words.find(w => w.word === word);
			if (targetWord && !foundWords.includes(word)) {
				setFoundWords(prev => [...prev, word]);
				setFoundWordsInOrder(prev => [...prev, word]);
				let wordScore = isVsComputer ? word.length * 5 : word.length * (getScoreMultiplier(levelStartTime));
				setScore(s => s + wordScore);
				playSound('correctSound');
				vibrate('success');
				setJustFoundWordInfo({ word, positions: targetWord.positions });
				setTimeout(() => setJustFoundWordInfo(null), 600);
			}
            else {
                const masterWordList = (wordLists[language] || []).map(customToUpperCase);
                const isBonusWord = masterWordList.includes(word);
                const alreadyFound = foundWords.includes(word) || foundBonusWords.includes(word);
                if (isBonusWord && !alreadyFound && word.length >= 3) {
                    setFoundBonusWords(prev => [...prev, word]);
                    const bonusScore = word.length * 2;
                    setScore(s => s + bonusScore);
                    playSound('correctSound');
                    vibrate('success');
                    setJustFoundWordInfo({ word, positions: selectedCells });
                    setTimeout(() => setJustFoundWordInfo(null), 600);
                    setToastMessage(`Listede olmayan (${word}) kelimesini buldun, +${bonusScore} puan`);
                } else {
                    playSound('wrongSound');
                    vibrate('error');
                }
            }
        }
        setSelectedCells([]);
    };







    
    const playSound = React.useCallback((soundId) => {
        const sound = document.getElementById(soundId);
        if (sound) {
            sound.currentTime = 0;
            sound.play().catch(e => {});
        }
    }, []);

    const getScoreMultiplier = (startTime) => {
        if (!startTime) return 1;
        const elapsedSeconds = (Date.now() - startTime) / 1000;
        if (elapsedSeconds <= 20) return 5;
        if (elapsedSeconds <= 40) return 4;
        if (elapsedSeconds <= 60) return 3;
        if (elapsedSeconds <= 80) return 2;
        return 1;
    };

    const handleAnswerSlotClick = (letter, index) => {
        if (hintLockedSlots.includes(index) || !letter) return;
        const newAnswerSlots = [...answerSlots];
        newAnswerSlots[index] = null;
        setAnswerSlots(newAnswerSlots);
        setSourceLetters([...sourceLetters, letter]);
    };

    const handleSourceLetterClick = (letter) => {
        const firstEmptyIndex = answerSlots.findIndex(slot => slot === null);
        if (firstEmptyIndex === -1) return;
        const newAnswerSlots = [...answerSlots];
        newAnswerSlots[firstEmptyIndex] = letter;
        setAnswerSlots(newAnswerSlots);
        setSourceLetters(sourceLetters.filter(l => l.id !== letter.id));
    };
    
    const goToNextLevel = () => {
        const newStats = { ...stats };
        newStats.maxLevelCompleted = Math.max(stats.maxLevelCompleted, level);
        if (!newStats.modesCompleted) newStats.modesCompleted = {};
        newStats.modesCompleted[config.name] = true;
        const currentModeHighScore = newStats.highScores[config.name] || 0;
        newStats.highScores[config.name] = Math.max(currentModeHighScore, score);
        onStatsChange(newStats);
        closeModal();
        setLevel(prevLevel => prevLevel + 1);
    };

    const triggerConfetti = () => confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
    
    const handleCheckHiddenWord = () => {
        if (!gameState || !gameState.hiddenWord) { return; }
        const getHiddenWordMultiplier = (attempts) => { const attemptNumber = attempts + 1; if (attemptNumber === 1) return 5; if (attemptNumber === 2) return 4; if (attemptNumber === 3) return 3; if (attemptNumber === 4) return 2; return 1; };
        const guessedWord = customToUpperCase(answerSlots.map(l => l && l.char).join(''));
        const correctWord = gameState.hiddenWord;
        if (guessedWord === correctWord) {
            playSound('achievementSound'); vibrate('achievement'); triggerConfetti();
            const newStats = { ...stats }; if (!newStats.modesCompleted) newStats.modesCompleted = {};
            newStats.modesCompleted[config.name] = true; let goldEarned = 0;
            if (config.name === 'easy' || config.name === 'super-easy') goldEarned = 1; else if (config.name === 'hard') goldEarned = 3; else if (config.name === 'timed-easy') goldEarned = 5; else if (config.name === 'timed-hard') goldEarned = 8;
            newStats.gold = (stats.gold || 0) + goldEarned;
            const attemptMultiplier = getHiddenWordMultiplier(hiddenWordAttempts);
            const hiddenWordBaseScore = (correctWord.length * 50); const finalHiddenWordScore = hiddenWordBaseScore * attemptMultiplier;
            const finalScore = score + finalHiddenWordScore; setScore(finalScore);
            const currentHighScore = newStats.highScores[config.name] || 0;
            newStats.highScores[config.name] = Math.max(currentHighScore, finalScore); onStatsChange(newStats);
            const shareText = `Kelime Avı'nda ${level + 1}. seviyeyi tamamladım ve ${finalScore} puan aldım!`;
            setModalContent({
                isOpen: true, title: '', onClose: config?.isOneShot ? goToHome : goToNextLevel,
                body: ( <div className="text-white bg-gradient-to-br from-green-500 to-teal-600 rounded-2xl shadow-2xl p-6 text-center w-full max-w-sm"> <div className="text-6xl mb-3 animate-bounce">🏆</div> <h2 className="text-3xl font-black tracking-tight mb-2">Seviye Tamamlandı!</h2> <div className="grid grid-cols-2 gap-4 text-left my-6 bg-black/20 p-4 rounded-xl"> <div className="border-r border-white/20 pr-4"> <p className="text-xs text-white/70 uppercase tracking-wider">Seviye</p> <p className="text-3xl font-bold">{level + 1}</p> </div> <div> <p className="text-xs text-white/70 uppercase tracking-wider">Kazanılan Altın</p> <p className="text-3xl font-bold">💰 +{goldEarned}</p> </div> <div className="col-span-2 text-center border-t border-white/20 pt-4"> <p className="text-sm font-semibold text-white/80 uppercase">Toplam Puan</p> <p className="text-5xl font-extrabold">{finalScore}</p> </div> </div> <div className="flex flex-col gap-3"> {config?.isOneShot ? ( <button onClick={goToHome} className="w-full px-4 py-3 bg-white text-green-700 font-bold rounded-lg transform transition-transform hover:scale-105 shadow-lg">Ana Sayfaya Dön</button> ) : ( <button onClick={goToNextLevel} className="w-full px-4 py-3 bg-white text-green-700 font-bold rounded-lg transform transition-transform hover:scale-105 shadow-lg">Sonraki Seviye →</button> )} </div> <ShareButtons text={shareText} setToastMessage={setToastMessage} /> </div> )
            });
        } else {
            playSound('wrongSound'); vibrate('error'); setIsShaking(true); setTimeout(() => setIsShaking(false), 400); setHiddenWordAttempts(prev => prev + 1);
            const lettersToReturn = []; const newAnswerSlots = Array(gameState.hiddenWord.length).fill(null);
            answerSlots.forEach((letter, index) => { if (letter) { if (hintLockedSlots.includes(index)) { newAnswerSlots[index] = letter; } else { lettersToReturn.push(letter); } } });
            setSourceLetters(prevSource => _.shuffle([...prevSource, ...lettersToReturn])); setAnswerSlots(newAnswerSlots);
        }
    };
    
	const getModeDisplayName = (modeKey, translations) => {
        const keyMap = { 'super-easy': 'superEasyMode', 'easy': 'easyMode', 'hard': 'hardMode', 'timed-easy': 'timedEasyMode', 'timed-hard': 'timedHardMode' };
        const translationKey = keyMap[modeKey] || 'randomMode';
        return translations[translationKey] || modeKey;
    };
	
    const handleRevealWordHint = () => {
        const unfoundWords = gameState.words.filter(w => !foundWords.includes(w.word));
        if (stats.gold < 1 || unfoundWords.length === 0) return;
        const wordToReveal = _.sample(unfoundWords);
        onStatsChange({ ...stats, gold: stats.gold - 1 });
        setFoundWords(prev => [...prev, wordToReveal.word]);
        setJustFoundWordInfo({ word: wordToReveal.word, positions: wordToReveal.positions });
        setTimeout(() => setJustFoundWordInfo(null), 600);
        playSound('correctSound');
        vibrate('success');
    };

    const handleHiddenWordHint = () => {
        if (stats.gold < 1 || !gameState) return;
        const hintIndex = answerSlots.findIndex((slot, index) => slot === null && !hintLockedSlots.includes(index));
        if (hintIndex === -1) return;
        const correctChar = gameState.hiddenWord[hintIndex];
        let letterToMove = null;
        const newAnswerSlots = [...answerSlots];
        let newSourceLetters = [...sourceLetters];
        const sourceIdx = newSourceLetters.findIndex(l => l.char === correctChar);
        if (sourceIdx > -1) {
            letterToMove = newSourceLetters[sourceIdx];
            newSourceLetters.splice(sourceIdx, 1);
        } else {
            const wrongSlotIdx = newAnswerSlots.findIndex((l, i) => l?.char === correctChar && !hintLockedSlots.includes(i));
            if (wrongSlotIdx > -1) {
                letterToMove = newAnswerSlots[wrongSlotIdx];
                newAnswerSlots[wrongSlotIdx] = null;
            }
        }
        if (!letterToMove) return;
        if (newAnswerSlots[hintIndex]) {
            newSourceLetters.push(newAnswerSlots[hintIndex]);
        }
        newAnswerSlots[hintIndex] = letterToMove;
        setAnswerSlots(newAnswerSlots);
        setSourceLetters(_.shuffle(newSourceLetters));
        setHintLockedSlots(prev => [...prev, hintIndex]);
        onStatsChange({ ...stats, gold: stats.gold - 1 });
        playSound('correctSound');
    };

    const handleGoHomeClick = () => {
        if (config?.isOneShot) {
            goToHome();
            return;
        }
        setModalContent({
            isOpen: true,
            title: '',
            onClose: closeModal,
            body: (
                <div className="w-full max-w-sm text-white bg-gradient-to-br from-slate-700 to-gray-800 rounded-2xl shadow-2xl p-6 text-center">
                    <div className="text-6xl mb-4">👋</div>
                    <h2 className="text-2xl font-bold mb-2">Emin misin?</h2>
                    <p className="text-white/80 mb-6">
                        Ana menüye dönmek istediğine emin misin? Mevcut ilerlemen kaydedildi.
                    </p>
                    <div className="flex justify-center gap-4">
                        <button onClick={closeModal} className="px-8 py-2 bg-white/20 text-white font-bold rounded-lg hover:bg-white/30">Hayır, Kal</button>
                        <button onClick={goToHome} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Evet, Çık</button>
                    </div>
                </div>
            )
        });
    };        

	React.useEffect(() => {
        foundWordsRef.current = foundWords;
        computerStateRef.current = computerState;
    }, [foundWords, computerState]);

    React.useEffect(() => {
        if (isLoading || !isVsComputer || !gameState) {
            return;
        }
        const aiStrength = config.aiStrength || 'orta';
        const intervalTime = { zayif: 15000, orta: 11000, guclu: 7000 }[aiStrength];
        const computerMoveInterval = setInterval(() => {
            const currentFoundWordsByPlayer = foundWordsRef.current;
            const currentFoundWordsByComputer = computerStateRef.current.foundWords;
            const playerOccupiedCells = new Set();
            gameState.words.filter(w => currentFoundWordsByPlayer.includes(w.word)).forEach(wordInfo => {
                wordInfo.positions.forEach(pos => playerOccupiedCells.add(`${pos.row}-${pos.col}`));
            });
            const allCurrentlyFoundWords = [...currentFoundWordsByPlayer, ...currentFoundWordsByComputer];
            if (gameState.words.length > 0 && allCurrentlyFoundWords.length >= gameState.words.length) {
                clearInterval(computerMoveInterval);
                return;
            }
            const availableWords = gameState.words.filter(wordInfo => {
                if (allCurrentlyFoundWords.includes(wordInfo.word)) return false;
                const isOverlapping = wordInfo.positions.some(pos => playerOccupiedCells.has(`${pos.row}-${pos.col}`));
                return !isOverlapping;
            });
            if (availableWords.length > 0) {
                const wordToFind = _.sample(availableWords);
                setComputerState(prev => ({ score: prev.score + (wordToFind.word.length * 5), foundWords: [...prev.foundWords, wordToFind.word] }));
                playSound('correctSound');
            }
        }, intervalTime); 
        return () => clearInterval(computerMoveInterval);
    }, [isLoading, isVsComputer, gameState, config.aiStrength, playSound, setComputerState]);

    React.useEffect(() => {
		if (isLoading || !isVsComputer || !gameState || !gameState.words) return;
		const totalWords = gameState.words.length;
		if (totalWords === 0) return;
		const totalFoundCount = foundWords.length + computerState.foundWords.length;
		if (totalFoundCount >= totalWords) {
			const finalPlayerScore = score;
			const finalComputerScore = computerState.score;
			let resultTitle = ''; let resultIcon = '🤝'; let cardClass = ''; let shareText = '';
			if (finalPlayerScore > finalComputerScore) {
				resultTitle = 'Tebrikler, Kazandın!'; resultIcon = '🏆'; cardClass = 'from-green-500 to-teal-500';
				shareText = `Kelime Avı'nda yapay zekayı ${finalPlayerScore} - ${finalComputerScore} yendim! Sen de oyna!`;
			} else if (finalComputerScore > finalPlayerScore) {
				resultTitle = 'Kaybettin'; resultIcon = '😔'; cardClass = 'from-red-500 to-rose-600';
				shareText = `Kelime Avı'nda yapay zekaya karşı oynadım. Skor: ${finalPlayerScore} - ${finalComputerScore}.`;
			} else {
				resultTitle = 'Berabere!'; resultIcon = '🤝'; cardClass = 'from-sky-500 to-indigo-500';
				shareText = `Kelime Avı'nda yapay zeka ile ${finalPlayerScore} - ${finalComputerScore} berabere kaldım!`;
			}
			setModalContent({
				isOpen: true,
				title: '',
				onClose: goToHome,
				body: (
					 <div className={`relative w-full max-w-sm text-white bg-gradient-to-br ${cardClass} rounded-2xl shadow-2xl p-6 text-center`}>
						<div className="text-6xl mb-4 animate-bounce">{resultIcon}</div>
						<h2 className="text-4xl font-black tracking-tighter mb-2">{resultTitle}</h2>
						<div className="bg-black/20 rounded-lg py-2 px-4 inline-block mb-4">
							<p className="text-3xl font-bold tabular-nums tracking-wide">{finalPlayerScore} - {finalComputerScore}</p>
							<p className="text-xs text-white/70 uppercase tracking-wider">Sen - Yapay Zeka</p>
						</div>
						<button onClick={goToHome} className="w-full mt-4 bg-white/90 hover:bg-white text-gray-800 font-bold py-3 px-8 rounded-lg shadow-lg">Ana Sayfaya Dön</button>
						<ShareButtons text={shareText} setToastMessage={setToastMessage} />
					</div>
				)
			});
		}
	}, [foundWords, computerState.foundWords, score, isVsComputer, isLoading, gameState]);

    React.useEffect(() => {
        if (isRealtimeDuel || !gameState || !Array.isArray(gameState.words)) return;
        const areAllFound = gameState.words.length > 0 && foundWords.length === gameState.words.length;
        if(areAllFound){
            setAllRequiredWordsFound(true);
        }
    }, [foundWords, gameState, isRealtimeDuel]);

    React.useEffect(() => {
		if (isRealtimeDuel || config?.isOneShot || config.name === 'vs-computer') return;
		if (gameState && !isLoading) {
		   const gameStateToSave = { level, score, foundWords, timeLeft, gameState, mode: config.name, language: language, difficulty: config.difficulty, boardSize: config.boardSize };
				try {
					const currentSaves = JSON.parse(localStorage.getItem(ALL_SAVES_KEY)) || {};
					currentSaves[config.name] = gameStateToSave;
					currentSaves.lastPlayed = config.name;
					localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
				} catch (e) { console.error("Oyun kaydedilirken hata:", e); }
			}
    }, [gameState, isLoading, level, config, language, score, foundWords, timeLeft, isRealtimeDuel]);
    
	React.useEffect(() => {
		if (allRequiredWordsFound && gameState && gameState.hiddenWord && !isRealtimeDuel) {
			const wordLength = gameState.hiddenWord.length;
			const letters = _.shuffle(gameState.hiddenWord.split('')).map((char, index) => ({ id: `letter-${index}-${char}`, char: char }));
			setAnswerSlots(Array(wordLength).fill(null));
			setSourceLetters(letters);
			setHintLockedSlots([]);
			if (wordLength >= 8) {
				const firstChar = gameState.hiddenWord[0];
				const hintLetterIndex = letters.findIndex(l => l.char === firstChar);
				if (hintLetterIndex > -1) {
					const hintLetter = letters.splice(hintLetterIndex, 1)[0];
					const finalAnswerSlots = Array(wordLength).fill(null);
					finalAnswerSlots[0] = hintLetter;
					setAnswerSlots(finalAnswerSlots);
					setHintLockedSlots([0]);
					setSourceLetters(_.shuffle(letters));
				}
			}
		}
	}, [allRequiredWordsFound, gameState, isRealtimeDuel]);

    React.useEffect(() => {
        if (!config.name?.startsWith('timed') || !gameState || modalContent.isOpen || isRealtimeDuel) return;
        if (allRequiredWordsFound) {
            if (hiddenWordTimeLeft === 0) {
                vibrate('error');
                setModalContent({ isOpen: true, title: "Süre Bitti!", onClose: goToHome, body: ( <div className="flex flex-col items-center gap-4"> <p className="text-lg text-gray-700 text-center">Tüh! Süre bitti.<br/>Bulman gereken gizli kelime <b className="text-red-600">{gameState.hiddenWord}</b> idi.</p> <button onClick={goToHome} className="bg-blue-600 text-white px-6 py-2 rounded-lg font-medium">{t.homeButton}</button> </div> ) });
                return;
            }
            const timerId = setInterval(() => setHiddenWordTimeLeft(t => t > 0 ? t - 1 : 0), 1000);
            return () => clearInterval(timerId);
        } else {
            if (timeLeft === 0) {
                vibrate('error');
                try {
                    const currentSaves = JSON.parse(localStorage.getItem(ALL_SAVES_KEY)) || {};
                    const savedGame = currentSaves[config.name];
                    if (savedGame) {
                        savedGame.foundWords = [];
                        savedGame.timeLeft = getInitialTime(config.name, savedGame.level);
                        currentSaves[config.name] = savedGame;
                        localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
                    }
                } catch (e) { console.error("Süre bittiğinde oyun kaydı güncellenirken hata:", e); }
                setModalContent({ isOpen: true, title: t.timeUp, onClose: goToHome, body: ( <div> <p className="text-xl mb-4">{t.finalScore(score)}</p> <button onClick={goToHome} className="bg-blue-600 text-white px-5 py-2 rounded-lg font-medium">{t.homeButton}</button> </div> ) });
                return;
            }
		    const timerId = setInterval(() => setTimeLeft(t => t > 0 ? t - 1 : 0), 1000);
		    return () => clearInterval(timerId);
        }
    }, [timeLeft, hiddenWordTimeLeft, config, gameState, modalContent.isOpen, allRequiredWordsFound, isRealtimeDuel]);

    React.useEffect(() => {
        if (allRequiredWordsFound && config.name?.startsWith('timed') && hiddenWordTimeLeft === null && !isRealtimeDuel && !isVsComputer) {
            const wordLength = gameState?.hiddenWord?.length || 5;
            const duration = 15 + (wordLength * 5);
            setHiddenWordTimeLeft(duration);
        }
    }, [allRequiredWordsFound, config, hiddenWordTimeLeft, gameState, isRealtimeDuel, isVsComputer]);

    React.useEffect(() => {
        if (isRealtimeDuel && realtimeGameData?.status === 'finished' && realtimeGameData.players) {
            const finalSortedPlayers = Object.entries(realtimeGameData.players).sort(([, a], [, b]) => b.score - a.score);
            const winnerUsername = finalSortedPlayers.length > 0 ? finalSortedPlayers[0][0] : null;
            const isWinner = winnerUsername === username;
            if (isWinner) { triggerConfetti(); }
            let shareText = `Kelime Avı'nda çok oyunculu bir maçı tamamladım! Sonuçlar: `;
            finalSortedPlayers.forEach(([pName, pData]) => { shareText += `${pName}: ${pData.score}, `; });
            setModalContent({
                isOpen: true,
                title: '',
                onClose: goToHome,
                body: (
                     <div className={`relative w-full max-w-sm text-white bg-gradient-to-br ${isWinner ? 'from-green-500 to-teal-600' : 'from-slate-700 to-gray-800'} rounded-2xl shadow-2xl p-6 text-center`}>
                        <div className="text-6xl mb-4 animate-bounce">{isWinner ? '🏆' : '🏁'}</div>
                        <h2 className="text-4xl font-black tracking-tighter mb-2">{isWinner ? "Kazandın!" : "Oyun Bitti!"}</h2>
                        <p className="text-white/80 mb-4">İşte sonuçlar:</p>
                        <div className="space-y-2 text-left bg-black/20 p-3 rounded-lg w-full">
                            {finalSortedPlayers.map(([pName, pData], index) => (
                                <div key={pName} className={`flex justify-between items-center text-lg p-2 rounded ${pName === username ? 'bg-yellow-500/30' : ''}`}>
                                    <span className="font-semibold flex items-center gap-2">
                                       <span className="w-6 text-center">{index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`}</span>
                                       {pName}
                                    </span>
                                    <span className="font-bold">{pData.score}</span>
                                </div>
                            ))}
                        </div>
                        <button onClick={goToHome} className="w-full mt-6 bg-white/90 hover:bg-white text-gray-800 font-bold py-3 px-8 rounded-lg shadow-lg">Ana Sayfaya Dön</button>
                        <ShareButtons text={shareText} setToastMessage={setToastMessage} />
                    </div>
                )
            });
        }
    }, [realtimeGameData, username]);

	if (isLoading || isGenerating) {
		const loadingText = (isVsComputer || isRealtimeDuel) ? "Oyun Kuruluyor..." : t.loadingLevel(level + 1);
		return <div className="flex items-center justify-center h-full text-lg font-semibold text-indigo-700">{loadingText}</div>;
	}

    if (error) { return (<div className="flex flex-col items-center justify-center h-full p-4 text-center"><p className="text-lg font-semibold text-red-600">{error}</p><button onClick={goToHome} className="mt-4 bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600">Ana Sayfaya Dön</button></div>); }
    
    if (!gameState || !board || !board[0] || !Array.isArray(gameState.words) || !gameState.hiddenWord) {
        return ( <div className="flex flex-col items-center justify-center h-full p-4 text-center"> <p className="text-lg font-semibold text-orange-600">Oyun verileri beklenmedik bir şekilde eksik. Lütfen oyunu yeniden başlatın.</p> <button onClick={() => { localStorage.removeItem('wordHuntAllSaves'); window.location.reload(); }} className="mt-4 bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600"> Hafızayı Temizle ve Yeniden Başlat </button> </div> );
    }
     
	if (isRealtimeDuel) {
		const sortedPlayers = realtimeGameData && realtimeGameData.players ? Object.entries(realtimeGameData.players).sort(([, a], [, b]) => b.score - a.score) : [];
		return (
			<div className="h-full w-full flex flex-col items-center py-2 sm:py-4 bg-indigo-50">
				<div className="container w-full h-full flex flex-col gap-1 text-center text-gray-800 p-1">
					<div className="flex-shrink-0 w-full grid grid-cols-4 gap-1 mb-1">
						{sortedPlayers.map(([playerName, playerData]) => {
							const playerCard = playerCardColors.find(c => c.id === playerData.cardColor);
							const cardBgClass = playerCard ? playerCard.class : 'bg-gradient-to-br from-slate-500 to-gray-600';
							return (
								<div key={playerName} className={`p-1.5 rounded-lg text-white shadow-md text-center ${cardBgClass} ${username === playerName ? 'ring-2 ring-yellow-400 ring-offset-2 ring-offset-indigo-50' : ''}`}>
									<p className="font-bold text-xs truncate" title={playerName}>{playerName}</p>
									<p className="font-extrabold text-base">{playerData.score}</p>
								</div>
							);
						})}
					</div>
					<div ref={gridRef} className="flex-shrink-0 grid gap-0.5 p-1 rounded-lg bg-indigo-100 w-full max-w-2xl mx-auto aspect-square shadow-inner"
						style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }}
						onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)}
						onMouseMove={(e) => throttledMouseMove(e.clientX, e.clientY)}
						onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd}
						onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)}
						onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd} >
						
						{board.map((row, r) => row.map((letter, c) => {
							const isSelected = selectedCells.some(cell => cell.row === r && cell.col === c);
							const owner = cellOwnerMap[`${r}-${c}`];
							let cellClass = 'bg-white text-gray-800 hover:bg-gray-200';
							if (isSelected) {
								cellClass = 'bg-yellow-300 text-black transform scale-110 shadow-lg';
							} else if (owner && realtimeGameData.players[owner]) {
								const sortedPlayersForColor = Object.keys(realtimeGameData.players).sort();
								const playerIndex = sortedPlayersForColor.indexOf(owner);
								const colorInfo = wordFoundColors[playerIndex % wordFoundColors.length];
								cellClass = `${colorInfo.bg} ${colorInfo.text}`;
							}
							return (<div key={`${r}-${c}`} className={`flex items-center justify-center aspect-square text-center font-bold rounded-sm transition-all duration-150 select-none ${cellClass}`}>{letter}</div>);
						}))}
					</div>
					<div className="flex-1 min-h-0 w-full max-w-2xl mx-auto mt-1 flex flex-col bg-white rounded-lg shadow">
						<div className="flex-1 overflow-y-auto scrollbar-thin p-2">
							<div className="flex flex-wrap justify-center content-start gap-x-1.5 gap-y-1">
								{(() => {
									const allFoundWordsCombined = new Set(Object.values(realtimeGameData.players).flatMap(p => p.foundWords));
									const allWordsInLevel = realtimeGameData.boardData ? realtimeGameData.boardData.words : [];
									return allWordsInLevel.map(({ word }) => {
										const isFound = allFoundWordsCombined.has(word);
										const isHidden = realtimeGameData.gameSettings.difficulty === 'hard' && !isFound;
										return (
											<span key={word} className={`font-medium transition-all duration-300 rounded-md px-2 py-1 text-xs ${ isFound ? 'bg-gray-300 text-gray-500 line-through opacity-60' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : 'bg-indigo-100 text-gray-800' }`}>
												{isHidden ? '???' : word}
											</span>
										);
									});
								})()}
							</div>
						</div>
					</div>
					<div className="flex-shrink-0 w-full">
						<button onClick={showExitConfirmation} className="w-full py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition-all text-sm">Oyundan Çık (Terk Et)</button>
					</div>
					<Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.body}</Modal>
				</div>
			</div>
		);
	}

    if (isVsComputer) {
        const allWordsInLevel = gameState.words; const allFoundWordsCombined = new Set([...foundWords, ...computerState.foundWords]);
        const calculateFontSize = (numCols) => { if (!numCols) return { fontSize: '18px' }; const maxGridWidth = 768; const targetRatio = 0.8; const minFontSize = 10; const preferredVw = (100 / numCols) * targetRatio; const maxFontSize = (maxGridWidth / numCols) * targetRatio; return { fontSize: `clamp(${minFontSize}px, ${preferredVw.toFixed(2)}vw, ${maxFontSize.toFixed(2)}px)` }; };
        const fontSizeStyle = calculateFontSize(board?.[0]?.length);
        return ( <div className="h-full w-full flex flex-col items-center py-2 sm:py-4 bg-indigo-50"> <div className="container w-full h-full flex flex-col gap-2 text-center text-gray-800 p-1"> <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.body}</Modal> <div className="flex-shrink-0 w-full max-w-2xl mx-auto"> <div className="flex justify-between items-center bg-white p-1.5 rounded-lg shadow-sm"> <div className="flex items-center gap-2 w-2/5 justify-start"><span className="font-semibold text-sm truncate text-indigo-700">Siz</span><span className="text-lg font-bold text-green-600">{score}</span></div> <span className="text-sm font-bold text-gray-400">VS</span> <div className="flex items-center gap-2 w-2/5 justify-end"><span className="font-semibold text-sm truncate text-gray-600">Bilgisayar ({config.difficulty})</span><span className="text-lg font-bold text-red-600">{computerState.score}</span></div> </div> </div> <div className="flex-shrink-0 w-full max-w-2xl mx-auto"> <div ref={gridRef} className="grid gap-0.5 p-1 rounded-lg bg-indigo-100 w-full aspect-square shadow-inner" style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }} 
            onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)} 
            onMouseMove={(e) => throttledMouseMove(e.clientX, e.clientY)}
            onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd} 
            onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)} 
            onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd} >
            {board.map((row, r) => row.map((letter, c) => { const isSelected = selectedCells.some(cell => cell.row === r && cell.col === c); const foundBy = isCellFound(r, c); let cellClass = 'bg-white text-gray-800 hover:bg-gray-200'; if (isSelected) { cellClass = 'bg-yellow-300 text-black transform scale-110 shadow-lg'; } else if (foundBy === 'player') { cellClass = 'bg-green-300 text-green-800'; } else if (foundBy === 'computer') { cellClass = 'bg-red-300 text-red-800'; } return ( <div key={`${r}-${c}`} className={`flex items-center justify-center aspect-square text-center font-bold rounded-sm transition-all duration-150 select-none ${cellClass}`} style={fontSizeStyle}> {letter} </div> ); }))} </div> </div> <div className="flex-1 min-h-0 w-full max-w-2xl mx-auto"> <div className="bg-white rounded-lg p-1 shadow h-full overflow-y-auto scrollbar-thin"> <div className="flex flex-wrap justify-center content-start gap-x-1.5 gap-y-1 p-1"> {allWordsInLevel.map(({ word }) => { const isFound = allFoundWordsCombined.has(word); const isHidden = config.difficulty === 'hard' && !isFound; return (<span key={word} className={`font-medium transition-all duration-300 rounded-md px-2 py-1 text-xs ${ isFound ? 'bg-gray-300 text-gray-500 line-through opacity-50' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : 'bg-indigo-100 text-gray-800' }`}>{isHidden ? '???' : word}</span>); })} </div> </div> </div> <div className="flex-shrink-0 w-full max-w-2xl mx-auto"> <button onClick={showExitConfirmation} className="w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition-all text-sm">Ana Menüye Dön</button> </div> </div> </div> );
    }

    const calculateFontSize = (numCols) => {
        if (!numCols) return { fontSize: '18px' };
        const maxGridWidth = 768; const targetRatio = 0.8; const minFontSize = 10;
        const preferredVw = (100 / numCols) * targetRatio;
        const maxFontSize = (maxGridWidth / numCols) * targetRatio;
        return { fontSize: `clamp(${minFontSize}px, ${preferredVw.toFixed(2)}vw, ${maxFontSize.toFixed(2)}px)`, fontWeight: '900' };
    };

    const fontSizeStyle = calculateFontSize(board?.[0]?.length);
    
    return (
        <div className="relative h-screen w-full">
            <div className={`h-screen w-full flex flex-col p-2 gap-2 text-center overflow-hidden ${theme.bg}`}>
                <div className="w-full flex-shrink-0 grid grid-cols-3 gap-2">
                    <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm" title={t.score}><span className="text-xl">⭐</span><span className="font-bold text-sm text-green-600">{score}</span></div>
                    <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm" title={t.gold}><span className="text-xl">💰</span><span className="font-bold text-sm text-amber-600">{stats.gold || 0}</span></div>
                    <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm">
                        {(config.name?.startsWith('timed') && !allRequiredWordsFound) ? ( <div key={timeLeft} className="animate-timer-pulse flex items-center justify-center gap-1 text-blue-600 tabular-nums" title="Kalan Süre"> <span className="text-xl">⏱️</span> <span className="font-bold text-sm">{Math.floor(timeLeft / 60)}:{(timeLeft % 60).toString().padStart(2, '0')}</span> </div> ) : ( <div className="flex items-center justify-center gap-1 text-slate-400" title="Bu modda süre yoktur"> <span className="text-xl">⏱️</span> <span className="font-bold text-sm">-:--</span> </div> )}
                    </div>
                </div>
               {!allRequiredWordsFound && (
                    <div className="flex-1 min-h-0 p-2 bg-gray-100 rounded-lg overflow-y-auto scrollbar-thin flex">
                        <div className="flex flex-wrap justify-center items-center gap-x-2 gap-y-1 m-auto">
                            {gameState.words.map(({ word }) => {
                                const isFound = foundWords.includes(word);
                                const isHidden = (config.name === 'hard' || config.name === 'timed-hard') && !isFound;
                                const sizeClasses = config.name === 'super-easy' ? 'px-4 py-2 text-lg' : 'px-1 py-1 text-base';
                                return ( <span key={word} className={`transition-all duration-500 rounded-lg ${sizeClasses} ${isFound ? 'bg-gray-300 text-gray-500 line-through opacity-50' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : theme.wordBg + ' text-gray-800'}`}> {isHidden ? '?????' : word} </span> );
                            })}
                        </div>
                    </div>
                )}
                <div className="w-full flex-shrink-0">
                    {!allRequiredWordsFound ? (
                        <div ref={gridRef} className={`grid gap-0.5 content-start rounded-lg shadow-md w-full max-w-full mx-auto aspect-square ${theme.gridBg}`} 
                            style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }} 
                            onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)} 
                            onMouseMove={(e) => throttledMouseMove(e.clientX, e.clientY)} 
                            onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd} 
                            onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)} 
                            onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd} >
                        {(() => {
                            const numCols = board[0] ? board[0].length : 1;
							return board.map((row, rowIndex) => row.map((letter, colIndex) => { 
								const isSelected = selectedCells.some(cell => cell.row === rowIndex && cell.col === colIndex);
								const isFoundPart = isCellFound(rowIndex, colIndex); 
								const isJustFound = justFoundWordInfo?.positions.some(p => p.row === rowIndex && p.col === colIndex); 
								const isBonusGlowCell = bonusGlowCells.some(cell => cell.row === rowIndex && cell.col === colIndex); 
								const colorInfo = foundCellColorMap[`${rowIndex}-${colIndex}`];
								return <Cell key={`${rowIndex}-${colIndex}`} letter={letter} isSelected={isSelected} isFoundRequiredPart={!!isFoundPart} isJustFound={isJustFound} isBonusGlow={isBonusGlowCell} theme={theme} numCols={numCols} foundWordColorInfo={colorInfo} />;
							}));
                        })()}
                        </div>
                    ) : (
                        <div className="w-full h-full flex items-center justify-center overflow-y-auto overflow-x-hidden scrollbar-thin bg-white rounded-lg">
                            <div className="w-full max-w-2xl mx-auto p-2">
                                <p className="font-bold text-lg text-indigo-700">{t.hiddenWord}</p>
                                {hiddenWordTimeLeft !== null && <div key={hiddenWordTimeLeft} className="animate-timer-pulse text-xl font-bold text-red-600 my-2">Kalan Süre: {hiddenWordTimeLeft}s</div>}
                                <div id="answer-area-container" className={`my-2 p-1 bg-gray-200 rounded-lg w-full flex flex-wrap justify-center gap-2 ${isShaking ? 'shake-animation' : ''}`}>{answerSlots.map((letter, index) => ( <div key={index} onClick={() => handleAnswerSlotClick(letter, index)} className={`w-12 h-12 aspect-square flex items-center justify-center rounded-md text-4xl leading-none font-bold transition-all ${hintLockedSlots.includes(index) ? 'bg-amber-300 cursor-not-allowed' : 'bg-white shadow-inner cursor-pointer hover:bg-red-100'} text-gray-800`}>{letter ? letter.char : ''}</div> ))}</div>
                                <p className="text-sm text-gray-600 mt-4 mb-2">Kalan Harfler</p>
                                <div className="p-2 bg-gray-200 rounded-lg w-full flex flex-wrap justify-center gap-2 min-h-[64px]">{sourceLetters.map(letter => ( <button key={letter.id} onClick={() => handleSourceLetterClick(letter)} className="w-12 h-12 flex items-center justify-center rounded-md bg-sky-500 text-white text-2xl font-bold shadow-md hover:bg-sky-600 active:scale-90 transition-all">{letter.char}</button> ))}</div>
                                <button onClick={handleCheckHiddenWord} disabled={answerSlots.some(l => l === null)} className="mt-4 w-full bg-green-500 text-white rounded-lg py-3 font-bold hover:bg-green-600 transition-transform active:scale-95 disabled:bg-gray-400 disabled:cursor-not-allowed">{t.checkButton}</button>
                            </div>
                        </div>
                    )}
                </div>
				<div className="w-full flex-shrink-0 mb-1" style={{ fontFamily: "'Nunito', sans-serif" }}>
					<div className={`bg-gradient-to-r ${infoBarClass} border border-slate-200 rounded-xl p-1 text-center shadow-sm flex items-center justify-center divide-x-2 divide-slate-300/50`}>
						<div className="px-3 flex items-center gap-1.5">
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4 opacity-70"> <path d="M15.5 2A1.5 1.5 0 0014 3.5v13a1.5 1.5 0 001.5 1.5h1a1.5 1.5 0 001.5-1.5v-13A1.5 1.5 0 0016.5 2h-1zM9.5 6A1.5 1.5 0 008 7.5v9a1.5 1.5 0 001.5 1.5h1a1.5 1.5 0 001.5-1.5v-9A1.5 1.5 0 0010.5 6h-1zM3.5 10A1.5 1.5 0 002 11.5v5a1.5 1.5 0 001.5 1.5h1a1.5 1.5 0 001.5-1.5v-5A1.5 1.5 0 004.5 10h-1z" /> </svg>
							<p className="font-semibold text-xs sm:text-sm"> Mod: <span className="font-extrabold">{getModeDisplayName(config.name, t)}</span> </p>
						</div>
						<div className="px-3 flex items-center gap-1.5">
							 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4 opacity-70"> <path fillRule="evenodd" d="M10.868 2.884c.321-.772 1.305-.772 1.626 0l1.83 4.425a1 1 0 00.95.69h4.642c.81 0 1.133 1.04.546 1.593l-3.75 2.725a1 1 0 00-.364 1.118l1.42 4.134c.245.714-.638 1.342-1.285.933l-3.89-2.82a1 1 0 00-1.176 0l-3.89 2.82c-.647.409-1.53-.219-1.285-.933l1.42-4.134a1 1 0 00-.364-1.118L2.054 9.592c-.587-.553-.264-1.593.546-1.593h4.642a1 1 0 00.95-.69l1.83-4.425z" clipRule="evenodd" /> </svg>
							<p className="font-semibold text-xs sm:text-sm"> Seviye: <span className="font-extrabold">{level + 1}</span> </p>
						</div>
					</div>
				</div>
				<div className="w-full flex-shrink-0 grid grid-cols-2 gap-2">
					<button onClick={handleGoHomeClick} title={t.homeButton} className="w-full rounded-xl p-1 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-white/80 hover:bg-white border border-slate-200 text-slate-700"><span className="text-base">🏠</span><span>Anasayfa</span></button>
					{allRequiredWordsFound ? ( <button onClick={handleHiddenWordHint} disabled={stats.gold < 1} className="w-full rounded-xl p-1 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-sky-500 hover:bg-sky-600 text-white disabled:bg-slate-400 disabled:text-white/80 disabled:cursor-not-allowed"> <span className="text-base">🔑</span> <span>İpucu</span> <span className="opacity-80 font-normal">(-1💰)</span> </button> ) : ( <button onClick={handleRevealWordHint} disabled={stats.gold < 1 || (gameState && foundWords.length === gameState.words.length)} className="w-full rounded-xl p-1 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-amber-500 hover:bg-amber-600 text-white disabled:bg-slate-400 disabled:text-white/80 disabled:cursor-not-allowed"> <span className="text-base">🔎</span> <span>Aç</span> <span className="opacity-80 font-normal">(-1💰)</span> </button> )}
				</div>
                <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.body}</Modal>
            </div>
        </div>
    );
}






function DuelModeModal({ isOpen, onClose, duelProgress, startGame, currentUser, goToHome }) {
        if (!isOpen || !duelProgress) return null;
        const t = translations['tr'] || translations['en'];
        const [activeTab, setActiveTab] = React.useState('super-easy');
        const [scores, setScores] = React.useState({});
        const [loading, setLoading] = React.useState(true);

        const duelModes = [
            { key: 'super-easy', title: t.superEasyMode, icon: '🧸', color: 'from-sky-500 to-cyan-400' },
            { key: 'easy', title: t.easyMode, icon: '😊', color: 'from-blue-500 to-indigo-500' },
            { key: 'hard', title: t.hardMode, icon: '🔥', color: 'from-purple-600 to-violet-600' },
            { key: 'timed-easy', title: t.timedEasyMode, icon: '⏱️', color: 'from-emerald-500 to-teal-500' },
            { key: 'timed-hard', title: t.timedHardMode, icon: '⚡', color: 'from-slate-700 to-gray-800' }
        ];

        const leaderboardTabs = [
            { key: 'super-easy', line1Key: 'çok', line2Key: 'kolay', activeBg: 'bg-green-500' },
            { key: 'easy', line1Key: 'kolay', line2Key: 'normal', activeBg: 'bg-teal-500' },
            { key: 'hard', line1Key: 'zor', line2Key: 'normal', activeBg: 'bg-red-500' },
            { key: 'timed-easy', line1Key: 'süreli', line2Key: 'kolay', activeBg: 'bg-blue-500' },
            { key: 'timed-hard', line1Key: 'süreli', line2Key: 'zor', activeBg: 'bg-orange-500' }
        ];

        React.useEffect(() => {
            if (isOpen) {
                setLoading(true);
                const fetchPromises = leaderboardTabs.map(tab =>
                    db.collection("duel-scores")
                        .where("mode", "==", tab.key)
                        .orderBy("score", "desc")
                        .limit(50)
                        .get()
                );
                Promise.all(fetchPromises)
                    .then(snapshots => {
                        const newScores = {};
                        snapshots.forEach((snapshot, index) => {
                            const mode = leaderboardTabs[index].key;
                            newScores[mode] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        });
                        setScores(newScores);
                    })
                    .catch(error => console.error("Düello liderlik tablosu verileri çekilirken hata oluştu:", error))
                    .finally(() => setLoading(false));
            }
        }, [isOpen]);

        return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-2 sm:p-4" onClick={onClose}>
                <div className="bg-white dark:bg-gray-900 p-4 sm:p-6 rounded-2xl shadow-2xl max-w-4xl w-full text-center relative max-h-[95vh] overflow-y-auto scrollbar-thin" onClick={e => e.stopPropagation()}>
                    <h3 className="text-3xl sm:text-4xl font-black mb-6 text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-indigo-600">🏆 DÜELLO MEYDANI 🏆</h3>
                    <button onClick={onClose} className="absolute top-3 right-3 text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 text-4xl">&times;</button>
                    <div className="grid grid-cols-2 gap-3 sm:gap-4 mb-8">
                        {duelModes.map(modeInfo => {
                            const progress = duelProgress[modeInfo.key] || { currentLevel: 0, cumulativeScore: 0 };
                            return (
                                <div key={modeInfo.key} className={`flex flex-col text-white rounded-2xl shadow-lg bg-gradient-to-br ${modeInfo.color} transform hover:-translate-y-1 transition-transform`}>
                                     <div className="flex justify-between items-start p-3 rounded-t-lg bg-black/20">
                                        <h4 className="text-lg sm:text-xl font-bold">{modeInfo.title}</h4>
                                        <span className="text-3xl sm:text-4xl opacity-80">{modeInfo.icon}</span>
                                    </div>
                                    <div className="bg-black/10 p-3 text-xs sm:text-sm space-y-1 text-left">
                                        <p>Mevcut Seviye: <span className="font-bold sm:text-base">{progress.currentLevel + 1}</span></p>
                                        <p>Toplam Puan: <span className="font-bold sm:text-base">{progress.cumulativeScore}</span></p>
                                    </div>
                                    <button onClick={() => startGame(modeInfo.key)} className="w-full bg-white/30 hover:bg-white/40 backdrop-blur-sm font-bold py-2 sm:py-3 rounded-b-lg transition-all text-base sm:text-lg">
                                        {progress.currentLevel > 0 ? 'DEVAM ET' : 'BAŞLA'}
                                    </button>
                                 </div>
                            );
                        })}
                    </div>
                    <hr className="my-6 border-gray-300 dark:border-gray-700"/>
                    <div>
                         <div className="flex justify-between items-center mb-4 px-1">
                            <h4 className="text-2xl font-bold text-gray-800 dark:text-gray-100 uppercase">DÜELLO LİDERLERİ</h4>
                            <button onClick={onClose} className="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all text-sm flex items-center gap-2">
        🏠 <span>Anasayfa</span>
    </button>
                        </div>
                        <div className="flex items-center border-b-2 border-gray-200 dark:border-gray-700">
                             {leaderboardTabs.map(tab => {
                                 const isActive = activeTab === tab.key;
                                 return (
                                     <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`flex-1 flex flex-col justify-center items-center h-14 py-1 text-center transition-all duration-300 border-x border-transparent ${isActive ? `${tab.activeBg} scale-105 z-10 rounded-t-lg` : 'hover:bg-gray-100 dark:hover:bg-gray-800'}`}>
                                         <span className={`block text-xs font-bold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}>
                                             {t[tab.line1Key]}
                                         </span>
                                         <span className={`block text-xs font-semibold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}>
                                             {t[tab.line2Key]}
                                         </span>
                                     </button>
                                 );
                             })}
                         </div>
                        <div className="min-h-[250px]">
                        {loading
                            ? <p className="text-gray-600 dark:text-gray-400 pt-10">Liderlik tablosu yükleniyor...</p>
                            : <DuelLeaderboardDisplay scores={scores[activeTab]} currentUser={currentUser} />
                        }
                    </div>
                </div>
            </div>
        </div>
    );
    }
        



function UsernamePrompt({ onSave }) { const [name, setName] = React.useState(''); const [isLoading, setIsLoading] = React.useState(false); const [error, setError] = React.useState(''); const handleSave = async () => { if (!name.trim()) return; setIsLoading(true); setError(''); const success = await onSave(name.trim()); if (!success) { setError('Bu kullanıcı adı zaten alınmış. Lütfen başka bir tane deneyin.'); setIsLoading(false); } }; return ( <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4"> <div className="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm text-center"> <h3 className="text-2xl font-bold mb-4 text-gray-800">Oyuna Hoş Geldin!</h3> <p className="text-gray-600 mb-5">Liderlik tablosu için benzersiz bir kullanıcı adı belirle.</p> <input type="text" value={name} onChange={(e) => setName(e.target.value)} className="w-full border-2 border-gray-300 p-2 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-indigo-400" placeholder="Kullanıcı adınız..." maxLength={15} disabled={isLoading} /> {error && <p className="text-red-500 text-sm mt-2">{error}</p>} <button onClick={handleSave} disabled={!name.trim() || isLoading} className="w-full mt-4 bg-indigo-600 text-white font-bold px-6 py-3 rounded-lg hover:bg-indigo-700 transition-all shadow-lg disabled:bg-gray-400 disabled:cursor-not-allowed" > {isLoading ? 'Kontrol ediliyor...' : 'Kaydet ve Başla'} </button> </div> </div> ); }

        
function DuelLeaderboardDisplay({ scores, currentUser }) {
            if (!scores || scores.length === 0) {
                return <p className="text-gray-600 dark:text-gray-400 pt-10">Bu düello kategorisinde henüz skor bulunmuyor.</p>;
            }
            const rankIcons = ['🥇', '🥈', '🥉'];
            return (
                <div className="text-left overflow-y-auto max-h-[250px] mt-4 pr-2 scrollbar-thin">
                    <ul className="space-y-2">
                        {scores.map((score, index) => {
                            const isCurrentUser = score.username === currentUser;
                            return (
                                <li key={score.id || index} className={`flex items-center p-3 rounded-lg transition-all ${isCurrentUser ? 'bg-purple-100 dark:bg-purple-800/20 border-2 border-purple-400' : 'bg-gray-50 dark:bg-gray-800'}`}>
                                    <span className="font-bold text-lg w-10 text-center text-gray-500 dark:text-gray-400">{rankIcons[index] || index + 1}</span>
                                    <div className="flex-1">
                                        <p className={`font-semibold text-gray-800 dark:text-gray-200 ${isCurrentUser ? 'text-purple-900 dark:text-purple-300' : ''}`}>{score.username}</p>
                                        <p className={`text-xs text-gray-500 dark:text-gray-400 ${isCurrentUser ? 'text-purple-800 dark:text-purple-400' : ''}`}>Seviye {score.level}</p>
                                    </div>
                                    <span className={`font-bold text-xl text-indigo-600 dark:text-indigo-400 tabular-nums ${isCurrentUser ? 'text-purple-900 dark:text-purple-300' : ''}`}>{score.score}</span>
                                </li>
                            );
                        })}
                    </ul>
                </div>
            );
        }

    window.androidBridge = {
        onBackPress: () => {
            if (typeof window.androidBridge.registered_onBackPress === 'function') {
                window.androidBridge.registered_onBackPress();
            }
        },
        registered_onBackPress: null,
        receiveFCMToken: (token) => {
            pendingFCMToken = token;
            const currentUser = localStorage.getItem('wordHuntUsername');
            if (currentUser) {
                saveTokenForUser(currentUser, token);
            } else {
            }
        },
        };

    let pendingFCMToken = null;

    const saveTokenForUser = async (username, token, maxRetries = 3, toastCallback = null) => {
        if (!username || !token) return;

        const userRef = db.collection("users").doc(username);

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                await userRef.set({ fcmToken: token }, { merge: true });
                pendingFCMToken = null;
                return;
            } catch (error) {
                console.error(`WebAppLog: FCM token kaydetme denemesi ${attempt} başarısız oldu. Hata:`, error);
                if (attempt === maxRetries) {
                    const errorMessage = "Bildirim ayarları yapılamadı. İnternetinizi kontrol edin.";
                    console.error(`WebAppLog: Tüm denemelere rağmen FCM token kaydedilemedi. Kullanıcıya gösterilen hata: ${errorMessage}`);
                    if (toastCallback) {
                        toastCallback(errorMessage);
                    }
                } else {
                    const delay = Math.pow(2, attempt) * 1000;
                    await new Promise(res => setTimeout(res, delay));
                }
            }
        }
    };


    function App() {
        const [page, setPage] = React.useState('home');
        const [language, setLanguage] = React.useState('tr');
        const [modeConfig, setModeConfig] = React.useState({ name: 'easy' });
        const [gameStats, setGameStats] = React.useState(loadGameStats);
        const [modalContent, setModalContent] = React.useState({ isOpen: false, title: '', body: null });
        const [allSaves, setAllSaves] = React.useState(null);
        const [username, setUsername] = React.useState('');
        const [gold, setGold] = React.useState(0);
        const [showUsernamePrompt, setShowUsernamePrompt] = React.useState(false);
        const [isInitializing, setIsInitializing] = React.useState(true);
        const [gameId, setGameId] = React.useState(null);
        const [showAppExitModal, setShowAppExitModal] = React.useState(false);
        const [toastMessage, setToastMessage] = React.useState(null);
        const [incomingInvitation, setIncomingInvitation] = React.useState(null);
        const [isAvatarModalOpen, setIsAvatarModalOpen] = React.useState(false);
        const [avatarId, setAvatarId] = React.useState(null);
        const [isProfileModalOpen, setIsProfileModalOpen] = React.useState(false);
        const [friendRequest, setFriendRequest] = React.useState(null);
        const [cardColor, setCardColor] = React.useState(null);
		const [unlockedAvatars, setUnlockedAvatars] = React.useState(['avatar1']);
        const [unlockedColors, setUnlockedColors] = React.useState(['gray']);
        const [directInvite, setDirectInvite] = React.useState(null);
        const [updateInfo, setUpdateInfo] = React.useState({ required: false, url: '' });
        const [gameKey, setGameKey] = React.useState(null);


        const loadUserData = async (user) => {
        const userRef = db.collection("users").doc(user);
        const doc = await userRef.get();
        if (doc.exists) {
            const userData = doc.data();
            setUsername(user);
            setGold(userData.gold || 0);
            setAvatarId(userData.avatarId || 'avatar1');
            setCardColor(userData.cardColor || 'gray');
            setUnlockedAvatars(userData.unlockedAvatars || ['avatar1']);
            setUnlockedColors(userData.unlockedColors || ['gray']);
        } else {
            localStorage.removeItem('wordHuntUsername');
            setShowUsernamePrompt(true);
        }
    };

		const handlePurchaseItem = async (itemType, itemId, cost) => {
        if (gold < cost) {
            setToastMessage("Yetersiz altın!");
            return;
        }

        const newGold = gold - cost;
        const userRef = db.collection("users").doc(username);

        try {
            if (itemType === 'avatar') {
                await userRef.update({
                    gold: newGold,
                    unlockedAvatars: firebase.firestore.FieldValue.arrayUnion(itemId)
                });
                setUnlockedAvatars(prev => [...prev, itemId]);
            } else if (itemType === 'color') {
                await userRef.update({
                    gold: newGold,
                    unlockedColors: firebase.firestore.FieldValue.arrayUnion(itemId)
                });
                setUnlockedColors(prev => [...prev, itemId]);
            }
            setGold(newGold);
            setToastMessage("Başarıyla satın alındı!");
        } catch (error) {
            console.error("Satın alma hatası:", error);
            setToastMessage("Bir hata oluştu.");
        }
    };


        const handleSaveUsername = async (name) => {
        const userRef = db.collection("users").doc(name);
        const doc = await userRef.get();
        if (doc.exists) {
            return false;
        } else {
            await userRef.set({ gold: 0, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            localStorage.setItem('wordHuntUsername', name);
            setUsername(name);
            setGold(0);
            setShowUsernamePrompt(false);

            if (window.Android && typeof window.Android.saveUsername === 'function') {
                window.Android.saveUsername(name);
            } else if (pendingFCMToken) {
                saveTokenForUser(name, pendingFCMToken, 3, setToastMessage);
            }

            return true;
        }
    };

      const handleStatsChange = React.useCallback((newStats) => {
            saveGameStats(newStats);
            setGameStats(newStats);
            if (username && typeof newStats.gold !== 'undefined' && newStats.gold !== gold) {
                setGold(newStats.gold);
                db.collection("users").doc(username).update({ gold: newStats.gold }).catch(error => console.error("Altın güncellenirken hata:", error));
            }
        }, [username, gold]); 

     const handleAvatarSelect = async (avatarId) => {
        if (!username) return;

        try {
            await db.collection("users").doc(username).update({
                avatarId: avatarId
            });
            setAvatarId(avatarId);
            setToastMessage("Avatarın başarıyla güncellendi!");
            setIsAvatarModalOpen(false);

        } catch (error) {
            console.error("Avatar güncellenirken hata oluştu:", error);
            setToastMessage("Hata: Avatar güncellenemedi.");
        }
    };


const goToHome = React.useCallback(() => {
            if (page === 'lobby' && username) {
                db.collection('lobby').doc(username).delete().catch(() => {});
            } else if (page === 'game' && gameId) {
                // Bu kısım yeni oda sisteminde güncellenebilir, şimdilik böyle kalabilir.
                // Örneğin: Oyuncunun odadan ayrılması sağlanabilir.
            }
            setPage('home');
            setGameId(null);
        }, [username, page, gameId]);

const createGameRoom = async (settings) => {
            if (!username) return;
            setToastMessage("Yeni oyun odası oluşturuluyor...");

            const roomRef = db.collection('game_rooms').doc();

            const newRoom = {
                roomId: roomRef.id,
                status: 'waiting',
                host: username,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                gameSettings: {
                    boardSize: settings.boardSize || 'medium',
                    difficulty: settings.difficulty || 'easy', // Zorluk eklendi
                    maxPlayers: parseInt(settings.maxPlayers) || 3,
                },
                players: {
                    [username]: { score: 0, foundWords: [], avatarId: avatarId || 'avatar1', cardColor: cardColor || 'gray', color: 'green', joinedAt: firebase.firestore.FieldValue.serverTimestamp() }
                }
            };

            try {
                await roomRef.set(newRoom);
                setToastMessage("Oda başarıyla kuruldu!");
                setGameId(roomRef.id);
                setPage('room_lobby');
            } catch (error) {
                console.error("Oda kurulamadı:", error);
                setToastMessage("Hata: Oda oluşturulamadı.");
            }
        };

        const joinGameRoom = async (roomIdToJoin) => {
            if (!username) return;
            const roomRef = db.collection('game_rooms').doc(roomIdToJoin);

            try {
                await db.runTransaction(async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists) throw "Bu oda artık mevcut değil.";

                    const roomData = roomDoc.data();
                    const playerCount = Object.keys(roomData.players).length;

                    if (roomData.status !== 'waiting') throw "Bu oyun çoktan başlamış veya bitmiş.";
                    if (playerCount >= roomData.gameSettings.maxPlayers) throw "Bu oda dolu.";
                    if (roomData.players[username]) {
                        setToastMessage("Zaten bu odadasınız.");
                        setGameId(roomIdToJoin);
                        setPage('room_lobby');
                        return;
                    }
                    
                    const playerColors = ['green', 'red', 'blue', 'purple'];
                    const newPlayerColor = playerColors[playerCount] || 'gray';

                    const newPlayerField = `players.${username}`;
                    transaction.update(roomRef, {
                        [newPlayerField]: {
                            score: 0,
                            foundWords: [],
                            avatarId: avatarId || 'avatar1',
                            cardColor: cardColor || 'gray',
                            color: newPlayerColor,
                            joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                        }
                    });
                });

                setToastMessage("Odaya başarıyla katıldınız!");
                setGameId(roomIdToJoin);
                setPage('room_lobby');

            } catch (error) {
                console.error("Odaya katılırken hata:", error);
                setToastMessage(`Hata: ${error.toString()}`);
            }
        };



// MEVCUT startGame FONKSİYONUNU SİLİP, BUNU YAPIŞTIRIN:
const startGame = async (roomId) => {
    console.log("[startGame] Fonksiyonu başlatıldı. Oda ID:", roomId);
    const roomRef = db.collection('game_rooms').doc(roomId);
    
    try {
        const roomDoc = await roomRef.get();
        if (!roomDoc.exists) {
            console.error("[startGame] Hata: Oda bulunamadı.");
            setToastMessage("Hata: Oyun odası bulunamadı.");
            return;
        }
        const roomData = roomDoc.data();

        if (roomData.host !== username) {
            setToastMessage("Sadece oda kurucusu oyunu başlatabilir!");
            return;
        }

        const boardSize = roomData.gameSettings.boardSize;
        console.log("[startGame] Oyun tahtası oluşturuluyor... Boyut:", boardSize);
        
        const gameConfig = { name: 'multiplayer', boardSize: boardSize, modeType: 'avi' };
        const newBoardData = createBoard(null, language, gameConfig);

        if (!newBoardData) {
            console.error("[startGame] Hata: createBoard fonksiyonu 'null' döndürdü.");
            setToastMessage("Hata: Oyun tahtası oluşturulamadı. Lütfen tekrar deneyin.");
            return;
        }
        console.log("[startGame] Tahta başarıyla oluşturuldu. Veritabanına yazılacak.");

        const boardAsMap = {};
        newBoardData.board.forEach((row, index) => {
            boardAsMap[index] = row;
        });

        console.log("[startGame] Veritabanı güncellemesi başlıyor...");
        await roomRef.update({
            status: 'in-progress',
            boardData: { ...newBoardData, board: boardAsMap }
        });
        console.log("[startGame] Veritabanı başarıyla güncellendi! Oyun başlamalı.");

        // YENİ EKLENEN KISIM:
        // Kurucuyu beklemeden doğrudan oyun ekranına yönlendir.
        setPage('game');

    } catch (error) {
        console.error("[startGame] Veritabanı GÜNCELLEME HATASI:", error);
        setToastMessage("Kritik Hata: Oyun veritabanına yazılamadı. Konsolu kontrol edin.");
    }
};









        
       const sendDirectInvite = (targetPlayer, boardSize, difficulty) => {
            if (!username || !targetPlayer) return;

            setToastMessage(`${targetPlayer.username} kullanıcısına davet gönderiliyor...`);
            
            const gameId = [username, targetPlayer.username].sort().join('_') + `_${Date.now()}`;
            const gameRef = db.collection('game_rooms').doc(gameId);

            const newRoomData = {
                roomId: gameId,
                status: 'invited',
                host: username,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                gameSettings: {
                    boardSize: boardSize || 'medium',
                    difficulty: difficulty || 'easy', // Zorluk eklendi
                    maxPlayers: 2
                },
                players: {
                    [username]: { score: 0, foundWords: [], avatarId: avatarId || 'avatar1', cardColor: cardColor || 'gray', color: 'green' },
                    [targetPlayer.username]: { score: 0, foundWords: [], avatarId: targetPlayer.avatarId || 'avatar1', cardColor: targetPlayer.cardColor || 'gray', color: 'red' }
                }
            };

            gameRef.set(newRoomData).then(() => {
                // Lobi durumunu güncellemeye devam et (uygulama içindekiler için)
                db.collection('lobby').doc(targetPlayer.username).set({
                    status: 'invited', invitedBy: username, gameId: gameId,
                }, { merge: true });

                // YENİ EKLENEN KISIM: Cloud Function'ı tetiklemek için "invites" koleksiyonuna yaz
                db.collection('invites').add({
                    from: username,
                    to: targetPlayer.username,
                    gameId: gameId,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });

                setToastMessage("Davet gönderildi!");
                setGameId(gameId);
                setPage('room_lobby');
            }).catch(error => {
                console.error("Davet gönderilirken hata:", error);
                setToastMessage("Hata: Davet gönderilemedi.");
            });
        };

const handleAcceptDirectInvite = async () => {
            if (!directInvite) return;
            const gameRef = db.collection('game_rooms').doc(directInvite.gameId);
            try {
                // Önce oyunun mevcut ayarlarını (örn: boardSize) al
                const roomDoc = await gameRef.get();
                if (!roomDoc.exists) throw new Error("Oda bulunamadı!");
                
                const roomData = roomDoc.data();
                const boardSize = roomData.gameSettings.boardSize;

                // Oyun tahtasını oluştur
                const newBoardData = createBoard(null, language, null, boardSize);
                if (!newBoardData) throw new Error("Oyun tahtası oluşturulamadı.");

                // Firestore'a uygun hale getirmek için board dizisini objeye çevir
                const boardAsMap = {};
                newBoardData.board.forEach((row, index) => {
                    boardAsMap[index] = row;
                });

                // Hem durumu hem de yeni oluşturulan tahtayı veritabanına yaz
                await gameRef.update({
                    status: 'in-progress',
                    boardData: { ...newBoardData, board: boardAsMap }
                });

                // Davet edilen oyuncuyu lobi durumundan çıkar
                await db.collection('lobby').doc(username).update({ status: 'in-game', gameId: directInvite.gameId });

                setGameId(directInvite.gameId);
                setPage('room_lobby'); // Bu sayfa bizi otomatik olarak 'game' sayfasına yönlendirecek
                setDirectInvite(null);

            } catch (error) {
                console.error("Davet kabul edilirken hata:", error);
                setToastMessage("Hata: Oyuna katılamadınız. " + error.message);
            }
        };

        const handleDeclineDirectInvite = async () => {
            if (!directInvite) return;
            // Oyunu (daveti) veritabanından sil
            await db.collection('game_rooms').doc(directInvite.gameId).delete();
            // Davet eden oyuncunun lobi durumunu temizle
            await db.collection('lobby').doc(directInvite.invitedBy).update({ status: 'idle', gameId: null });
            // Kendi lobi durumunu temizle
            await db.collection('lobby').doc(username).update({ status: 'idle', gameId: null });
            setDirectInvite(null);
            setToastMessage("Davet reddedildi.");
        };




React.useEffect(() => {
            if (!username || !db) return;

            const userLobbyRef = db.collection('lobby').doc(username);
            const unsubscribe = userLobbyRef.onSnapshot((doc) => {
                const data = doc.data();
                if (data && data.status === 'invited' && data.gameId && data.invitedBy) {
                    setDirectInvite({
                        gameId: data.gameId,
                        invitedBy: data.invitedBy
                    });
                } else {
                    setDirectInvite(null);
                }
            });

            return () => unsubscribe(); // Bileşen kaldırıldığında dinleyiciyi kapat
        }, [username, db]);



        React.useEffect(() => 
        {
            window.androidBridge.handleIncomingDuel = (payloadString) => 
            {
             try {
            const payload = JSON.parse(payloadString);
            if (payload && payload.id && payload.invitedBy) {
                setIncomingInvitation(payload);
            } else {
                console.error("WebAppLog: Geçersiz veya eksik payload.", payload);
            }
                } catch (error) {
            console.error("WebAppLog: Gelen payload işlenirken hata oluştu:", error);
                }
            };
            return () => 
            {window.androidBridge.handleIncomingDuel = null;};
            }, []);


        const handleAndroidBack = React.useCallback(() => {
            if (page === 'game' && typeof window.androidBridge.game_showExitConfirmation === 'function') {
                window.androidBridge.game_showExitConfirmation();
            } else if (page === 'home') {
                setShowAppExitModal(true);
            } else {
                goToHome();
            }
        }, [page, goToHome]);

        window.androidBridge.handleIncomingDuel = async (duelId) => {
            if (!duelId) return;
            const duelRef = db.collection('active-duels').doc(duelId);
            const duelDoc = await duelRef.get();
            if (duelDoc.exists) {
                setIncomingInvitation({ id: duelDoc.id, ...duelDoc.data() });
            } else {
                console.log("Davet bulunamadı veya iptal edilmiş.");
            }
        };

        React.useEffect(() => {
            if (!username || !db) return;
            const lobbyRef = db.collection('lobby').doc(username);
            const updatePresence = (status) => {
                lobbyRef.set({
                    username: username,
                    presence: status,
                    last_active: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
            };
            updatePresence('online');
            const handleVisibilityChange = () => {
                if (document.visibilityState === 'hidden') {
                    updatePresence('offline');
                } else {
                    updatePresence('online');
                }
            };
            const handleBeforeUnload = () => {
                updatePresence('offline');
            };
            document.addEventListener('visibilitychange', handleVisibilityChange);
            window.addEventListener('beforeunload', handleBeforeUnload);
            return () => {
                document.removeEventListener('visibilitychange', handleVisibilityChange);
                window.removeEventListener('beforeunload', handleBeforeUnload);
            };
        }, [username, db]);

        React.useEffect(() => {
            if (!username) return;
            const requestsRef = db.collection('users').doc(username).collection('friendRequests');
            const unsubscribe = requestsRef.onSnapshot(snapshot => {
                if (!snapshot.empty) {
                    const firstRequest = snapshot.docs[0];
                    setFriendRequest({ id: firstRequest.id, ...firstRequest.data() });
                } else {
                    setFriendRequest(null);
                }
            });
            return () => unsubscribe();
        }, [username, db]);

        const handleColorSelect = async (colorId) => {
            if (!username) return;
            try {
                await db.collection('users').doc(username).update({
                    cardColor: colorId
                });
                setCardColor(colorId);
                setToastMessage("Kart rengin güncellendi!");
            } catch (error) {
                console.error("Kart rengi güncellenirken hata:", error);
            }
        };

        const handleUsernameUpdate = async (newName) => {
            const trimmedName = newName.trim();
            if (!trimmedName || trimmedName === username) {
                setToastMessage("Yeni kullanıcı adı geçerli veya mevcut olanla aynı.");
                return;
            }
            const userRef = db.collection("users").doc(trimmedName);
            const doc = await userRef.get();
            if (doc.exists) {
                setToastMessage("Bu kullanıcı adı zaten alınmış.");
                return;
            }
            try {
                const oldUserDoc = await db.collection("users").doc(username).get();
                if(oldUserDoc.exists) {
                    await db.collection("users").doc(trimmedName).set(oldUserDoc.data());
                    await db.collection("users").doc(username).delete();
                    localStorage.setItem('wordHuntUsername', trimmedName);
                    setUsername(trimmedName);
                    setToastMessage("Kullanıcı adın başarıyla güncellendi!");
                }
            } catch (error) {
                console.error("Kullanıcı adı güncellenirken hata:", error);
                setToastMessage("Hata: Kullanıcı adı güncellenemedi.");
            }
        };

        const handleAcceptFriendRequest = async () => {
            if (!friendRequest) return;
            const fromUser = friendRequest.from;
            const batch = db.batch();
            const myFriendRef = db.collection('users').doc(username).collection('friends').doc(fromUser);
            batch.set(myFriendRef, { addedAt: firebase.firestore.FieldValue.serverTimestamp() });
            const theirFriendRef = db.collection('users').doc(fromUser).collection('friends').doc(username);
            batch.set(theirFriendRef, { addedAt: firebase.firestore.FieldValue.serverTimestamp() });
            const requestRef = db.collection('users').doc(username).collection('friendRequests').doc(fromUser);
            batch.delete(requestRef);
            try {
                await batch.commit();
                setToastMessage(`${fromUser} ile arkadaş oldunuz!`);
                setFriendRequest(null);
            } catch (error) {
                console.error("İstek kabul edilemedi:", error);
            }
        };

        const handleDeclineFriendRequest = async () => {
            if (!friendRequest) return;
            const requestRef = db.collection('users').doc(username).collection('friendRequests').doc(friendRequest.from);
            await requestRef.delete();
            setFriendRequest(null);
        };

        React.useEffect(() => {
            if (page === 'game' || page === 'lobby') {
                document.body.classList.add('no-scroll');
            } else {
                document.body.classList.remove('no-scroll');
            }
        }, [page]);

       React.useEffect(() => {
            window.androidBridge.registered_onBackPress = handleAndroidBack;

            const initializeApp = async () => {
                setIsInitializing(true);
                try {
                    if (window.Android && typeof window.Android.getVersionName === 'function') {
                        const appVersion = window.Android.getVersionName();
                        if (appVersion) {
                            window.setAppVersion(appVersion);
                        }
                    }

                    const savedUser = localStorage.getItem('wordHuntUsername');
                    if (savedUser) {
                        await loadUserData(savedUser);
                        if (pendingFCMToken) {
                            saveTokenForUser(savedUser, pendingFCMToken, 3, setToastMessage);
                        }
                    } else {
                        setShowUsernamePrompt(true);
                    }
                } catch (error) {
                    console.error("Uygulama başlatılırken bir hata oluştu:", error);
                } finally {
                    setIsInitializing(false);
                }
            };

            initializeApp();

            return () => {
                window.androidBridge.registered_onBackPress = null;
            };
        }, [handleAndroidBack]);

      

        React.useEffect(() => {
            if (page === 'home') {
                try {
                    const saves = localStorage.getItem(ALL_SAVES_KEY);
                    setAllSaves(saves ? JSON.parse(saves) : { lastPlayed: null });
                } catch (e) {
                    setAllSaves({ lastPlayed: null });
                }
            }
        }, [page]);

        React.useEffect(() => {
            if (toastMessage) {
                const timer = setTimeout(() => setToastMessage(null), 3800);
                return () => clearTimeout(timer);
            }
        }, [toastMessage]);

const startSinglePlayerGame = (selectedMode) => {
            const t = translations[language] || translations['en'];
            
            const isTracking = selectedMode.startsWith('takip-');
            const modeName = isTracking ? selectedMode.substring(6) : selectedMode;
            const modeType = isTracking ? 'takip' : 'avi';

            if (modeName === 'random') {
                const playableModes = ['super-easy', 'easy', 'hard', 'timed-easy', 'timed-hard'];
                const randomModeKey = _.sample(playableModes);
                const keyForTranslation = randomModeKey.replace(/-(\w)/g, (m, l) => l.toUpperCase()) + 'Mode';
                const randomModeName = t[keyForTranslation] || randomModeKey;
                const randomLevel = _.random(0, 89);
                setModalContent({
                    isOpen: true,
                    title: t.randomGameTitle,
                    body: (<div><p className="text-gray-700 text-lg mb-6" dangerouslySetInnerHTML={{ __html: t.randomGameBody(randomModeName, randomLevel + 1) }} /><button onClick={() => {
                        setGameKey(Date.now());
                        // modeType'ı config'e ekle
                        setModeConfig({ name: randomModeKey, modeType: modeType, level: randomLevel, isOneShot: true });
                        setPage('game');
                        setModalContent({ isOpen: false });
                    }} className="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg">{t.startButton}</button></div>)
                });
                return;
            }

            const savedGameForMode = allSaves?.[selectedMode];
            if (!savedGameForMode) {
                setGameKey(Date.now());
                setModeConfig({ name: modeName, modeType: modeType });
                setPage('game');
            } else {
                const handleContinue = () => {
                    setGameKey(Date.now());
                    setModeConfig({ name: savedGameForMode.mode, modeType: modeType, level: savedGameForMode.level });
                    setLanguage(savedGameForMode.language);
                    setModalContent({ isOpen: false });
                    setPage('game');
                };
                const handleNewGame = () => {
                    const currentSaves = { ...allSaves };
                    delete currentSaves[selectedMode];
                    localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
                    setAllSaves(currentSaves);
                    
                    setGameKey(Date.now());
                    // modeType'ı config'e ekle
                    setModeConfig({ name: modeName, modeType: modeType });
                    setModalContent({ isOpen: false });
                    setPage('game');
                };

                let modalBgClass = 'from-sky-600 to-indigo-700';
                if (savedGameForMode.mode.includes('super-easy')) {
                    modalBgClass = 'from-purple-600 to-violet-700';
                } else if (savedGameForMode.mode.includes('hard')) {
                    modalBgClass = 'from-red-600 to-rose-700';
                }
                
                setModalContent({
                    isOpen: true,
                    title: '',
                    onClose: () => setModalContent({ isOpen: false }),
                    body: (
                        <div className={`w-full max-w-sm text-white bg-gradient-to-br ${modalBgClass} rounded-2xl shadow-2xl p-6 text-center`}>
                            <div className="text-6xl mb-4">🧭</div>
                            <h2 className="text-2xl font-bold mb-2">Maceraya Devam Et!</h2>
                            <p className="text-white/80 mb-6" dangerouslySetInnerHTML={{ __html: t.savedGameFoundBody(savedGameForMode.level + 1) }}></p>
                            <div className="flex flex-col gap-3">
                                <button 
                                    onClick={handleContinue}
                                    className="w-full px-8 py-3 bg-amber-500 text-white font-bold rounded-lg hover:bg-amber-400 transition-all transform hover:scale-105 shadow-lg"
                                >
                                    {t.yesContinueButton}
                                </button>
                                <button 
                                    onClick={handleNewGame}
                                    className="w-full px-8 py-2 bg-emerald-600 text-white font-bold rounded-lg hover:bg-emerald-500 transition-all"
                                >
                                    {t.noStartNewButton}
                                </button>
                            </div>
                        </div>
                    )
                });
            }
        };

	const launchVsComputerGame = (difficulty, boardSize, aiStrength) => { // <-- aiStrength eklendi
            setModalContent({ isOpen: false });
            setGameKey(Date.now());
            setModeConfig({ 
                name: 'vs-computer', 
                difficulty: difficulty, 
                boardSize: boardSize,
                aiStrength: aiStrength // <-- aiStrength eklendi
            });
            setPage('game');
        };

       const openVsComputerSetupModal = () => {
            const VsComputerSetupModal = ({ onStart }) => {
                const [difficulty, setDifficulty] = React.useState('easy');
                const [size, setSize] = React.useState('medium');
                const [aiStrength, setAiStrength] = React.useState('orta');

                // İkonlar güncellendi, alt yazılar (desc) kaldırıldı
                const strengthOptions = [
                    { key: 'zayif', label: 'Zayıf', icon: '🧠' },
                    { key: 'orta', label: 'Orta', icon: '🤓' }, // Ampul ikonu değişti
                    { key: 'guclu', label: 'Güçlü', icon: '⚡️' }
                ];
                const difficultyOptions = [
                    { key: 'easy', label: 'Kolay', icon: '🧸' },
                    { key: 'hard', label: 'Zor', icon: '🔥' },
                ];
                const sizeOptions = [
                    { key: 'small', label: 'Küçük', icon: '🤏' },
                    { key: 'medium', label: 'Orta', icon: '👌' },
                    { key: 'large', label: 'Geniş', icon: '👐' },
                ];
                return (
                    <div className="flex flex-col gap-6 mt-2">
                        <div>
                            <h4 className="font-bold text-lg text-slate-700 mb-3 text-left">Yapay Zekâ Gücü</h4>
                            <div className="grid grid-cols-3 gap-3">
                                {strengthOptions.map(opt => (
                                    <button
                                        key={opt.key}
                                        onClick={() => setAiStrength(opt.key)}
                                        // Buton yüksekliği (h-24) azaltılarak daha kompakt hale getirildi
                                        className={`p-3 h-24 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${aiStrength === opt.key ? 'bg-gradient-to-br from-amber-400 to-orange-500 text-white ring-4 ring-offset-2 ring-amber-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}
                                    >
                                        <span className="text-3xl">{opt.icon}</span>
                                        <span className="mt-1 text-sm">{opt.label}</span>
                                        {/* Alt yazı (desc) buradan kaldırıldı */}
                                    </button>
                                ))}
                            </div>
                        </div>

                        <div>
                            <h4 className="font-bold text-lg text-slate-700 mb-3 text-left">Zorluk Seviyesi</h4>
                            <div className="grid grid-cols-2 gap-3">
                                {difficultyOptions.map(opt => (
                                    <button
                                        key={opt.key}
                                        onClick={() => setDifficulty(opt.key)}
                                        // Buton yüksekliği (h-24) azaltıldı
                                        className={`p-3 h-24 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${difficulty === opt.key ? (opt.key === 'easy' ? 'bg-gradient-to-br from-green-400 to-emerald-500' : 'bg-gradient-to-br from-red-500 to-rose-600') + ' text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}
                                    >
                                        <span className="text-4xl">{opt.icon}</span>
                                        <span className="mt-1 text-base">{opt.label}</span>
                                        {/* Alt yazı (desc) buradan kaldırıldı */}
                                    </button>
                                ))}
                            </div>
                        </div>

                        <div>
                            <h4 className="font-bold text-lg text-slate-700 mb-3 text-left">Oyun Alanı Boyutu</h4>
                            <div className="grid grid-cols-3 gap-3">
                                {sizeOptions.map(opt => (
                                     <button
                                        key={opt.key}
                                        onClick={() => setSize(opt.key)}
                                        className={`p-3 h-24 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${size === opt.key ? 'bg-indigo-600 text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}
                                    >
                                        <span className="text-3xl">{opt.icon}</span>
                                        <span className="mt-1 text-sm">{opt.label}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                        <button
                            onClick={() => onStart(difficulty, size, aiStrength)}
                            className="w-full mt-4 py-3 bg-gradient-to-r from-purple-600 to-indigo-700 text-white font-bold rounded-lg text-lg hover:shadow-xl transition-all transform hover:scale-105"
                        >
                            Başlat!
                        </button>
                    </div>
                );
            };
            setModalContent({
                isOpen: true,
                title: 'Siz vs. 🤖',
                body: <VsComputerSetupModal onStart={launchVsComputerGame} />
            });
        };

        const startGameVsComputer = () => {
        openVsComputerSetupModal();
    };
const statsForWordHunt = React.useMemo(() => {
            return { ...gameStats, gold: gold, username: username };
        }, [gameStats, gold, username]);
        const handleAcceptInvitation = async () => {
            if (!incomingInvitation) return;
            const duelId = incomingInvitation.id;
            const gameRef = db.collection('active-duels').doc(duelId);
            await gameRef.update({ status: 'active' });
            const playerUsernames = Object.keys(incomingInvitation.players);
            const player1Ref = db.collection('lobby').doc(playerUsernames[0]);
            const player2Ref = db.collection('lobby').doc(playerUsernames[1]);
            await player1Ref.update({ status: 'in-game', gameId: duelId });
            await player2Ref.update({ status: 'in-game', gameId: duelId });
            setIncomingInvitation(null);
            setGameId(duelId);
            setPage('game');
        };

        const handleDeclineInvitation = async () => {
            if (!incomingInvitation) return;
            await db.collection('active-duels').doc(incomingInvitation.id).delete();
            setIncomingInvitation(null);
        };

        

        const goToLobby = () => {
            if (username) {
                const lobbyData = {
                    username: username,
                    status: 'idle',
                    joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    last_active: firebase.firestore.FieldValue.serverTimestamp()
                };
                db.collection('lobby').doc(username).set(lobbyData);
                setPage('lobby');
            } else {
                setShowUsernamePrompt(true);
            }
        };

      const openLobbyPage = () => {
            setPage('lobby');
        };

    

        return (
            <ErrorBoundary>
                <div className="h-full w-full overflow-hidden">
                  {page === 'home' && (
                        <HomePage
                            startGame={startSinglePlayerGame}
                            startGameVsComputer={startGameVsComputer}
                            language={language}
                            setLanguage={setLanguage}
                            stats={statsForWordHunt}
                            setModalContent={setModalContent}
                            savedGame={allSaves && allSaves.lastPlayed ? allSaves[allSaves.lastPlayed] : null}
                            username={username}
                            isInitializing={isInitializing}
                            openLobbyPage={openLobbyPage}
                            avatarId={avatarId}
                            openProfileModal={() => setIsProfileModalOpen(true)}
				cardColor={cardColor} 
                            playerCardColors={playerCardColors}                         />
                    )}
                 {page === 'lobby' && (
                        <DuelLobbyPage
                            username={username}
                            onBack={goToHome}
                            db={db}
                            setToastMessage={setToastMessage}
                            joinGameRoom={joinGameRoom}
                            createGameRoom={createGameRoom}
                            sendDirectInvite={sendDirectInvite}
                        />
                    )}

   

{page === 'room_lobby' && (
    <RoomLobbyPage
        username={username}
        gameId={gameId}
        db={db}
        onBack={goToHome}
        startGame={startGame}
        setPage={setPage}
        setToastMessage={setToastMessage}
        setModeConfig={setModeConfig} 
     />
)}


                    {page === 'game' && (
                        <WordHunt
                            key={gameKey}
                            config={modeConfig}
                            gameId={gameId}
                            username={username}
                            goToHome={goToHome}
                            language={language}
                            stats={{ ...gameStats, gold: gold, username: username }}
                            onStatsChange={handleStatsChange}
                            initialSavedState={allSaves && !gameId ? allSaves[modeConfig.name] : null}
                            toastMessage={toastMessage}
                            setToastMessage={setToastMessage}
                        />
                    )}
                </div>
                <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={() => setModalContent({ isOpen: false })}>
                    {modalContent.body}
                </Modal>
                {showUsernamePrompt && <UsernamePrompt onSave={handleSaveUsername} />}
                
          
                {showAppExitModal && (
                    <Modal isOpen={true} title="Oyundan Çık" onClose={() => setShowAppExitModal(false)}>
                        <div className="text-center">
                            <p className="text-lg text-gray-700 mb-6">Uygulamadan çıkmak istediğinize emin misiniz?</p>
                            <div className="flex justify-center gap-4">
                                <button onClick={() => setShowAppExitModal(false)} className="px-8 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600">Hayır</button>
                                <button onClick={() => { if (window.Android && window.Android.closeApp) { window.Android.closeApp(); } }} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Evet</button>
                            </div>
                        </div>
                    </Modal>
                )}
                <AvatarSelectionModal
                    isOpen={isAvatarModalOpen}
                    onClose={() => setIsAvatarModalOpen(false)}
                    onAvatarSelect={handleAvatarSelect}
                />
                <ProfileModal
    isOpen={isProfileModalOpen}
    onClose={() => setIsProfileModalOpen(false)}
    username={username}
    avatarId={avatarId}
    cardColor={cardColor}
    gold={gold}
    unlockedAvatars={unlockedAvatars}
    unlockedColors={unlockedColors}
    onAvatarSelect={handleAvatarSelect}
    onUsernameUpdate={handleUsernameUpdate}
    onColorSelect={handleColorSelect}
    onPurchaseItem={handlePurchaseItem}
/>
                <FriendRequestModal
                    isOpen={!!friendRequest}
                    requestDetails={friendRequest}
                    onAccept={handleAcceptFriendRequest}
                    onDecline={handleDeclineFriendRequest}
                />

<DirectInviteModal
                    isOpen={!!directInvite}
                    invitationDetails={directInvite}
                    onAccept={handleAcceptDirectInvite}
                    onDecline={handleDeclineDirectInvite}
                />


                {toastMessage && (
                    <div className="toast-notification fixed bottom-24 left-1/2 -translate-x-1/2 bg-indigo-600 text-white font-bold py-3 px-6 rounded-full shadow-lg z-[9999]">
                        {toastMessage}
                    </div>
                )}
            </ErrorBoundary>
        );
    }
    window.handleAndroidBackPress = function() {
        if (window.appNavigator && window.appNavigator.getCurrentPage() === 'game') {
            window.appNavigator.goToHome();
            return true;
        }
        return false;
    };
    initializeGame();

</script>
</body>
</html>
