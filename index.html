<!DOCTYPE html>
<html lang="tr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Kelime Avƒ± - Tam S√ºr√ºm</title>
	<script src="libs/react.production.min.js"></script>
	<script src="libs/react-dom.production.min.js"></script>
	<script src="libs/lodash.min.js"></script>
	<script src="libs/tailwindcss.js"></script>
	<script src="libs/confetti.browser.min.js"></script>
	<script src="libs/firebase-app.js"></script>
	<script src="libs/firebase-firestore.js"></script>
	<script src="libs/firebase-auth.js"></script>
    <script src="libs/firebase-remote-config.js"></script>
	<script src="libs/babel.min.js"></script>
	<script src="wordstr.js?v=1.0"></script>
	<script src="words_tr_2letters.js?v=1.0"></script>
	<script src="wordsen.js?v=1.0"></script>

	<style>
	body {overscroll-behavior-y: none;-webkit-user-select: none;user-select: none;height: 100vh;font-family: 'Inter', sans-serif;background-color: #f3f4f6;    }
	body.no-scroll {overflow: hidden;touch-action: none;}
    body.no-scroll #root {overflow: hidden;}
    .grid { -webkit-tap-highlight-color: transparent; }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    .scrollbar-thin { scrollbar-width: thin; scrollbar-color: #9CA3AF #E5E7EB; }
    .scrollbar-thin::-webkit-scrollbar { width: 5px; }
    .scrollbar-thin::-webkit-scrollbar-track { background: #E5E7EB; border-radius: 10px;}
    .scrollbar-thin::-webkit-scrollbar-thumb { background-color: #9CA3AF; border-radius: 10px; border: 1px solid #E5E7EB; }
    .shake-animation {  animation: shake 0.3s ease-in-out;}
    .toast-notification { animation: toast-in-out 4s forwards; }
    .hidden-word-start-letter { color: #0d6efd !important; font-weight: 900; }
    .animate-hint-pulse {animation: pulse-hint 1.5s infinite ease-in-out;color: #713f12 !important;font-weight: 900;}
    .animate-word-found { animation: word-found-animation 0.6s ease-out; }
	.dynamic-grid {display: grid; grid-template-columns: repeat(var(--grid-cols, 6), 1fr);  }
    @keyframes word-found-animation {
    0% { transform: scale(1); background-color: #6ee7b7; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
    50% { transform: scale(1.1); background-color: #34d399; box-shadow: 0 0 15px 5px rgba(16, 185, 129, 0.5); }
    100% { transform: scale(1); background-color: #6ee7b7; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }	}
    .animate-bonus-glow {animation: bonus-double-glow-animation 1.2s ease-out;}

    @keyframes bonus-double-glow-animation {    0% {        transform: scale(1);    }
    25% {        transform: scale(1.15);        background-color: #fde047;        box-shadow: 0 0 15px #facc15;    }
    50% {        transform: scale(1);    }
    75% {        transform: scale(1.15);        background-color: #fde047;         box-shadow: 0 0 15px #facc15;    }
    100% {       transform: scale(1);    }    }	


    #loader.hidden {        opacity: 0;        visibility: hidden;        transition: opacity 0.5s ease-out, visibility 0.5s ease-out;    }
    #loader-progress {        animation: loading-progress 1.5s ease-in-out forwards;    }
    @keyframes loading-progress {        0% { width: 0%; }        100% { width: 100%; }    }
	.animate-timer-pulse {	animation: pulse-timer 0.5s ease-out;}

    @keyframes pulse-timer {      0% { transform: scale(1); }
      40% { transform: scale(1.15); color: #ef4444; }
      100% { transform: scale(1); }}

    @keyframes toast-in-out {
    0% { transform: translateY(100%); opacity: 0; }
    15% { transform: translateY(0); opacity: 1; }
    85% { transform: translateY(0); opacity: 1; }
    100% { transform: translateY(100%); opacity: 0; }}

    @keyframes shake {
    0% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    50% { transform: translateX(5px); }
    75% { transform: translateX(-5px); }
    100% { transform: translateX(0); }}
@keyframes gradient-animation {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}
.animate-loading-bar-slide {
    width: 40%;
    animation: loading-bar-slide 1.5s ease-in-out infinite;
}
@keyframes loading-bar-slide {
    0% { transform: translateX(-150%); }
    100% { transform: translateX(300%); }
}
    @keyframes pulse-hint {  0%, 100% { background-color: #fef08a; transform: scale(1); }50% { background-color: #fde047; 	transform: scale(1.05); box-shadow: 0 0 8px #facc15; } }
</style>

</head>

<body class="h-[100vh] flex flex-col">
<div id="loader" class="fixed inset-0 bg-slate-800 flex flex-col items-center justify-center z-[9999]">
	<img src="logo.png" alt="Oyun Logosu" class="w-32 h-32 mb-6 animate-pulse" />

	<div class="w-48 bg-slate-700 rounded-full h-2.5">
		<div id="loader-progress" class="bg-indigo-500 h-2.5 rounded-full" style="width: 0%"></div>
	</div>
	<p class="text-slate-400 mt-4 text-lg font-semibold">Y√ºkleniyor...</p>

	<p id="version-display" class="absolute bottom-4 text-white/60 text-sm font-mono"></p></div>
</div>

<div id="root" class="flex-1"></div>

<audio id="correctSound" preload="auto" src="sounds/correct.mp3">Tarayƒ±cƒ±nƒ±z ses etiketini desteklemiyor.</audio>
<audio id="wrongSound" preload="auto" src="sounds/wrong.mp3">Tarayƒ±cƒ±nƒ±z ses etiketini desteklemiyor.</audio>
<audio id="achievementSound" preload="auto" src="sounds/achievement.mp3">Tarayƒ±cƒ±nƒ±z ses etiketini desteklemiyor.</audio>

<script type="text/babel">

	window.setAppVersion = function(version) {
      const versionElement = document.getElementById('version-display');

      if (versionElement) {
        versionElement.innerText = `v${version}`;
      } else {
        console.error("JS: HATA! 'version-display' elementi HTML'de bulunamadƒ±!");
      }
    };

  function DuelInviteModal({ isOpen, onClose, player, onInvite, language }) {
    if (!isOpen || !player) return null;
    
    const t = translations[language] || translations['en'];
    const [boardSize, setBoardSize] = React.useState('medium');
    const [difficulty, setDifficulty] = React.useState('easy');

    const difficultyOptions = [
        { key: 'easy', label: t.kolay, icon: 'üß∏', desc: t.easyDesc, color: 'from-green-400 to-emerald-500' },
        { key: 'hard', label: t.zor, icon: 'üî•', desc: t.hardDesc, color: 'from-red-500 to-rose-600' }
    ];

    const sizeOptions = [
        { key: 'small', label: t.smallArea, icon: 'ü§è' },
        { key: 'medium', label: t.mediumArea, icon: 'üëå' },
        { key: 'large', label: t.largeArea, icon: 'üëê' }
    ];

    const handleSendInvite = () => {
        onInvite(player, boardSize, difficulty);
        onClose();
    };

    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className="bg-slate-50 p-6 rounded-2xl shadow-2xl w-full max-w-sm" onClick={e => e.stopPropagation()}>
                <h3 className="text-2xl font-bold mb-6 text-gray-800 text-center">
                    <span className="font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-indigo-600">{t.setupGameFor(player.username)}</span>
                </h3>
                <div className="space-y-6">
                    <div>
                        <h4 className="font-bold text-lg text-slate-700 mb-3">{t.difficulty}</h4>
                        <div className="grid grid-cols-2 gap-3">
                            {difficultyOptions.map(opt => (
                                <button
                                    key={opt.key}
                                    onClick={() => setDifficulty(opt.key)}
                                    className={`p-3 h-28 rounded-xl text-white font-bold flex flex-col items-center justify-center text-center transition-all transform bg-gradient-to-br ${opt.color} ${difficulty === opt.key ? 'ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'opacity-80 hover:opacity-100'}`}
                                >
                                    <span className="text-4xl drop-shadow-lg">{opt.icon}</span>
                                    <span className="mt-1 text-base">{opt.label}</span>
                                    <span className="mt-1 text-xs font-normal opacity-90">{opt.desc}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                    <div>
                        <h4 className="font-bold text-lg text-slate-700 mb-3">{t.boardSize}</h4>
                        <div className="grid grid-cols-3 gap-3">
                            {sizeOptions.map(opt => (
                                 <button
                                    key={opt.key}
                                    onClick={() => setBoardSize(opt.key)}
                                    className={`p-3 h-24 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${boardSize === opt.key ? 'bg-indigo-600 text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}
                                >
                                    <span className="text-3xl">{opt.icon}</span>
                                    <span className="mt-1 text-sm">{opt.label}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
                <button onClick={handleSendInvite} className="w-full mt-8 bg-green-500 text-white font-bold py-3 rounded-lg hover:bg-green-600 transition-all text-lg shadow-lg">
                    {t.challenge}
                </button>
            </div>
        </div>
    );
}



function ConfirmationModal({ isOpen, onClose, onConfirm, title, bodyText, language }) {
    if (!isOpen) return null;
    const t = translations[language] || translations['en'];
    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
            <div className="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm text-center">
                <h3 className="text-xl font-bold mb-4 text-gray-800">{title}</h3>
                <p className="text-gray-600 mb-6" dangerouslySetInnerHTML={{ __html: bodyText }}></p>
                <div className="flex justify-center gap-4">
                    <button onClick={onClose} className="px-6 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600">{t.stayButton}</button>
                    <button onClick={onConfirm} className="px-6 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">{t.quitButton}</button>
                </div>
            </div>
        </div>
    );
}

function DirectInviteModal({ isOpen, invitationDetails, onAccept, onDecline, language }) {
    if (!isOpen || !invitationDetails) return null;
    const t = translations[language] || translations['en'];
    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
            <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-sm text-center transform transition-all animate-pulse-once">
                <h3 className="text-3xl font-bold mb-2 text-gray-800">‚öîÔ∏è {t.duelChallenge} ‚öîÔ∏è</h3>
                <p className="text-gray-600 text-lg mb-6">
                    <span className="font-bold text-indigo-600">{invitationDetails.invitedBy}</span> {t.invitedToGame(invitationDetails.invitedBy)}
                </p>
                <div className="flex justify-center gap-4 mt-4">
                    <button
                        onClick={onDecline}
                        className="px-8 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-all transform hover:scale-105 shadow-lg">
                        {t.decline}
                    </button>
                    <button
                        onClick={onAccept}
                        className="px-8 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition-all transform hover:scale-105 shadow-lg">
                        {t.accept}
                    </button>
                </div>
            </div>
        </div>
    );
}


function RoomLobbyPage({ username, gameId, db, onBack, startGame, setPage, setToastMessage, setModeConfig, language }) {
    const t = translations[language] || translations['en'];
    const [roomData, setRoomData] = React.useState(null);

    React.useEffect(() => {
        if (!gameId) {
            onBack();
            return;
        }

        const roomRef = db.collection('game_rooms').doc(gameId);
        const unsubscribe = roomRef.onSnapshot(doc => {
            if (doc.exists) {
                const data = doc.data();
                setRoomData(data);
                
                if (data.status === 'in-progress' && data.boardData && data.boardData.board && Object.keys(data.boardData.board).length > 0) {
                    const newConfig = {
                        name: 'multiplayer',
                        boardSize: data.gameSettings.boardSize,
                        difficulty: data.gameSettings.difficulty,
                        modeType: 'avi' 
                    };
                    setModeConfig(newConfig);
                    setPage('game');
                }
            } else {
                setToastMessage("Oda kapatƒ±ldƒ± veya bulunamadƒ±.");
                onBack();
            }
        });

        return () => unsubscribe();
    }, [gameId, db, onBack, setPage, setToastMessage, setModeConfig]);

    const leaveRoom = async () => {
        if (!roomData) return;
        const roomRef = db.collection('game_rooms').doc(gameId);
        
        try {
            if (Object.keys(roomData.players).length <= 1) {
                await roomRef.delete();
            } else {
                const updates = {
                    [`players.${username}`]: firebase.firestore.FieldValue.delete()
                };
                if (roomData.host === username) {
                    updates.host = Object.keys(roomData.players).find(p => p !== username) || null;
                }
                await roomRef.update(updates);
            }
        } catch (error) {
            console.error("Odadan ayrƒ±lƒ±rken hata:", error);
        } finally {
            onBack();
        }
    };

    if (!roomData) {
        return <div className="flex items-center justify-center h-screen bg-gray-800 text-white text-lg">{t.loading}...</div>;
    }

    const isHost = roomData.host === username;
    const players = Object.values(roomData.players);
    const playerUsernames = Object.keys(roomData.players);
    const canStart = playerUsernames.length >= 2;

    return (
        <div className="h-screen w-full bg-gradient-to-br from-gray-800 to-slate-900 text-white flex flex-col items-center justify-center p-4">
            <div className="text-center mb-8">
                <h1 className="text-4xl font-black mb-2 tracking-tight">{t.hostsRoom(roomData.host)}</h1>
                <p className="text-indigo-300 animate-pulse">{isHost ? t.waitingForPlayers : t.waitingForHost}</p>
            </div>

            <div className="w-full max-w-lg grid grid-cols-2 gap-4 mb-8">
                {playerUsernames.map((name, index) => {
                    const pData = roomData.players[name];
                    return (
                        <div key={name} className="bg-white/10 p-3 rounded-lg flex flex-col items-center gap-2 text-center shadow-lg">
                           <div className="relative">
                             <img src={pData.avatarId ? `avatars/${pData.avatarId}.png` : 'avatars/default.png'} className="w-16 h-16 rounded-full object-cover border-2 border-slate-500" />
                             {roomData.host === name && <span className="absolute -top-1 -right-1 text-2xl" title={t.host}>üëë</span>}
                           </div>
                           <p className="font-bold text-sm">{name}</p>
                        </div>
                    );
                })}
            </div>

            {isHost && (
                <button
                    onClick={() => startGame(gameId)}
                    disabled={!canStart}
                    className="bg-green-600 text-white font-bold py-4 px-10 rounded-lg shadow-lg text-xl hover:bg-green-700 disabled:bg-gray-500 disabled:cursor-not-allowed transform hover:scale-105 transition-all"
                >
                    {canStart ? t.startGameButton : t.waitingForPlayer}
                </button>
            )}

            <button onClick={leaveRoom} className="absolute top-6 right-6 bg-red-500/50 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-500/80 transition-colors">
                {t.leaveRoomButton}
            </button>
        </div>
    );
}








function initializeGame() {
        if (window.firebase && window._ && window.React && window.ReactDOM) {
            runApp();
        } else {
            setTimeout(initializeGame, 100);
        }
    }

    const playerCardColors = [
    { id: 'teal', name: 'Turkuaz', class: 'bg-gradient-to-br from-teal-400 to-cyan-500' },
    { id: 'blue', name: 'Mavi', class: 'bg-gradient-to-br from-blue-400 to-indigo-500' },
    { id: 'purple', name: 'Mor', class: 'bg-gradient-to-br from-purple-500 to-violet-600' },
    { id: 'pink', name: 'Pembe', class: 'bg-gradient-to-br from-pink-400 to-rose-500' },
    { id: 'orange', name: 'Turuncu', class: 'bg-gradient-to-br from-orange-400 to-amber-500' },
    { id: 'lime', name: 'Misket Limonu', class: 'bg-gradient-to-br from-lime-400 to-emerald-500' },
    { id: 'sky', name: 'G√∂k Mavisi', class: 'bg-gradient-to-br from-sky-400 to-cyan-400' },
    { id: 'red', name: 'Kƒ±rmƒ±zƒ±', class: 'bg-gradient-to-br from-red-500 to-rose-600' },
    { id: 'green', name: 'Ye≈üil', class: 'bg-gradient-to-br from-green-500 to-lime-600' },
    { id: 'gray', name: 'Gri', class: 'bg-gradient-to-br from-slate-500 to-gray-600' },
    { id: 'yellow', name: 'Sarƒ±', class: 'bg-gradient-to-br from-yellow-400 to-amber-500' },
    { id: 'cyan', name: 'Cam G√∂beƒüi', class: 'bg-gradient-to-br from-cyan-400 to-sky-500' },
    { id: 'emerald', name: 'Z√ºmr√ºt', class: 'bg-gradient-to-br from-emerald-500 to-green-600' },
    { id: 'fuchsia', name: 'Galibarda', class: 'bg-gradient-to-br from-fuchsia-500 to-pink-600' },
    { id: 'indigo', name: '√áivit Mavisi', class: 'bg-gradient-to-br from-indigo-500 to-purple-600' }
];

    const ModernModeCard = ({ title, icon, bgColor, className, onClick, disabled, userInfo, buttonText = "Oyna" }) =>
        {const handleClick = () => {
            if (!disabled) {onClick();}};

        return (
            <div
                onClick={handleClick}
                role="button"
                tabIndex={disabled ? -1 : 0}
                className={`relative group w-full rounded-2xl text-white overflow-hidden transition-opacity duration-200 border border-white/20 will-change-transform ${bgColor} ${className} ${disabled ? 'opacity-60 cursor-not-allowed' : 'cursor-pointer'}`}
            >
                <div className="absolute -right-2 -bottom-2 text-8xl opacity-40 drop-shadow-lg">
                    {icon}
                </div>

                {userInfo && userInfo.username && (
                    <div className="absolute bottom-2 right-3 bg-black/30 backdrop-blur-sm text-white text-[10px] font-bold px-2 py-0.5 rounded-full flex items-center gap-1">
                        <div className={`w-1.5 h-1.5 ${userInfo.status === '√áevrimi√ßi' ? 'bg-green-400' : 'bg-gray-400'} rounded-full`}></div>
                        {userInfo.username}
                    </div>
                )}

                <div className="p-3 h-full flex flex-col justify-between text-left pointer-events-none">
                    <h3 className="text-lg font-bold leading-tight">{title}</h3>
                    <div className={`mt-2 self-start bg-white/20 backdrop-blur-sm text-white text-xs font-bold uppercase tracking-wider rounded-full px-4 py-1.5 flex items-center gap-2`}>
                        <span>{disabled ? '...' : buttonText}</span>
                        {!disabled && <span>‚Üí</span>}
                    </div>
                </div>
            </div>
        );
    };

    const availableAvatars = [
        { id: 'avatar1', url: 'avatars/avatar1.png' },
        { id: 'avatar2', url: 'avatars/avatar2.png' },
        { id: 'avatar3', url: 'avatars/avatar3.png' },
        { id: 'avatar4', url: 'avatars/avatar4.png' },
        { id: 'avatar5', url: 'avatars/avatar5.png' },
        { id: 'avatar6', url: 'avatars/avatar6.png' },
        { id: 'avatar7', url: 'avatars/avatar7.png' },
        { id: 'avatar8', url: 'avatars/avatar8.png' },
        { id: 'avatar9', url: 'avatars/avatar9.png' },
        { id: 'avatar10', url: 'avatars/avatar10.png' },
        { id: 'avatar11', url: 'avatars/avatar11.png' },
        { id: 'avatar12', url: 'avatars/avatar12.png' },
        { id: 'avatar13', url: 'avatars/avatar13.png' },
        { id: 'avatar14', url: 'avatars/avatar14.png' },
        { id: 'avatar15', url: 'avatars/avatar15.png' },
        { id: 'avatar16', url: 'avatars/avatar16.png' }

    ];
    function runApp() {
        const loader = document.getElementById('loader');

        const firebaseConfig = {
          apiKey: "AIzaSyC9qRRHO-m3e_2Kfs14wxxjsovhrE3idXs",
          authDomain: "kelime-avla.firebaseapp.com",
          projectId: "kelime-avla",
          storageBucket: "kelime-avla.firebasestorage.app",
          messagingSenderId: "557108031682",
          appId: "1:557108031682:web:a0738215100b2c6b864b5b",
          measurementId: "G-XYCB5BS8SR"
        };

        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }

        ReactDOM.render(<App />, document.getElementById('root'));

        setTimeout(() => {
            if (loader) {
                loader.classList.add('hidden');
            }
        }, 1800);
    }


    function AvatarSelectionModal({ isOpen, onClose, onAvatarSelect }) {
        if (!isOpen) return null;

        return (
            <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}>
                <div
    className="relative bg-gradient-to-br from-slate-50 to-gray-100 p-6 rounded-2xl shadow-2xl w-full max-w-md text-center flex flex-col max-h-[90vh]"
    onClick={e => e.stopPropagation()}
>
                    <h3 className="text-3xl font-black mb-6 text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 flex-shrink-0">
                        Avatarƒ±nƒ± Se√ß
                    </h3>

                    <div className="overflow-y-auto scrollbar-thin flex-1 pr-2 -mr-2">
                        <div className="grid grid-cols-3 sm:grid-cols-4 gap-4">
                            {availableAvatars.map(avatar => (
                                <div key={avatar.id} onClick={() => onAvatarSelect(avatar.id)} className="cursor-pointer group flex flex-col items-center">
                                    <img
                                        src={avatar.url}
                                        alt={avatar.id}
                                        className="w-20 h-20 rounded-full object-cover bg-gray-200 border-4 border-transparent group-hover:border-indigo-500 group-hover:scale-110 group-hover:shadow-lg transition-all duration-200"
                                    />
                                </div>
                            ))}
                        </div>
                    </div>

                    <button
                        onClick={onClose}
                        className="mt-8 bg-slate-200 text-slate-800 font-bold py-2 px-8 rounded-lg hover:bg-slate-300 transition-all flex-shrink-0 shadow-sm"
                    >
                        Kapat
                    </button>
                </div>
            </div>
        );
    }



function ShareButtons({ text, setToastMessage }) {
    const gameUrl = "https://play.google.com/store/apps/details?id=com.ozcelikinc.kelimeavlama";

    const copyLink = () => {
        navigator.clipboard.writeText(gameUrl).then(() => {
            setToastMessage("Link panoya kopyalandƒ±!");
        }, (err) => {
            console.error('Link kopyalanamadƒ±', err);
            setToastMessage("Hata: Link kopyalanamadƒ±.");
        });
    };

    const handleShare = () => {
        const shareContent = `${text} ${gameUrl}`;
        if (window.Android && typeof window.Android.shareGeneric === 'function') {
            window.Android.shareGeneric(shareContent);
        } else {
            alert("Bu √∂zellik sadece uygulamada kullanƒ±labilir.");
        }
    };

    return (
        <div className="w-full mt-6 pt-4 border-t border-white/20 text-center">
            <h4 className="font-bold text-sm text-white/80 mb-3">Sonucu Payla≈ü</h4>
            <div className="flex justify-center items-center gap-3">

                {/* YENƒ∞ VE DAHA G√úZEL PAYLA≈û BUTONU */}
                <button onClick={handleShare} title="Payla≈ü"
                        className="h-12 flex-1 flex items-center justify-center gap-2 bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-bold rounded-full transition-all transform hover:scale-105 shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                        <path strokeLinecap="round" strokeLinejoin="round" d="M8.684 13.342C8.886 12.938 9 12.482 9 12s-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z" />
                    </svg>
                    <span>Payla≈ü</span>
                </button>

                {/* Linki Kopyala Butonu */}
                <button onClick={copyLink} title="Linki Kopyala"
                        className="w-12 h-12 flex-shrink-0 flex items-center justify-center bg-white/10 hover:bg-white/20 rounded-full transition-all transform hover:scale-105">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-6 h-6 text-white">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244" />
                    </svg>
                </button>
            </div>
        </div>
    );
}


const PlayerCard = ({ player, onOpenInviteModal, onSendRequest, onRemoveFriend }) => {
    const isFriend = player.isFriend;
    const onlineStatusColor = player.presence === 'online' ? 'bg-green-400' : 'bg-gray-400';
    const cardBgColor = player.cardColor
        ? playerCardColors.find(c => c.id === player.cardColor)?.class || 'bg-white'
        : 'bg-white';

    return (
        <div className={`p-2 rounded-xl shadow-sm flex items-center gap-3 transition-all hover:shadow-md ${cardBgColor}`}>
            
            <div className="relative flex-shrink-0">
                <img
                    src={player.avatarId ? `avatars/${player.avatarId}.png` : 'avatars/default.png'}
                    alt={player.username}
                    className="w-12 h-12 rounded-full object-cover border-2 border-white shadow"
                />
                <div className={`absolute bottom-0 right-0 w-3 h-3 ${onlineStatusColor} rounded-full border-2 border-white`} title={player.presence}></div>
            </div>

            <div className="flex-1 min-w-0">
                <p className="font-bold text-sm text-slate-800 truncate">{player.username}</p>
                <p className="text-xs text-slate-500">{player.presence === 'online' ? '√áevrimi√ßi' : '√áevrimdƒ±≈üƒ±'}</p>
            </div>

            {/* === BUTON ƒ∞KONLARI EMOJI/KARAKTER ƒ∞LE YENƒ∞LENDƒ∞ === */}
            <div className="flex-shrink-0 flex items-center gap-2">
                {isFriend ? (
                    <button
                        onClick={() => onRemoveFriend(player)}
                        className="w-9 h-9 flex items-center justify-center bg-slate-200 text-slate-600 text-xl font-black rounded-full transition-all duration-200 transform hover:scale-110 hover:bg-red-500 hover:text-white shadow-sm"
                        title="Arkada≈ülƒ±ktan √áƒ±kar"
                    >
                        -
                    </button>
                ) : (
                    <button
                        onClick={() => onSendRequest(player)}
                        className="w-9 h-9 flex items-center justify-center bg-slate-200 text-slate-600 text-xl font-black rounded-full transition-all duration-200 transform hover:scale-110 hover:bg-indigo-500 hover:text-white shadow-sm"
                        title="Arkada≈ü Ekle"
                    >
                       +
                    </button>
                )}
                <button
                    onClick={() => onOpenInviteModal(player)}
                    className="w-9 h-9 flex items-center justify-center bg-slate-200 text-slate-600 text-xl rounded-full transition-all duration-200 transform hover:scale-110 hover:bg-green-500 hover:text-white shadow-sm"
                    title="Oyuna Davet Et"
                >
                    ‚öîÔ∏è
                </button>
            </div>
        </div>
    );
};

function ProfileModal({ isOpen, onClose, username, avatarId, cardColor, gold, unlockedAvatars, unlockedColors, onAvatarSelect, onUsernameUpdate, onColorSelect, onPurchaseItem, language }) {
    if (!isOpen) return null;
    
    const t = translations[language] || translations['en'];
    const [newUsername, setNewUsername] = React.useState(username);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div
                className="relative bg-gradient-to-br from-slate-50 to-gray-100 p-6 rounded-2xl shadow-2xl w-full max-w-md text-center flex flex-col max-h-[90vh]"
                onClick={e => e.stopPropagation()}
            >
                <div className="absolute top-4 right-4 bg-amber-100 text-amber-800 text-lg font-bold px-4 py-2 rounded-full shadow-md flex items-center gap-2">
                    <span>üí∞</span>
                    <span>{gold}</span>
                </div>

                <h3 className="text-3xl font-black mb-4 text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 flex-shrink-0">{t.profileTitle}</h3>

                <div className="mb-6 flex-shrink-0">
                    <label className="block text-sm font-bold text-slate-700 mb-2">{t.changeUsernameLabel}</label>
                    <div className="flex gap-2">
                        <input
                            type="text"
                            value={newUsername}
                            onChange={(e) => setNewUsername(e.target.value)}
                            className="flex-1 border-2 border-slate-300 p-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400"
                            maxLength={15}
                            placeholder={t.newUsernamePlaceholder}
                        />
                        <button
                            onClick={() => onUsernameUpdate(newUsername)}
                            className="px-4 py-2 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition-colors shadow-md"
                        >
                            {t.saveButton}
                        </button>
                    </div>
                </div>

                <div className="flex-1 min-h-0 overflow-y-auto scrollbar-thin pr-2 -mr-4">
                    <div className="mb-6 border-t pt-4">
                        <label className="block text-sm font-bold text-slate-700 mb-3">{t.selectCardColorLabel}</label>
                        <div className="flex flex-wrap justify-center gap-3">
                            {playerCardColors.map(color => {
                                const isUnlocked = (unlockedColors || []).includes(color.id);
                                const cost = 2;

                                return (
                                    <div key={color.id} className="flex flex-col items-center gap-1">
                                        <div
                                            onClick={() => isUnlocked ? onColorSelect(color.id) : onPurchaseItem('color', color.id, cost)}
                                            title={isUnlocked ? color.name : t.unlockForGold(cost)}
                                            className={`relative w-10 h-10 rounded-full cursor-pointer ${color.class} border-4 transition-all hover:scale-110 shadow-md ${cardColor === color.id ? 'border-green-500 scale-110 ring-2 ring-offset-2 ring-green-500' : 'border-transparent'}`}
                                        >
                                            {!isUnlocked && (
                                                <div className="absolute inset-0 rounded-full flex items-center justify-center bg-black/20">
                                                    <span className="text-2xl text-white drop-shadow-md">üîí</span>
                                                </div>
                                            )}
                                        </div>
                                        {!isUnlocked && <span className="text-xs font-bold text-amber-600 bg-amber-100 px-1.5 py-0.5 rounded-full">{cost}üí∞</span>}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    <div className="border-t pt-4">
                        <label className="block text-sm font-bold text-slate-700 mb-4">{t.changeAvatarLabel}</label>
                        <div className="grid grid-cols-4 sm:grid-cols-5 gap-4">
                            {availableAvatars.map(avatar => {
                                const isUnlocked = (unlockedAvatars || []).includes(avatar.id);
                                const cost = 5;

                                return (
                                    <div key={avatar.id} onClick={() => isUnlocked ? onAvatarSelect(avatar.id) : onPurchaseItem('avatar', avatar.id, cost)} className="cursor-pointer group flex flex-col items-center gap-1">
                                        <div className="relative" title={isUnlocked ? '' : t.unlockForGold(cost)}>
                                            <img
                                                src={avatar.url}
                                                alt={avatar.id}
                                                className={`w-16 h-16 rounded-full object-cover bg-gray-200 border-4 transition-all duration-200 shadow-md ${avatarId === avatar.id ? 'border-green-500 scale-110' : 'border-transparent'} group-hover:border-indigo-500 group-hover:scale-110`}
                                            />
                                            {!isUnlocked && (
                                                <div className="absolute inset-0 rounded-full flex items-center justify-center bg-black/20">
                                                    <span className="text-3xl text-white drop-shadow-md">üîí</span>
                                                </div>
                                            )}
                                        </div>
                                        {!isUnlocked && <span className="text-xs font-bold text-amber-600 bg-amber-100 px-1.5 py-0.5 rounded-full mt-1">{cost}üí∞</span>}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>

                <button onClick={onClose} className="mt-6 bg-slate-200 text-slate-800 font-bold py-2 px-8 rounded-lg hover:bg-slate-300 transition-all shadow-sm flex-shrink-0">
                    {t.closeButton}
                </button>
            </div>
        </div>
    );
}


function FriendRequestModal({ isOpen, requestDetails, onAccept, onDecline }) {
        if (!isOpen || !requestDetails) return null;

        return (
            <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
                <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-sm text-center">
                    <h3 className="text-2xl font-bold mb-2 text-gray-800">Arkada≈ülƒ±k ƒ∞steƒüi</h3>
                    <p className="text-gray-600 text-lg mb-6">
                        <span className="font-bold text-indigo-600">{requestDetails.from}</span> seni arkada≈ü olarak eklemek istiyor.
                    </p>
                    <div className="flex justify-center gap-4 mt-4">
                        <button onClick={onDecline} className="px-8 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Reddet</button>
                        <button onClick={onAccept} className="px-8 py-3 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700">Kabul Et</button>
                    </div>
                </div>
            </div>
        );
    }

function RoomCreateModal({ isOpen, onClose, onCreate }) {
    if (!isOpen) return null;

    const [maxPlayers, setMaxPlayers] = React.useState(3);
    const [boardSize, setBoardSize] = React.useState('medium');
    const [difficulty, setDifficulty] = React.useState('easy');

    const handleCreateClick = () => {
        onCreate({ maxPlayers, boardSize, difficulty });
        onClose();
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-sm" onClick={e => e.stopPropagation()}>
                <h3 className="text-2xl font-bold mb-6 text-gray-800 text-center">Yeni Oda Kur</h3>
                <div className="space-y-6">
                    <div>
                        <label className="block text-lg font-semibold text-slate-700 mb-3">Oyuncu Sayƒ±sƒ±</label>
                        <div className="grid grid-cols-2 gap-3">
                            <button onClick={() => setMaxPlayers(3)} className={`p-4 font-bold rounded-xl transition-all transform ${maxPlayers === 3 ? 'bg-indigo-600 text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 hover:bg-slate-300'}`}>3 Oyuncu</button>
                            <button onClick={() => setMaxPlayers(4)} className={`p-4 font-bold rounded-xl transition-all transform ${maxPlayers === 4 ? 'bg-indigo-600 text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 hover:bg-slate-300'}`}>4 Oyuncu</button>
                        </div>
                    </div>
                    <div>
                        <h4 className="font-semibold text-lg text-slate-700 mb-3">Zorluk Seviyesi</h4>
                        <div className="grid grid-cols-2 gap-3">
                            <button onClick={() => setDifficulty('easy')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${difficulty === 'easy' ? 'bg-gradient-to-br from-green-400 to-emerald-500 text-white ring-4 ring-offset-2 ring-green-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">üß∏</span> <span className="mt-1 text-sm">Kolay</span> </button>
                            <button onClick={() => setDifficulty('hard')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${difficulty === 'hard' ? 'bg-gradient-to-br from-red-500 to-rose-600 text-white ring-4 ring-offset-2 ring-red-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">üî•</span> <span className="mt-1 text-sm">Zor</span> </button>
                        </div>
                    </div>
                    <div>
                        <h4 className="font-semibold text-lg text-slate-700 mb-3">Oyun Alanƒ± Boyutu</h4>
                        <div className="grid grid-cols-3 gap-3">
                            <button onClick={() => setBoardSize('small')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${boardSize === 'small' ? 'bg-gradient-to-br from-gray-400 to-gray-500 text-white ring-4 ring-offset-2 ring-gray-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">ü§è</span> <span className="mt-1 text-xs">K√º√ß√ºk</span> </button>
                            <button onClick={() => setBoardSize('medium')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${boardSize === 'medium' ? 'bg-gradient-to-br from-sky-500 to-blue-600 text-white ring-4 ring-offset-2 ring-sky-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">üëå</span> <span className="mt-1 text-xs">Orta</span> </button>
                            <button onClick={() => setBoardSize('large')} className={`py-3 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${boardSize === 'large' ? 'bg-gradient-to-br from-purple-500 to-violet-600 text-white ring-4 ring-offset-2 ring-purple-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}> <span className="text-3xl">üëê</span> <span className="mt-1 text-xs">Geni≈ü</span> </button>
                        </div>
                    </div>
                </div>
                <button onClick={handleCreateClick} className="w-full mt-8 bg-green-500 text-white font-bold py-3 rounded-lg hover:bg-green-600 transition-all text-lg">Odayƒ± Olu≈ütur</button>
            </div>
        </div>
    );
}


function AccordionSection({ title, isOpen, onToggle, children, badgeCount, icon, colorClasses }) {
    const headerColor = colorClasses || 'bg-white';

    return (
        <div className="rounded-xl bg-white/70 backdrop-blur-sm shadow-md overflow-hidden transition-all duration-300">
            <button onClick={onToggle} className={`w-full flex justify-between items-center p-4 text-left font-bold transition-colors ${headerColor}`}>
                <span className="flex items-center gap-3">
                    {/* ƒ∞konun yazƒ± boyutu b√ºy√ºt√ºld√º */}
                    {icon && <div className="w-8 h-8 flex items-center justify-center rounded-lg bg-white/50 text-xl">{icon}</div>}
                    <span className="text-lg">{title}</span>
                </span>
                <span className="flex items-center gap-3">
                    {badgeCount > 0 && <span className="bg-indigo-500 text-white text-xs font-bold px-2.5 py-1 rounded-full">{badgeCount}</span>}
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={`w-6 h-6 transition-transform ${isOpen ? 'transform rotate-180' : ''}`}>
                        <path fillRule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clipRule="evenodd" />
                    </svg>
                </span>
            </button>
            {isOpen && (
                <div className="relative p-4 border-t border-slate-200/50">
                    <button onClick={onToggle} className="absolute top-2 right-2 text-slate-400 hover:text-slate-600 p-1 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-5 h-5"><path d="M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z" /></svg>
                    </button>
                    {children}
                </div>
            )}
        </div>
    );
}


function DuelLobbyPage({ username, onBack, db, setToastMessage, joinGameRoom, createGameRoom, sendDirectInvite }) {



    const [openSection, setOpenSection] = React.useState('lobi');
    const [gameRooms, setGameRooms] = React.useState([]);
    const [onlineUsers, setOnlineUsers] = React.useState([]);
    const [allUsers, setAllUsers] = React.useState([]);
    const [friends, setFriends] = React.useState([]);
    const [loading, setLoading] = React.useState(true);
    const [isCreateModalOpen, setCreateModalOpen] = React.useState(false);
    const [invitePlayer, setInvitePlayer] = React.useState(null);
    const [confirmAction, setConfirmAction] = React.useState({ isOpen: false });

    React.useEffect(() => {
        if (!db || !username) return;
        const usersUnsubscribe = db.collection('users').onSnapshot(usersSnapshot => {
            const friendsSubUnsubscribe = db.collection('users').doc(username).collection('friends').onSnapshot(friendsSnapshot => {
                const lobbyUnsubscribe = db.collection('lobby').onSnapshot(lobbySnapshot => {
                    const presenceMap = new Map();
                    lobbySnapshot.docs.forEach(doc => presenceMap.set(doc.id, doc.data().presence || 'offline'));
                    const friendUsernames = new Set(friendsSnapshot.docs.map(doc => doc.id));
                    const allUsersData = usersSnapshot.docs
                        .map(doc => {
                            const data = doc.data();
                            return {
                                username: doc.id,
                                avatarId: data.avatarId,
                                cardColor: data.cardColor,
                                presence: presenceMap.get(doc.id) || 'offline',
                                isFriend: friendUsernames.has(doc.id)
                            };
                        })
                        .filter(u => u.username !== username);
                    setAllUsers(allUsersData);
                    setFriends(allUsersData.filter(u => u.isFriend));
                    setOnlineUsers(allUsersData.filter(u => u.presence === 'online'));
                    setLoading(false);
                });
                return () => lobbyUnsubscribe();
            });
            return () => friendsSubUnsubscribe();
        });
        const roomsUnsubscribe = db.collection('game_rooms').where('status', '==', 'waiting')
            .onSnapshot(snapshot => setGameRooms(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))));
        
        return () => { roomsUnsubscribe(); usersUnsubscribe(); };
    }, [db, username]);

    const handleSendFriendRequest = async (targetPlayer) => {
        const requestRef = db.collection('users').doc(targetPlayer.username).collection('friendRequests').doc(username);
        try {
            await requestRef.set({ from: username, timestamp: firebase.firestore.FieldValue.serverTimestamp() });
            setToastMessage(`${targetPlayer.username} ki≈üisine arkada≈ülƒ±k isteƒüi g√∂nderildi!`);
        } catch (error) {
            setToastMessage("Hata: ƒ∞stek g√∂nderilemedi.");
        }
    };

    const handleRemoveFriend = (targetPlayer) => {
        setConfirmAction({
            isOpen: true,
            title: "Arkada≈ülƒ±ktan √áƒ±kar",
            bodyText: `<b>${targetPlayer.username}</b> ki≈üisini arkada≈ülƒ±ktan √ßƒ±karmak istediƒüinize emin misiniz?`,
            onConfirm: async () => {
                const currentUserFriendsRef = db.collection('users').doc(username).collection('friends').doc(targetPlayer.username);
                const targetUserFriendsRef = db.collection('users').doc(targetPlayer.username).collection('friends').doc(username);
                await Promise.all([currentUserFriendsRef.delete(), targetUserFriendsRef.delete()]);
                setToastMessage(`${targetPlayer.username} arkada≈ülƒ±ktan √ßƒ±karƒ±ldƒ±.`);
                setConfirmAction({ isOpen: false });
            }
        });
    };

    const PlayerList = ({ players }) => {
        if (!players || players.length === 0) return <p className="text-center text-slate-500 py-4">Burada kimse yok.</p>;
        return (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-2 max-h-96 overflow-y-auto scrollbar-thin p-1">
                {players.map(player => (
                    <PlayerCard
                        key={player.username}
                        player={player}
                        onSendRequest={handleSendFriendRequest}
                        onRemoveFriend={handleRemoveFriend}
                        onOpenInviteModal={setInvitePlayer}
                    />
                ))}
            </div>
        );
    };

    const RoomList = ({ rooms }) => {
        if (rooms.length === 0) {
            return <p className="text-center text-slate-500 py-4">Aktif oyun odasƒ± bulunmuyor.</p>;
        }
        return (
            <div className="space-y-3 max-h-96 overflow-y-auto scrollbar-thin">
                {rooms.map(room => {
                     const playerCount = Object.keys(room.players).length;
                     const isFull = playerCount >= room.gameSettings.maxPlayers;
                     return (
                         <div key={room.id} className="bg-white p-3 rounded-lg shadow flex items-center justify-between">
                             <div>
                                <p className="font-bold text-slate-800">{room.host}'un Odasƒ±</p>
                                <p className="text-sm text-slate-500">
                                    {playerCount} / {room.gameSettings.maxPlayers} Oyuncu
                                </p>
                             </div>
                             <button onClick={() => joinGameRoom(room.id)} disabled={isFull} className="bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 disabled:bg-gray-400">
                                 {isFull ? 'Dolu' : 'Katƒ±l'}
                             </button>
                         </div>
                     );
                })}
            </div>
        );
    };

    const handleToggle = (section) => setOpenSection(prev => (prev === section ? null : section));
    
    return (
        <>
            <div className="h-full w-full bg-gradient-to-br from-indigo-50 to-purple-100 flex flex-col">
                <div className="container mx-auto px-4 pt-3 flex flex-col flex-1">
                    <header className="my-2 flex-shrink-0 flex items-center justify-between">
                        <button onClick={onBack} className="bg-white/80 border border-slate-200 text-slate-600 px-4 py-2 rounded-lg font-semibold hover:bg-white">Geri</button>
                        <h1 className="text-3xl font-black text-slate-700">Oyun Lobisi</h1>
                        <div className="w-20"></div>
                    </header>

                     {loading ? <p className="text-center mt-10">Y√ºkleniyor...</p> : (
                        <div className="flex-1 min-h-0 overflow-y-auto scrollbar-thin py-4 space-y-3">
                            
                            {/* ƒ∞konlar artƒ±k component deƒüil, doƒürudan emoji */}
                            <AccordionSection 
                                title="Lobi" 
                                isOpen={openSection === 'lobi'} 
                                onToggle={() => handleToggle('lobi')} 
                                badgeCount={gameRooms.length}
                                icon="üéÆ"
                                colorClasses="bg-gradient-to-r from-purple-200 to-indigo-200 text-indigo-900 font-extrabold"
                            >
                                <div className="text-center">
                                    <button onClick={() => setCreateModalOpen(true)} className="w-full mb-4 bg-indigo-600 text-white px-4 py-3 rounded-lg font-semibold hover:bg-indigo-700 transition-colors shadow-lg">
                                        + Yeni Oda Kur
                                    </button>
                                    <RoomList rooms={gameRooms} />
                                </div>
                            </AccordionSection>

                            <AccordionSection 
                                title="≈ûu Anda Online" 
                                isOpen={openSection === 'online'} 
                                onToggle={() => handleToggle('online')} 
                                badgeCount={onlineUsers.length}
                                icon="üü¢"
                                colorClasses="text-green-800"
                            >
                                <PlayerList players={onlineUsers} />
                            </AccordionSection>
                            
                            <AccordionSection 
                                title="Arkada≈ülar" 
                                isOpen={openSection === 'arkadaslar'} 
                                onToggle={() => handleToggle('arkadaslar')} 
                                badgeCount={friends.length}
                                icon="‚ù§Ô∏è"
                                colorClasses="text-sky-800"
                            >
                                <PlayerList players={friends} />
                            </AccordionSection>

                            <AccordionSection 
                                title="T√ºm Kullanƒ±cƒ±lar" 
                                isOpen={openSection === 'kullanicilar'} 
                                onToggle={() => handleToggle('kullanicilar')} 
                                badgeCount={allUsers.length}
                                icon="üåç"
                                colorClasses="text-slate-800"
                            >
                                <PlayerList players={allUsers} />
                            </AccordionSection>
                        </div>
                    )}
                </div>
            </div>
            <RoomCreateModal isOpen={isCreateModalOpen} onClose={() => setCreateModalOpen(false)} onCreate={createGameRoom} />
            <DuelInviteModal isOpen={!!invitePlayer} onClose={() => setInvitePlayer(null)} player={invitePlayer} onInvite={sendDirectInvite} />
            <ConfirmationModal 
                isOpen={confirmAction.isOpen} 
                onClose={() => setConfirmAction({ isOpen: false })} 
                onConfirm={confirmAction.onConfirm}
                title={confirmAction.title}
                bodyText={confirmAction.bodyText}
            />
        </>
    );
}


    

    

    const servers = {
          iceServers: [
            {
              urls: [
                'stun:stun1.l.google.com:19302',
                'stun:stun2.l.google.com:19302',
              ],
            },
          ],
          iceCandidatePoolSize: 10,
        };

    let peerConnection = null;
    let dataChannel = null;

    const firebaseConfig = {
      apiKey: "AIzaSyC9qRRHO-m3e_2Kfs14wxxjsovhrE3idXs",
      authDomain: "kelime-avla.firebaseapp.com",
      projectId: "kelime-avla",
      storageBucket: "kelime-avla.firebasestorage.app",
      messagingSenderId: "557108031682",
      appId: "1:557108031682:web:a0738215100b2c6b864b5b",
      measurementId: "G-XYCB5BS8SR"
    };

    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }
    const db = firebase.firestore();
    const ALL_SAVES_KEY = 'wordHuntAllSaves';

    window.onerror = function (msg, url, lineNo, columnNo, error) { console.error(`Global error: ${msg}\nURL: ${url}\nLine: ${lineNo}\nColumn: ${columnNo}\nError:`, error); const root = document.getElementById('root'); if (root) root.innerHTML = `<div class="p-4 text-red-600">Beklenmedik bir hata olu≈ütu. L√ºtfen sayfayƒ± yenileyin. Hata: ${msg}</div>`; return false; };
    function customToUpperCase(str) { if (typeof str !== 'string') return ''; try { return str.replace(/i/g, 'ƒ∞').replace(/ƒ±/g, 'I').replace(/ƒü/g, 'ƒû').replace(/√º/g, '√ú').replace(/≈ü/g, '≈û').replace(/√∂/g, '√ñ').replace(/√ß/g, '√á').toUpperCase(); } catch (err) { console.error('customToUpperCase hatasƒ±:', err); return (str || '').toUpperCase(); } }
    class ErrorBoundary extends React.Component { state = { hasError: false }; static getDerivedStateFromError(error) { return { hasError: true }; } componentDidCatch(error, errorInfo) { console.error("ErrorBoundary yakaladƒ±:", error, errorInfo); } render() { if (this.state.hasError) { return <div className="p-4 text-red-600">Beklenmedik bir hata olu≈ütu. L√ºtfen sayfayƒ± yenileyin.</div>; } return this.props.children; } }

    const vibrate = (pattern) => { if ('vibrate' in navigator) { if (pattern === 'success') navigator.vibrate(50); else if (pattern === 'error') navigator.vibrate([100, 50, 100]); else if (pattern === 'achievement') navigator.vibrate([100, 50, 100, 50, 100]); else if (typeof pattern === 'number') navigator.vibrate(pattern); } };



const wordFoundColors = [
    { bg: 'bg-rose-200', text: 'text-rose-800' },
    { bg: 'bg-amber-200', text: 'text-amber-800' },
    { bg: 'bg-emerald-200', text: 'text-emerald-800' },
    { bg: 'bg-sky-200', text: 'text-sky-800' },
    { bg: 'bg-indigo-200', text: 'text-indigo-800' },
    { bg: 'bg-violet-200', text: 'text-violet-800' },
];

    const getInitialTime = (currentMode, currentLevel) => {
        if (!currentMode.startsWith('timed')) return 120;
        let baseTime = currentMode === 'timed-hard' ? 180 : 120;
        return baseTime + (currentLevel * 4);
    };


    const achievementsList = {
        'level_10': {icon: 'üéì',title: 'Acemi Ka≈üif',description: '10. seviyeye ula≈ü.',isUnlocked: (stats) => stats.maxLevelCompleted >= 9},
        'level_25': {icon: 'üó∫Ô∏è',title: 'Deneyimli Gezgin',description: '25. seviyeye ula≈ü.',isUnlocked: (stats) => stats.maxLevelCompleted >= 24},
        'level_50': {icon: 'üèÜ',title: 'Usta Maceracƒ±',description: '50. seviyeye ula≈ü.',isUnlocked: (stats) => stats.maxLevelCompleted >= 49},
        'super_easy_win': {icon: 'üß∏',title: 'Park Gezintisi',description: 'A≈üƒ±rƒ± Kolay modda bir seviye tamamla.',
        isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['super-easy']    },
        'easy_win': {icon: 'üòä',title: 'Tanƒ±dƒ±k Yollar',description: 'Kolay modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['easy']    },
        'hard_mode_win': {icon: 'üî•',title: 'Ate≈üle Oynayan',description: 'Zor modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['hard']},
        'timed_easy_win': {icon: '‚è±Ô∏è',title: 'Zamana Kar≈üƒ±',description: 'S√ºreli Kolay modda bir seviye tamamla.',isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['timed-easy']},
        'timed_hard_win': {        icon: '‚ö°',        title: '≈ûim≈üek Hƒ±zƒ±',        description: 'S√ºreli Zor modda bir seviye tamamla.',
    isUnlocked: (stats) => stats.modesCompleted && stats.modesCompleted['timed-hard']    },
        'score_10000': {
            icon: 'üí∞',
            title: 'Puan Koleksiyoncusu',
            description: 'Herhangi bir modda 10,000 puana ula≈ü.',
            isUnlocked: (stats) => Object.values(stats.highScores).some(score => score >= 10000)
        },
        'gold_50': {
            icon: 'üíé',
            title: 'Altƒ±n Madencisi',
            description: 'Toplamda 50 altƒ±n biriktir.',
            isUnlocked: (stats) => stats.gold >= 50
        }
    };

    function AchievementsList({ stats, language }) {
        const t = translations[language] || translations['en'];
        return (
            <div className="text-left overflow-y-auto max-h-[60vh] mt-4 pr-2 scrollbar-thin">
                <ul className="space-y-3">
                    {Object.values(achievementsList).map((ach, index) => {
                        const unlocked = ach.isUnlocked(stats);
                        return (
                            <li
                                key={index}
                                className={`flex items-center p-4 rounded-lg transition-all ${unlocked ? 'bg-green-100 dark:bg-green-800/30' : 'bg-gray-100 dark:bg-gray-800 opacity-60'}`}
                            >
                                <span className={`text-4xl mr-4 ${unlocked ? '' : 'grayscale'}`}>{ach.icon}</span>
                                <div className="flex-1">
                                    <p className={`font-bold text-gray-800 dark:text-gray-100 ${unlocked ? '' : 'text-gray-500'}`}>{ach.title}</p>
                                    <p className={`text-sm text-gray-600 dark:text-gray-400 ${unlocked ? '' : 'text-gray-500'}`}>{ach.description}</p>
                                </div>
                                {unlocked && (
                                    <span className="text-3xl text-green-500">‚úì</span>
                                )}
                            </li>
                        );
                    })}
                </ul>
            </div>
        );
    }

   const translations = {
        tr: {
            // Ana Sayfa & Genel
            title: "Kelime Avƒ±",
            homePageSubtitle: "Kelime dehasƒ± olmaya hazƒ±r mƒ±sƒ±n?",
            leaderboardButton: "Liderlik Tablosu",
            achievementsButton: "Ba≈üarƒ±lar",
            footerText: "¬© 2025 Ozcelik Inc.",
            languageSwitch: "üá¨üáß English",
            lobbyTitle: "√áok Oyunculu",
            lobbyDescription: "Arkada≈ülarƒ±nla veya diƒüer oyuncularla yarƒ±≈ü",
            vsAiTitle: "Yapay Zekaya Kar≈üƒ±",
            vsAiDescription: "Bilgisayara kar≈üƒ± kelime bulma yeteneƒüini sƒ±na",
            wordHuntTitle: "Kelime Avƒ± Klasik",
            wordHuntDescription: "Harflerin arasƒ±na gizlenmi≈ü kelimeleri bul",
            wordTrackingTitle: "Kelime Takibi",
            wordTrackingDescription: "Harfleri birle≈ütirerek yƒ±lan gibi kelimeler olu≈ütur",
            loading: "Y√ºkleniyor...",
            // Mod ƒ∞simleri
            √ßok: "√áOK", a≈üƒ±rƒ±: "A≈ûIRI", kolay: "KOLAY", normal: "NORMAL", zor: "ZOR", s√ºreli: "S√úRELƒ∞",
            superEasyMode: "√áOK KOLAY", easyMode: "KOLAY", hardMode: "ZOR", timedEasyMode: "S√úRELƒ∞ KOLAY", timedHardMode: "S√úRELƒ∞ ZOR", randomMode: "RASTGELE",
            // Oyun ƒ∞√ßi
            level: "Seviye", score: "Puan", gold: "Altƒ±n", time: "S√ºre", noTimeLimit: "S√ºresiz",
            hiddenWord: "Gizli S√∂zc√ºk", checkButton: "Kontrol Et", homeButton: "Anasayfa", nextLevelButton: "Sonraki Seviye ‚Üí",
            congrats: "Tebrikler!", levelCompleted: "Seviye Tamamlandƒ±!",
            timeUp: "S√ºre Bitti!", finalScore: (score) => `Skorunuz: ${score}`, earnedGold: "Kazanƒ±lan Altƒ±n",
            totalScore: "Toplam Puan", returnToHome: "Anasayfa'ya D√∂n", hint: "ƒ∞pucu", reveal: "A√ß",
            // Modallar & Uyarƒ±lar
            areYouSureTitle: "Emin misin?",
            quitGameBody: "Ana men√ºye d√∂nmek istediƒüine emin misin? Mevcut ilerlemen kaydedildi.",
            appQuitBody: "Uygulamadan √ßƒ±kmak istediƒüinize emin misiniz?",
            stayButton: "Hayƒ±r", quitButton: "Evet",
            savedGameFoundTitle: "Kayƒ±tlƒ± Oyun Bulundu",
            savedGameFoundBody: (level) => `Bu modda <span class="font-bold">Seviye ${level}</span>'de kayƒ±tlƒ± bir oyununuz mevcut. Ne yapmak istersiniz?`,
            continueButton: "Evet, Devam Et",
            newGameButton: "Hayƒ±r, Yeni Oyun Ba≈ülat",
randomGameTitle: "üêü Rastgele Oyun üêü",
            randomGameBody: (mode, level) => `Sizin i√ßin <span class="font-bold">${mode}</span> modunda, <span class="font-bold">Seviye ${level}</span> hazƒ±rlandƒ±. Bu oyun kaydedilmez.`,
startButton: "Ba≈üla!",
            closeButton: "Kapat",
            welcome: "Oyuna Ho≈ü Geldin!",
            usernamePrompt: "Liderlik tablosu i√ßin benzersiz bir kullanƒ±cƒ± adƒ± belirle.",
            usernamePlaceholder: "Kullanƒ±cƒ± adƒ±nƒ±z...",
            checking: "Kontrol ediliyor...",
            saveAndStart: "Kaydet ve Ba≈üla",
            usernameTaken: "Bu kullanƒ±cƒ± adƒ± zaten alƒ±nmƒ±≈ü. L√ºtfen ba≈üka bir tane deneyin.",
            profileTitle: "Profilin",
            changeUsernameLabel: "Kullanƒ±cƒ± Adƒ±nƒ± Deƒüi≈ütir",
            saveButton: "Kaydet",
            newUsernamePlaceholder: "Yeni kullanƒ±cƒ± adƒ±n...",
            selectCardColorLabel: "Kart Rengini Se√ß",
            changeAvatarLabel: "Avatarƒ±nƒ± Deƒüi≈ütir",
            unlockForGold: (cost) => `Kilidi a√ßmak i√ßin ${cost} altƒ±n`,
            gameLobby: "Oyun Lobisi", backButton: "Geri", createRoom: "+ Yeni Oda Kur",
            onlineNow: "≈ûu Anda Online", friends: "Arkada≈ülar", allUsers: "T√ºm Kullanƒ±cƒ±lar",
            waitingForPlayers: "Oyuncularƒ±n katƒ±lmasƒ±nƒ± bekliyorsun...", waitingForHost: "Oyunun ba≈ülamasƒ± bekleniyor...",
            startGameButton: "Oyunu Ba≈ülat", waitingForPlayer: "Oyuncu Bekleniyor", leaveRoomButton: "Odadan Ayrƒ±l",
            hostsRoom: (host) => `${host}'un Odasƒ±`,
            noRooms: "Aktif oyun odasƒ± bulunmuyor.",
            noUsers: "Burada kimse yok.",
            join: "Katƒ±l",
            full: "Dolu",
            challenge: "Meydan Oku",
            setupGameFor: (player) => `${player} i√ßin oyun kur`,
            difficulty: "Zorluk Seviyesi",
            easyDesc: "Kelimeler g√∂r√ºn√ºr",
            hardDesc: "Kelimeler gizli",
            boardSize: "Oyun Alanƒ± Boyutu",
            smallArea: "K√º√ß√ºk Alan",
            mediumArea: "Orta Alan",
            largeArea: "Geni≈ü Alan",
            friendRequest: "Arkada≈ülƒ±k ƒ∞steƒüi",
            wantsToBeFriend: (user) => `${user} seni arkada≈ü olarak eklemek istiyor.`,
            accept: "Kabul Et",
            decline: "Reddet",
            duelChallenge: "Meydan Okuma",
            invitedToGame: (user) => `${user} seni √∂zel bir oyuna davet ediyor!`,
            removeFriend: "Arkada≈ülƒ±ktan √áƒ±kar",
            removeFriendConfirm: (user) => `<b>${user}</b> ki≈üisini arkada≈ülƒ±ktan √ßƒ±karmak istediƒüinize emin misiniz?`,
            // Toast Mesajlarƒ±
            linkCopied: "Link panoya kopyalandƒ±!",
            copyFail: "Hata: Link kopyalanamadƒ±.",
            androidOnly: "Bu √∂zellik sadece uygulamada kullanƒ±labilir.",
            insufficientGold: "Yetersiz altƒ±n!",
            purchaseSuccess: "Ba≈üarƒ±yla satƒ±n alƒ±ndƒ±!",
            purchaseFail: "Bir hata olu≈ütu.",
            avatarUpdated: "Avatarƒ±n ba≈üarƒ±yla g√ºncellendi!",
            avatarUpdateFail: "Hata: Avatar g√ºncellenemedi.",
            colorUpdated: "Kart rengin g√ºncellendi!",
            usernameUpdated: "Kullanƒ±cƒ± adƒ±n ba≈üarƒ±yla g√ºncellendi!",
            usernameUpdateFail: "Hata: Kullanƒ±cƒ± adƒ± g√ºncellenemedi.",
            friendRequestSent: (user) => `${user} ki≈üisine arkada≈ülƒ±k isteƒüi g√∂nderildi!`,
            friendRequestFail: "Hata: ƒ∞stek g√∂nderilemedi.",
            friendRemoved: (user) => `${user} arkada≈ülƒ±ktan √ßƒ±karƒ±ldƒ±.`,
            friendRequestAccepted: (user) => `${user} ile arkada≈ü oldunuz!`,
            requestAcceptFail: "ƒ∞stek kabul edilemedi:",
            inviteSent: "Davet g√∂nderildi!",
            inviteFail: "Hata: Davet g√∂nderilemedi.",
            inviteDeclined: "Davet reddedildi.",
        },
        en: {
            // Homepage & General
            title: "Word Hunt", homePageSubtitle: "Ready to become a word genius?",
            leaderboardButton: "Leaderboard", achievementsButton: "Achievements",
            footerText: "¬© 2025 Ozcelik Inc.", languageSwitch: "üáπüá∑ T√ºrk√ße",
            lobbyTitle: "Multiplayer", lobbyDescription: "Compete with friends or other players",
            vsAiTitle: "Versus AI", vsAiDescription: "Test your word finding skills against the computer",
            wordHuntTitle: "Word Hunt Classic", wordHuntDescription: "Find the words hidden among the letters",
            wordTrackingTitle: "Word Tracking", wordTrackingDescription: "Create snake-like words by connecting letters",
            loading: "Loading...",
            // Mode Names
            √ßok: "SUPER", a≈üƒ±rƒ±: "SUPER", kolay: "EASY", normal: "NORMAL", zor: "HARD", s√ºreli: "TIMED",
            superEasyMode: "SUPER EASY", easyMode: "EASY", hardMode: "HARD",
            timedEasyMode: "TIMED EASY", timedHardMode: "TIMED HARD", randomMode: "RANDOM",
            // In-Game
            level: "Level", score: "Score", gold: "Gold", time: "Time", noTimeLimit: "No Limit",
            hiddenWord: "Hidden Word", checkButton: "Check", homeButton: "Homepage", nextLevelButton: "Next Level ‚Üí",
            congrats: "Congratulations!", levelCompleted: "Level Complete!",
            timeUp: "Time's Up!", finalScore: (score) => `Your Score: ${score}`, earnedGold: "Gold Earned",
            totalScore: "Total Score", returnToHome: "Return to Homepage", hint: "Hint", reveal: "Reveal",
            // Modals & Alerts
            areYouSureTitle: "Are you sure?",
            quitGameBody: "Are you sure you want to return to the main menu? Your current progress has been saved.",
            appQuitBody: "Are you sure you want to exit the application?",
            stayButton: "No", quitButton: "Yes",
            savedGameFoundTitle: "Saved Game Found",
            savedGameFoundBody: (level) => `You have a saved game in this mode at <span class="font-bold">Level ${level}</span>. What would you like to do?`,
            continueButton: "Yes, Continue", newGameButton: "No, Start New Game",
randomGameTitle: "üéÅ Random Game üéÅ",
            randomGameBody: (mode, level) => `A game in <span class="font-bold">${mode}</span> mode, <span class="font-bold">Level ${level}</span> has been prepared for you. This game will not be saved.`,
startButton: "Start!",
            closeButton: "Close",
            welcome: "Welcome to the Game!",
            usernamePrompt: "Set a unique username for the leaderboard.",
            usernamePlaceholder: "Your username...",
            checking: "Checking...",
            saveAndStart: "Save and Start",
            usernameTaken: "This username is already taken. Please try another one.",
            profileTitle: "Your Profile",
            changeUsernameLabel: "Change Username",
            saveButton: "Save",
            newUsernamePlaceholder: "Your new username...",
            selectCardColorLabel: "Select Card Color",
            changeAvatarLabel: "Change Your Avatar",
            unlockForGold: (cost) => `Unlock for ${cost} gold`,
            gameLobby: "Game Lobby", backButton: "Back", createRoom: "+ Create New Room",
            onlineNow: "Online Now", friends: "Friends", allUsers: "All Users",
            waitingForPlayers: "Waiting for players to join...", waitingForHost: "Waiting for the host to start...",
            startGameButton: "Start Game", waitingForPlayer: "Waiting for Player", leaveRoomButton: "Leave Room",
            hostsRoom: (host) => `${host}'s Room`,
            noRooms: "There are no active game rooms.",
            noUsers: "Nobody is here.",
            join: "Join",
            full: "Full",
            challenge: "Challenge",
            setupGameFor: (player) => `Setup game for ${player}`,
            difficulty: "Difficulty",
            easyDesc: "Words are visible",
            hardDesc: "Words are hidden",
            boardSize: "Board Size",
            smallArea: "Small Area",
            mediumArea: "Medium Area",
            largeArea: "Large Area",
            friendRequest: "Friend Request",
            wantsToBeFriend: (user) => `${user} wants to be your friend.`,
            accept: "Accept",
            decline: "Decline",
            duelChallenge: "Duel Challenge",
            invitedToGame: (user) => `${user} is inviting you to a private game!`,
            removeFriend: "Remove Friend",
            removeFriendConfirm: (user) => `Are you sure you want to remove <b>${user}</b> from your friends?`,
            // Toast Messages
            linkCopied: "Link copied to clipboard!",
            copyFail: "Error: Could not copy link.",
            androidOnly: "This feature is only available in the app.",
            insufficientGold: "Insufficient gold!",
            purchaseSuccess: "Purchase successful!",
            purchaseFail: "An error occurred.",
            avatarUpdated: "Avatar updated successfully!",
            avatarUpdateFail: "Error: Could not update avatar.",
            colorUpdated: "Card color updated!",
            usernameUpdated: "Your username has been updated successfully!",
            usernameUpdateFail: "Error: Could not update username.",
            friendRequestSent: (user) => `Friend request sent to ${user}!`,
            friendRequestFail: "Error: Could not send request.",
            friendRemoved: (user) => `${user} has been removed from friends.`,
            friendRequestAccepted: (user) => `You are now friends with ${user}!`,
            requestAcceptFail: "Could not accept request:",
            inviteSent: "Invite sent!",
            inviteFail: "Error: Could not send invite.",
            inviteDeclined: "Invite declined.",
        }
    };

    const charSets = { tr: 'ABC√áDEFGƒûHIƒ∞JKLMNO√ñPRS≈ûTU√úVYZ'.split(''), en: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('') };
    const wordLists = { tr: typeof wordListTr !== 'undefined' ? wordListTr : [], en: typeof wordListEn !== 'undefined' ? wordListEn : [] };
    const wordLists_2letters = { tr: typeof wordListTr_2letters !== 'undefined' ? wordListTr_2letters : [], en: [] };
        
        const directions = { diagonal: [ { name: 'down-right', dx: 1, dy: 1 }, { name: 'down-left', dx: 1, dy: -1 }, { name: 'up-right', dx: -1, dy: 1 }, { name: 'up-left', dx: -1, dy: -1 } ], horizontal: [ { name: 'right', dx: 0, dy: 1 }, { name: 'left', dx: 0, dy: -1 } ], vertical: [ { name: 'down', dx: 1, dy: 0 }, { name: 'up', dx: -1, dy: 0 } ] };
        const allDirections = [...directions.diagonal, ...directions.horizontal, ...directions.vertical];
        const nonDiagonalDirections = [...directions.horizontal, ...directions.vertical];
const GAME_STATS_KEY = 'wordHuntGameStats';
        const USED_WORDS_KEY = 'wordHuntUsedWords';
        const loadUsedWords = () => { try { const data = localStorage.getItem(USED_WORDS_KEY); return data ? JSON.parse(data) : {}; } catch (e) { console.error("Kullanƒ±lmƒ±≈ü kelimeler y√ºklenemedi:", e); return {}; } };
        const saveUsedWord = (mode, word) => { try { if (!mode || !word) return; const usedWords = loadUsedWords(); if (!usedWords[mode]) { usedWords[mode] = []; } if (!usedWords[mode].includes(word)) { usedWords[mode].push(word); localStorage.setItem(USED_WORDS_KEY, JSON.stringify(usedWords)); } } catch (e) { console.error("Kullanƒ±lmƒ±≈ü kelime kaydedilemedi:", e); } };


    const loadGameStats = () => {
        try {
            const stats = localStorage.getItem(GAME_STATS_KEY);
            if (stats) {
                const parsedStats = JSON.parse(stats);
                if (!parsedStats.modesCompleted) {
                    parsedStats.modesCompleted = {};
                }
                return parsedStats;
            }
        } catch (e) {
            console.error("ƒ∞statistikler y√ºklenemedi:", e);
        }
        return { totalWordsFound: 0, maxLevelCompleted: -1, highScores: {}, modesCompleted: {} };
    };

    const saveGameStats = (stats) => { try { localStorage.setItem(GAME_STATS_KEY, JSON.stringify(stats)); } catch (e) { console.error("ƒ∞statistikler kaydedilemedi:", e); } };
















function createBoard(level, language, config) {    
    if (config && config.modeType === 'takip') {
        return createTakipBoard(level, language, config);
    } 

    try {
        let rows, cols;
        const modeName = config ? config.name : 'easy';

        if (modeName === 'vs-computer') {
            const sizes = { small: { r: 7, c: 7 }, medium: { r: 9, c: 9 }, large: { r: 11, c: 11 } };
            rows = sizes[config.boardSize].r; cols = sizes[config.boardSize].c;
        } else if (modeName === 'multiplayer') {
            const sizes = { small: { r: 7, c: 7 }, medium: { r: 9, c: 8 }, large: { r: 11, c: 11 } };
            rows = sizes[config.boardSize].r; cols = sizes[config.boardSize].c;
        } else {
            if (modeName === 'super-easy') {
                const stage = Math.min(Math.floor(level / 12), 4);
                rows = 6 + stage; cols = 6 + stage;
            } else {
                const stage = Math.min(Math.floor(level / 18), 4);
                rows = 8 + stage; cols = 9 + stage;
            }
        }
        
        const mainWordPool = _.shuffle((wordLists[language] || []).filter(w => w && w.length >= 3 && w.length < Math.min(rows, cols)).map(customToUpperCase));
        const twoLetterWordPool = _.shuffle((wordLists_2letters[language] || []).map(customToUpperCase));
        const selectedTwoLetterWords = twoLetterWordPool.slice(0, 2);
        
        const wordsToPlacePool = [...selectedTwoLetterWords, ...mainWordPool];
        
        for (let attempt = 1; attempt <= 100; attempt++) {
            const board = Array(rows).fill(null).map(() => Array(cols).fill(null));
            const occupied = Array(rows).fill(null).map(() => Array(cols).fill(false));
            let placedWordsInfo = [];
            let placedCellCount = 0;

            const canPlace = (word, r, c, dir) => {
                for (let i = 0; i < word.length; i++) {
                    const nextR = r + i * dir.dx; const nextC = c + i * dir.dy;
                    if (nextR < 0 || nextR >= rows || nextC < 0 || nextC >= cols || occupied[nextR][nextC]) return false;
                }
                return true;
            };

            const placeWord = (word, r, c, dir) => {
                const positions = [];
                for (let i = 0; i < word.length; i++) {
                    const currentR = r + i * dir.dx; const currentC = c + i * dir.dy;
                    board[currentR][currentC] = word[i];
                    occupied[currentR][currentC] = true;
                    positions.push({ row: currentR, col: currentC });
                }
                placedCellCount += word.length;
                placedWordsInfo.push({ word, positions, direction: dir.name });
            };
            
            const shuffledWords = _.shuffle(wordsToPlacePool);
            const midPoint = Math.ceil(shuffledWords.length / 2);
            const diagonalWords = shuffledWords.slice(0, midPoint);
            const nonDiagonalWords = shuffledWords.slice(midPoint);

            const placeWordSet = (wordSet, directionSet) => {
                for (const word of wordSet) {
                    const availablePositions = [];
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            for (const dir of directionSet) {
                                if (canPlace(word, r, c, dir)) {
                                    availablePositions.push({ r, c, dir });
                                }
                            }
                        }
                    }
                    if (availablePositions.length > 0) {
                        const { r, c, dir } = _.sample(availablePositions);
                        placeWord(word, r, c, dir);
                    }
                }
            };
            
            placeWordSet(diagonalWords, directions.diagonal);
            placeWordSet(nonDiagonalWords, nonDiagonalDirections);
            
            const fillRatio = placedCellCount / (rows * cols);
            if (fillRatio < 0.90 && attempt < 99) {
                if(attempt % 10 === 0) 
                continue;
            }
            
            for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { if (board[r][c] === null) board[r][c] = _.sample(charSets[language]); } }
            let hiddenWord = _.sample(mainWordPool.filter(w => w.length >= 5 && w.length <= 9 && !placedWordsInfo.some(p => p.word === w))) || "T√úRKƒ∞YE";
            
const uniquePlacedWords = _.uniqBy(placedWordsInfo, 'word');

return { board, words: _.sortBy(uniquePlacedWords, 'word'), hiddenWord, scatteredHiddenLetterPositions: [] };

        }
    } catch (e) {
        console.error(`[createBoard] KRƒ∞Tƒ∞K HATA:`, e);
        return null;
    }

    console.error("[createBoard] UYARI: 100 denemeye raƒümen istenen kurallarda bir tahta olu≈üturulamadƒ±.");
    return null;
}









function createTakipBoard(level, language, config) {
    let rows, cols;
    const { boardSize, name } = config;

    if (boardSize) {
        const sizes = { small: { r: 9, c: 7 }, medium: { r: 12, c: 9 }, large: { r: 15, c: 11 } };
        rows = sizes[boardSize].r; cols = sizes[boardSize].c;
    } else if (name === 'super-easy') {
        const stage = Math.min(Math.floor(level / 12), 4);
        rows = 4 + stage; cols = 5 + stage;
    } else {
        const stage = Math.min(Math.floor(level / 18), 4);
        rows = 8 + stage; cols = 9 + stage;
    }

    const mainWordPool = (wordLists[language] || []).filter(w => w && w.length >= 3 && w.length <= 8).map(customToUpperCase);
    
    for (let attempt = 0; attempt < 50; attempt++) {
        let potentialWords = _.shuffle(mainWordPool);
        const board = Array(rows).fill(null).map(() => Array(cols).fill(null));
        let placedWordsInfo = [];
        const occupiedCoords = new Set();

        const buildWindingPath = (word) => {
            for (let i = 0; i < 200; i++) {
                const emptyCells = [];
                for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { if(!occupiedCoords.has(`${r}-${c}`)) emptyCells.push({r,c}); }}
                if (emptyCells.length < word.length) return null;
                const startCell = _.sample(emptyCells);
                if (!startCell) continue;
                let path = [{ row: startCell.r, col: startCell.c }];
                const tempOccupied = new Set(occupiedCoords);
                tempOccupied.add(`${startCell.r}-${startCell.c}`);
                let straightCount = 1;
                let lastDir = null;
                let success = true;

                for (let j = 1; j < word.length; j++) {
                    const lastPos = path[j-1];
                    let possibleDirs = [];
                    const directionsToTry = directions.horizontal.concat(directions.vertical);
                    for(const dir of _.shuffle(directionsToTry)) {
                        if (lastDir && dir.dx === -lastDir.dx && dir.dy === -lastDir.dy) continue;
                        const nextR = lastPos.row + dir.dx; const nextC = lastPos.col + dir.dy;
                        if(nextR >= 0 && nextR < rows && nextC >=0 && nextC < cols && !tempOccupied.has(`${nextR}-${nextC}`)){
                            possibleDirs.push(dir);
                        }
                    }
                    if(possibleDirs.length === 0) { success = false; break; }
                    let finalDirs = possibleDirs;
                    if(lastDir && straightCount >= 3) {
                        const nonStraightDirs = possibleDirs.filter(dir => !(dir.dx === lastDir.dx && dir.dy === lastDir.dy));
                        if(nonStraightDirs.length > 0) finalDirs = nonStraightDirs;
                    }
                    const chosenDir = _.sample(finalDirs);
                    if (!chosenDir) { success = false; break; }
                    const nextPos = { row: lastPos.row + chosenDir.dx, col: lastPos.col + chosenDir.dy };
                    path.push(nextPos);
                    tempOccupied.add(`${nextPos.row}-${nextPos.col}`);
                    if (lastDir && chosenDir.dx === lastDir.dx && chosenDir.dy === lastDir.dy) { straightCount++; } else { straightCount = 1; }
                    lastDir = chosenDir;
                }
                if(success) return path;
            }
            return null;
        };

        for(const word of potentialWords) {
            const path = buildWindingPath(word);
            if(path) {
                path.forEach((pos, k) => {
                    board[pos.row][pos.col] = word[k];
                    occupiedCoords.add(`${pos.row}-${pos.col}`);
                });
                placedWordsInfo.push({ word, positions: path, direction: 'snake' });
            }
        }
        
        const filledRatio = occupiedCoords.size / (rows * cols);
        if (filledRatio < 0.90 && attempt < 45) { 
            continue;
        }

        for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { if (board[r][c] === null) board[r][c] = _.sample(charSets[language]); } }

        let hiddenWord = _.sample(mainWordPool.filter(w => w.length >= 5 && w.length <= 9)) || "T√úRKƒ∞YE";
        const hiddenWordLetters = hiddenWord.split('');
        let currentBoardLetters = new Set();
        for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { currentBoardLetters.add(board[r][c]); } }
        
        const missingLetters = hiddenWordLetters.filter(l => !currentBoardLetters.has(l));
        if (missingLetters.length > 0) {
            const unlockedCells = [];
            for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { if(!occupiedCoords.has(`${r}-${c}`)) unlockedCells.push({r,c}); }}
            _.shuffle(unlockedCells).slice(0, missingLetters.length).forEach((cell, i) => {
                board[cell.r][cell.c] = missingLetters[i];
            });
        }
        
        const scatteredHiddenLetterPositions = [];
        const hiddenWordCharCount = _.countBy(hiddenWordLetters);
        const tempBoard = JSON.parse(JSON.stringify(board));
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const char = tempBoard[r][c];
                if (hiddenWordCharCount[char] > 0) {
                    scatteredHiddenLetterPositions.push({ row: r, col: c });
                    hiddenWordCharCount[char]--;
                    tempBoard[r][c] = null;
                }
            }
        }
        
       const uniquePlacedWords = _.uniqBy(placedWordsInfo, 'word');


if (uniquePlacedWords.length === 0) {
    console.error("createTakipBoard: 50 denemeye raƒümen hi√ßbir kelime yerle≈ütirilemedi.");
    return null;
}

return { board, words: _.sortBy(uniquePlacedWords, 'word'), hiddenWord, scatteredHiddenLetterPositions: [] };
    }
    console.error("Kelime Takibi tahtasƒ± olu≈üturulamadƒ±.");
    return null; 
}




















function Modal({ isOpen, title, children, onClose }) { if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}> <div className="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full text-center relative" onClick={e => e.stopPropagation()}> <h3 className="text-2xl font-semibold mb-4 text-gray-800">{title}</h3> <div className="text-gray-700">{children}</div> <button onClick={onClose} className="absolute top-2 right-2 text-gray-500 hover:text-gray-800 text-2xl">&times;</button> </div> </div> ); }

const Cell = React.memo(function Cell({letter, isSelected, isFoundRequiredPart, isHiddenLetterCell, allRequiredWordsFound, isJustFound, isBonusGlow, theme, numCols, foundWordColorInfo, rowIndex, colIndex }) {
    let cellClass = 'bg-white';
    let textClass = 'text-gray-800';

    if (isBonusGlow) {
        cellClass = 'animate-bonus-glow';
    }
    else if (allRequiredWordsFound) {
        if (isHiddenLetterCell) {
            cellClass = theme.hiddenWordCell;
            textClass = 'text-white';
        } else {
            cellClass = theme.obscuredCell;
        }
    } else {
        if (isJustFound) {
            cellClass = 'animate-word-found';
        } else if (isSelected) {
            cellClass = theme.selectedCell + ' transform scale-110 shadow-lg';
            textClass = 'text-black font-bold';
        } else if (isFoundRequiredPart) {
            if (foundWordColorInfo) {
                cellClass = foundWordColorInfo.bg;
                textClass = foundWordColorInfo.text;
            } else {
                cellClass = theme.foundCell;
                textClass = 'text-gray-600 opacity-75';
            }
        }
    }

    const calculateFontSize = () => {
        if (!numCols) return { fontSize: '18px' };
        const maxGridWidth = 768; const targetRatio = 0.6; const minFontSize = 10;
        const preferredVw = (100 / numCols) * targetRatio;
        const maxFontSize = (maxGridWidth / numCols) * targetRatio;
        return { fontSize: `clamp(${minFontSize}px, ${preferredVw.toFixed(2)}vw, ${maxFontSize.toFixed(2)}px)` };
    };

    const fontSizeStyle = calculateFontSize();

    return (
        <div
            data-row={rowIndex}
            data-col={colIndex}
            className={`flex items-center justify-center text-center font-semibold border border-gray-200/50 rounded aspect-square ${cellClass} ${textClass} transition-all duration-150 select-none`}
            style={fontSizeStyle}
        >
            {letter || ''}
        </div>
    );
});


    function LeaderboardDisplay({ scores, currentUser, language }) {
            const t = translations[language] || translations['en'];
            if (!scores || scores.length === 0) {
                return <p className="text-gray-600 dark:text-gray-400 pt-10">Bu mod i√ßin hen√ºz skor bulunmuyor.</p>;
            }
            const rankIcons = ['ü•á', 'ü•à', 'ü•â'];
            return (
                <div className="text-left overflow-y-auto max-h-[300px] mt-4 pr-2 scrollbar-thin">
                    <ul className="space-y-2">
                        {scores.map((score, index) => {
                            const isCurrentUser = score.username === currentUser;
                            return (
                                <li
                                    key={score.id || index}
                                    className={`flex items-center p-3 rounded-lg transition-all ${isCurrentUser ? 'bg-yellow-100 dark:bg-yellow-800/20 border-2 border-yellow-400' : 'bg-gray-50 dark:bg-gray-800'}`}
                                >
                                    <span className="font-bold text-lg w-10 text-center text-gray-500 dark:text-gray-400">
                                        {rankIcons[index] || index + 1}
                                    </span>

                                    <div className="flex-1">
                                        <p className={`font-semibold text-gray-800 dark:text-gray-200 ${isCurrentUser ? 'text-yellow-900 dark:text-yellow-300' : ''}`}>
                                            {score.username}
                                        </p>
                                        {score.level && (
                                            <p className={`text-xs text-gray-500 dark:text-gray-400 ${isCurrentUser ? 'text-yellow-800 dark:text-yellow-400' : ''}`}>
                                                Seviye {score.level}
                                            </p>
                                        )}
                                    </div>

                                    <span className={`font-bold text-xl text-indigo-600 dark:text-indigo-400 tabular-nums ${isCurrentUser ? 'text-yellow-900 dark:text-yellow-300' : ''}`}>
                                        {score.score}
                                    </span>
                                </li>
                            );
                        })}
                    </ul>
                </div>
            );
        }

    function LeaderboardModal({ isOpen, onClose, currentUser, language }) { const t = translations[language] || translations['en']; const [activeTab, setActiveTab] = React.useState('super-easy'); const [scores, setScores] = React.useState({ 'super-easy': [], easy: [], hard: [], 'timed-easy': [], 'timed-hard': [] }); const [loading, setLoading] = React.useState(true);

        const tabs = [

        { key: 'super-easy', line1Key: '√ßok', line2Key: 'kolay', activeBg: 'bg-green-500' },
                { key: 'easy', line1Key: 'kolay', line2Key: 'normal', activeBg: 'bg-teal-500' },
                { key: 'hard', line1Key: 'zor', line2Key: 'normal', activeBg: 'bg-red-500' },
                { key: 'timed-easy', line1Key: 's√ºreli', line2Key: 'kolay', activeBg: 'bg-blue-500' },
                { key: 'timed-hard', line1Key: 's√ºreli', line2Key: 'zor', activeBg: 'bg-orange-500' }
            ];

         React.useEffect(() => { if (isOpen) { setLoading(true); const fetchPromises = tabs.map(tab => db.collection("scores") .where("mode", "==", tab.key) .orderBy("score", "desc") .limit(50) .get() ); Promise.all(fetchPromises) .then(snapshots => { const newScores = {}; snapshots.forEach((snapshot, index) => { const mode = tabs[index].key; newScores[mode] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); }); setScores(newScores); }) .catch(error => console.error("Liderlik tablosu verileri √ßekilirken hata olu≈ütu:", error)) .finally(() => setLoading(false)); } }, [isOpen]); if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" onClick={onClose}> <div className="bg-white dark:bg-gray-900 p-4 sm:p-6 rounded-xl shadow-2xl max-w-lg w-full text-center relative" onClick={e => e.stopPropagation()}> <h3 className="text-3xl font-bold mb-4 text-gray-800 dark:text-gray-100">üèÜ {t.leaderboard} üèÜ</h3> <button onClick={onClose} className="absolute top-2 right-2 text-gray-500 hover:text-gray-800 dark:hover:text-gray-200 text-3xl">&times;</button> <div className="flex items-center border-b-2 border-gray-200 dark:border-gray-700"> {tabs.map(tab => { const isActive = activeTab === tab.key; return ( <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`flex-1 flex flex-col justify-center items-center h-14 py-1 text-center transition-all duration-300 border-x border-transparent ${isActive ? `${tab.activeBg} scale-105 z-10 rounded-t-lg` : 'hover:bg-gray-100 dark:hover:bg-gray-800'}`}> <span className={`block text-xs font-bold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}> {t[tab.line1Key]} </span> <span className={`block text-xs font-semibold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}> {t[tab.line2Key]} </span> </button> ); })} </div> <div className="min-h-[300px]"> {loading ? ( <p className="text-gray-600 dark:text-gray-400 pt-10">Liderlik tablosu y√ºkleniyor...</p> ) : ( <LeaderboardDisplay scores={scores[activeTab]} currentUser={currentUser} language={language} /> )} </div> </div> </div> ); }




function HomePage({
        startGame,
        startGameVsComputer,
        language,
        setLanguage,
        stats,
        setModalContent,
        setLeaderboardModalOpen,
        username,
        isInitializing,
        openLobbyPage,
        avatarId,
        openProfileModal,
        cardColor,
        playerCardColors
    }) {
        const t = translations[language] || translations['en'];
        const [expandedSection, setExpandedSection] = React.useState(null);

        const handleSectionClick = (section) => {
            setExpandedSection(prevSection => (prevSection === section ? null : section));
        };
        
        const handleAchievementsClick = () => {
            setModalContent({
                isOpen: true,
                title: t.achievementsButton,
                onClose: () => setModalContent({ isOpen: false }),
                body: <AchievementsList stats={stats} language={language} />
            });
        };

        const MainSectionCard = ({ sectionKey, title, icon, onClick, bgColor, children, description }) => {
            const isOpen = expandedSection === sectionKey;
            return (
                <div className={`rounded-2xl shadow-lg text-white overflow-hidden ${bgColor}`}>
                    <button onClick={onClick} className="w-full p-5 flex justify-between items-center text-left">
                        <div className="flex items-center gap-4">
                            <span className="text-5xl drop-shadow-lg">{icon}</span>
                            <div>
                                <h3 className="text-2xl font-bold">{title}</h3>
                                <p className="text-sm opacity-80 font-medium">{description}</p>
                            </div>
                        </div>
                        {children && (
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={`w-8 h-8 transition-transform duration-300 ${isOpen ? 'transform rotate-180' : ''}`}>
                                <path fillRule="evenodd" d="M12.53 16.28a.75.75 0 01-1.06 0l-7-7.5a.75.75 0 011.06-1.06L12 14.69l6.97-6.97a.75.75 0 111.06 1.06l-7.5 7.5z" clipRule="evenodd" />
                            </svg>
                        )}
                         {!children && <span className="text-3xl font-bold">‚Üí</span>}
                    </button>
                    {isOpen && (
                        <div className="bg-black/20 p-4">
                            {children}
                        </div>
                    )}
                </div>
            );
        };

        const SubModeCard = ({ title, icon, onClick, disabled, bgColor }) => (
             <button onClick={onClick} disabled={disabled} className={`p-3 w-full h-full rounded-lg flex flex-col items-center justify-center text-center transition-all transform hover:scale-105 disabled:opacity-50 ${bgColor || 'bg-white/20 hover:bg-white/30'} backdrop-blur-sm`}>
                <span className="text-4xl">{icon}</span>
                <span className="font-semibold mt-1">{title}</span>
            </button>
        );
        
        const selectedCardColor = playerCardColors.find(c => c.id === cardColor) || playerCardColors.find(c => c.id === 'gray');

        return (
            <div className="h-full w-full bg-slate-100 flex flex-col">
                <div className="container mx-auto px-4 pt-3 text-center flex flex-col flex-1 overflow-hidden">
                    <header className="my-2 flex-shrink-0 flex items-center justify-between">
                         <div className="text-left">
                            <h1 className="text-4xl md:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 drop-shadow-sm">{t.title}</h1>
                            <p className="text-slate-500 text-sm mt-1">{t.homePageSubtitle}</p>
                        </div>
                        {username && (
                            <div className="flex items-center gap-2">
                                <div 
                                    onClick={openProfileModal}
                                    className={`p-3 rounded-2xl shadow-sm border border-white/20 transition-all cursor-pointer hover:shadow-lg hover:scale-105 ${selectedCardColor.class}`}
                                >
                                    <div className="flex flex-col items-center gap-1.5 pointer-events-none">
                                        <div className="relative">
                                            <img
                                                src={avatarId ? `avatars/${avatarId}.png` : 'avatars/default.png'}
                                                className="w-12 h-12 rounded-full object-cover bg-gray-200 border-2 border-white shadow-md"
                                            />
                                            <div
                                                className="absolute bottom-0 right-0 w-3.5 h-3.5 bg-green-400 rounded-full border-2 border-white"
                                                title={'√áevrimi√ßi'}
                                            ></div>
                                        </div>
                                        <p className="font-bold text-sm text-white drop-shadow">{username}</p>
                                    </div>
                                </div>
                            </div>
                        )}
                    </header>

                    <div className="flex-shrink-0 grid grid-cols-2 gap-3 my-4">
                        <button 
                            onClick={() => setLeaderboardModalOpen(true)} 
                            className="w-full p-3 bg-gradient-to-br from-amber-400 to-orange-500 text-white font-bold rounded-xl shadow-lg flex items-center justify-center gap-2 transition-transform hover:scale-105"
                        >
                            <span className="text-2xl">üèÜ</span>
                            <span>{t.leaderboardButton}</span>
                        </button>
                        <button 
                            onClick={handleAchievementsClick} 
                            className="w-full p-3 bg-gradient-to-br from-lime-500 to-emerald-600 text-white font-bold rounded-xl shadow-lg flex items-center justify-center gap-2 transition-transform hover:scale-105"
                        >
                            <span className="text-2xl">üèÖ</span>
                            <span>{t.achievementsButton}</span>
                        </button>
                    </div>

                    <div className="flex-1 overflow-y-auto scrollbar-thin py-4">
                        <div className="w-full max-w-md mx-auto space-y-4">
                            <MainSectionCard sectionKey="lobi" title={t.lobbyTitle} icon="‚öîÔ∏è" description={t.lobbyDescription} onClick={openLobbyPage} bgColor="bg-gradient-to-br from-purple-600 to-indigo-700" />
                            <MainSectionCard sectionKey="vs_ai" title={t.vsAiTitle} icon="ü§ñ" description={t.vsAiDescription} onClick={startGameVsComputer} bgColor="bg-gradient-to-br from-slate-500 to-slate-700" />

							<MainSectionCard sectionKey="kelime_avi" title={t.wordHuntTitle} icon="üß≠" description={t.wordHuntDescription} onClick={() => handleSectionClick('kelime_avi')} bgColor="bg-gradient-to-br from-sky-500 to-cyan-600">
								<div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
									<SubModeCard title={t.superEasyMode} icon="üêª" onClick={() => startGame('super-easy')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.easyMode} icon="üó∫Ô∏è" onClick={() => startGame('easy')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.hardMode} icon="üåã" onClick={() => startGame('hard')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.timedEasyMode} icon="‚è±Ô∏è" onClick={() => startGame('timed-easy')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.timedHardMode} icon="üî•" onClick={() => startGame('timed-hard')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
									<SubModeCard title={t.randomMode} icon="üêü" onClick={() => startGame('random')} bgColor="bg-sky-800/50 hover:bg-sky-700/60" />
								</div>
							</MainSectionCard>

							<MainSectionCard sectionKey="kelime_takibi" title={t.wordTrackingTitle} icon="üéØ" description={t.wordTrackingDescription} onClick={() => handleSectionClick('kelime_takibi')} bgColor="bg-gradient-to-br from-amber-500 to-orange-600">
							   <div className="grid grid-cols-2 sm:grid-cols-2 gap-3">
									<SubModeCard title={t.superEasyMode} icon="üêõ" onClick={() => startGame('takip-super-easy')} bgColor="bg-amber-800/50 hover:bg-amber-700/60" />
									<SubModeCard title={t.easyMode} icon="üêç" onClick={() => startGame('takip-easy')} bgColor="bg-amber-800/50 hover:bg-amber-700/60" />
									<SubModeCard title={t.timedEasyMode} icon="‚è≥" onClick={() => startGame('takip-timed-easy')} bgColor="bg-amber-800/50 hover:bg-amber-700/60" />
									<SubModeCard title={t.randomMode} icon="üê†" onClick={() => startGame('takip-random')} bgColor="bg-amber-800/50 hover:bg-amber-700/60" />
								</div>
							</MainSectionCard>
						</div>
                    </div>
                    <footer className="p-4 text-center text-sm text-slate-500 flex-shrink-0">
                        <div className="mb-2">
                            <button 
                                onClick={() => setLanguage(language === 'tr' ? 'en' : 'tr')}
                                className="px-4 py-2 bg-white border border-slate-300 rounded-full shadow-sm text-slate-700 font-semibold hover:bg-slate-100 transition-colors"
                            >
                                {t.languageSwitch}
                            </button>
                        </div>
                        {t.footerText}
                    </footer>
                </div>
            </div>
        );
    }






const WordHunt = React.forwardRef(({ config, gameId, username, goToHome, language, stats, onStatsChange, initialSavedState, setToastMessage, toastMessage }, ref) => {
    const t = translations[language] || translations['en'];


React.useImperativeHandle(ref, () => ({
        showExitConfirmation() {
            handleGoHomeClick();
        }
    }));
    let infoBarClass = 'from-violet-100 to-indigo-100'; 
    if (config.name === 'super-easy') {
        infoBarClass = 'from-green-100 to-emerald-200 text-green-900';
    } else if (config.name === 'easy' || config.name === 'timed-easy') {
        infoBarClass = 'from-sky-100 to-blue-200 text-sky-900';
    } else if (config.name === 'hard' || config.name === 'timed-hard') {
        infoBarClass = 'from-red-100 to-rose-200 text-red-900';
    }
    const [isGenerating, setIsGenerating] = React.useState(true); 
    const isRealtimeDuel = !!gameId;
    const isVsComputer = config.name === 'vs-computer';
    const [realtimeGameData, setRealtimeGameData] = React.useState(null);
    const [computerState, setComputerState] = React.useState({ score: 0, foundWords: [] });
    const [board, setBoard] = React.useState(null);
    const [foundWordsInOrder, setFoundWordsInOrder] = React.useState([]);
    const [foundCellColorMap, setFoundCellColorMap] = React.useState({});
    const [isLoading, setIsLoading] = React.useState(true);
    const [error, setError] = React.useState('');
    const [level, setLevel] = React.useState(config?.level ?? initialSavedState?.level ?? 0);
    const [score, setScore] = React.useState(initialSavedState?.score ?? 0);
    const [foundWords, setFoundWords] = React.useState(initialSavedState?.foundWords ?? []);
    const [gameState, setGameState] = React.useState(null);
    const [timeLeft, setTimeLeft] = React.useState(initialSavedState?.timeLeft ?? getInitialTime(config.name, 0));
    const [modalContent, setModalContent] = React.useState({ isOpen: false });
    const [justFoundWordInfo, setJustFoundWordInfo] = React.useState(null);
    const [allRequiredWordsFound, setAllRequiredWordsFound] = React.useState(false);
    const [isShaking, setIsShaking] = React.useState(false);
    const [levelStartTime, setLevelStartTime] = React.useState(null);
    const [hiddenWordAttempts, setHiddenWordAttempts] = React.useState(0);
    const [answerSlots, setAnswerSlots] = React.useState([]);
    const [sourceLetters, setSourceLetters] = React.useState([]);
    const [hintLockedSlots, setHintLockedSlots] = React.useState([]);
    const [hiddenWordTimeLeft, setHiddenWordTimeLeft] = React.useState(null);
    const gridRef = React.useRef(null);
    const [selectedCells, setSelectedCells] = React.useState([]);
    const [isSwiping, setIsSwiping] = React.useState(false);
    const foundWordsRef = React.useRef(foundWords);
    const computerStateRef = React.useRef(computerState);
    const lastHiddenTimestamp = React.useRef(null);
    const [bonusGlowCells, setBonusGlowCells] = React.useState([]);
    const [foundBonusWords, setFoundBonusWords] = React.useState([]);
    const theme = (config.name === 'hard' || config.name === 'timed-hard') ? { bg: 'bg-red-50', foundCell: 'bg-red-200', hiddenWordCell: 'bg-blue-400 text-white font-bold', wordBg: 'bg-red-100', gridBg: 'bg-red-100', button: 'bg-red-600 hover:bg-red-700', inputBorder: 'border-red-300 focus:border-red-500', selectedCell: 'bg-yellow-400', obscuredCell: 'bg-gray-400 text-transparent opacity-50' } : { bg: 'bg-indigo-50', foundCell: 'bg-green-200', hiddenWordCell: 'bg-blue-400 text-white font-bold', wordBg: 'bg-indigo-100', gridBg: 'bg-indigo-100', button: 'bg-indigo-600 hover:bg-indigo-700', inputBorder: 'border-indigo-300 focus:border-indigo-500', selectedCell: 'bg-yellow-300', obscuredCell: 'bg-gray-400 text-transparent opacity-50' };



 const getCellFromEvent = (clientX, clientY) => {
    const targetElement = document.elementFromPoint(clientX, clientY);
    if (targetElement) {
        const rowStr = targetElement.getAttribute('data-row');
        const colStr = targetElement.getAttribute('data-col');
        if (rowStr && colStr) {
            return { row: parseInt(rowStr, 10), col: parseInt(colStr, 10) };
        }
    }
    return null;
};

const handleInteractionStart = React.useCallback((clientX, clientY) => {
    const canPlay = isRealtimeDuel || isVsComputer ? true : !allRequiredWordsFound;
    if (!canPlay || !board) {
        return;
    }
    
    const cell = getCellFromEvent(clientX, clientY);
    const cellFoundStatus = cell ? isCellFound(cell.row, cell.col) : 'yok';

    if (cell && !cellFoundStatus) {
        setIsSwiping(true);
        setSelectedCells([cell]);
    } else {
    }
}, [board, isCellFound, isRealtimeDuel, allRequiredWordsFound, isVsComputer]);
const handleInteractionMove = React.useCallback((clientX, clientY) => {
    if (!isSwiping) {
        return;
    }

    const currentCell = getCellFromEvent(clientX, clientY);
    if (!currentCell) {
        return;
    }
    
    setSelectedCells(prevSelectedCells => {
        if (prevSelectedCells.length === 0) return prevSelectedCells;
        
        const lastCell = prevSelectedCells[prevSelectedCells.length - 1];
        if(lastCell.row === currentCell.row && lastCell.col === currentCell.col) return prevSelectedCells;
        const isTrackingMode = config.modeType === 'takip';
        
        if (isTrackingMode) {
            let newSelectedCells = [...prevSelectedCells];
            if (newSelectedCells.length > 1) {
                const secondToLastCell = newSelectedCells[newSelectedCells.length - 2];
                if (secondToLastCell.row === currentCell.row && secondToLastCell.col === currentCell.col) {
                    return newSelectedCells.slice(0, -1);
                }
            }
            const isAdjacent = (Math.abs(currentCell.row - lastCell.row) === 1 && currentCell.col === lastCell.col) ||
                               (Math.abs(currentCell.col - lastCell.col) === 1 && currentCell.row === lastCell.row);
            if (isAdjacent && !isCellFound(currentCell.row, currentCell.col)) {
                return [...newSelectedCells, currentCell];
            }
            return newSelectedCells;
        } else { 
            const startCell = prevSelectedCells[0];
            const dx = Math.sign(currentCell.col - startCell.col);
            const dy = Math.sign(currentCell.row - startCell.row);
            const isDiagonal = (dx !== 0 && dy !== 0 && Math.abs(currentCell.col - startCell.col) === Math.abs(currentCell.row - startCell.row));
            const isStraight = (dx === 0 || dy === 0);
            
            if (!(isDiagonal || isStraight)) {
                 return prevSelectedCells;
            }
            
            const distance = Math.max(Math.abs(currentCell.row - startCell.row), Math.abs(currentCell.col - startCell.col));
            const path = [startCell];
            for (let i = 1; i <= distance; i++) {
                const nextCell = { row: startCell.row + i * dy, col: startCell.col + i * dx };
                const cellFoundStatus = isCellFound(nextCell.row, nextCell.col);
                if (cellFoundStatus) {
                    break;
                }
                path.push(nextCell);
            }
            return path;
        }
    });
}, [isSwiping, board, config.modeType, isCellFound]);




    const throttledMouseMove = React.useMemo(() => _.throttle((e) => handleInteractionMove(e.clientX, e.clientY), 50), [handleInteractionMove]);

    React.useEffect(() => {
        const gridElement = gridRef.current;
        const handleTouchMoveWrapper = (e) => {
            e.preventDefault();
            handleInteractionMove(e.touches[0].clientX, e.touches[0].clientY);
        };

        if (gridElement) {
            gridElement.addEventListener('touchmove', handleTouchMoveWrapper, { passive: false });
            return () => {
                gridElement.removeEventListener('touchmove', handleTouchMoveWrapper);
            };
        }
    }, [handleInteractionMove]);


    const cellOwnerMap = React.useMemo(() => {
        const map = {};
        if (!isRealtimeDuel || !realtimeGameData?.players || !realtimeGameData?.boardData?.words) return map;
        
        for (const playerName in realtimeGameData.players) {
            const playerInfo = realtimeGameData.players[playerName];
            if (playerInfo.foundWords && playerInfo.foundWords.length > 0) {
                const wordsFoundByPlayer = realtimeGameData.boardData.words.filter(w => playerInfo.foundWords.includes(w.word));
                for (const word of wordsFoundByPlayer) {
                    if (word.positions) {
                        for (const pos of word.positions) {
                            map[`${pos.row}-${pos.col}`] = playerName;
                        }
                    }
                }
            }
        }
        return map;
    }, [realtimeGameData, isRealtimeDuel]);

    React.useEffect(() => {
        if (isRealtimeDuel || isVsComputer) {
            setIsLoading(false);
            return;
        };
        setIsGenerating(true);
        setError('');
        setTimeout(() => {
            const newBoardData = createBoard(level, language, config);
            if (newBoardData) {
                setGameState(newBoardData);
                setBoard(newBoardData.board);
                if(initialSavedState && initialSavedState.level === level) {
                    setFoundWords(initialSavedState.foundWords || []);
                    setScore(initialSavedState.score || 0);
                    setTimeLeft(initialSavedState.timeLeft || getInitialTime(config.name, level));
                } else {
                    setFoundWords([]);
                    setScore(0);
                    setTimeLeft(getInitialTime(config.name, level));
                }
                setAllRequiredWordsFound(false);
                setHiddenWordAttempts(0);
                setJustFoundWordInfo(null);
                setAnswerSlots([]);
                setSourceLetters([]);
                setHintLockedSlots([]);
                setLevelStartTime(Date.now());
            } else {
                setError(t.levelLoadError);
            }
            setIsGenerating(false);
            setIsLoading(false);
        }, 100);
    }, [level, config.name, language, isRealtimeDuel, isVsComputer, initialSavedState]);
    
    React.useEffect(() => {
        if (!isRealtimeDuel) return;
        setIsLoading(true);
        const gameRef = db.collection('game_rooms').doc(gameId);
        const unsubscribe = gameRef.onSnapshot(doc => {
            if (!doc.exists) {
                setError('Oyun odasƒ± bulunamadƒ± veya kapatƒ±ldƒ±.');
                setIsLoading(false);
                setIsGenerating(false);
                setTimeout(goToHome, 3000);
                return;
            }
            const data = doc.data();
            setRealtimeGameData(data);
            if (data.boardData && data.boardData.board && Object.keys(data.boardData.board).length > 0) {
                setBoard(Object.values(data.boardData.board));
                setGameState(data.boardData);
                setIsLoading(false);
                setIsGenerating(false); 
            }
        });
        return () => unsubscribe();
    }, [isRealtimeDuel, gameId]);

    React.useEffect(() => {
        if (!isVsComputer) return;
        setIsGenerating(true);
        setError('');
        setTimeout(() => {
            const newBoardData = createBoard(null, language, config);
            if (newBoardData) {
                setGameState(newBoardData);
                setBoard(newBoardData.board);
                setFoundWords([]);
                setComputerState({ score: 0, foundWords: [] });
                setScore(0);
            } else {
                setError(t.levelLoadError);
            }
            setIsGenerating(false);
            setIsLoading(false);
        }, 100);
    }, [isVsComputer, config.name, language]);

    


    React.useEffect(() => {
        if (!isRealtimeDuel || !realtimeGameData || !realtimeGameData.boardData || realtimeGameData.status !== 'in-progress') {
            return;
        }
        const allWordsInLevel = realtimeGameData.boardData.words;
        if (!allWordsInLevel || allWordsInLevel.length === 0) {
            return;
        }
        const allFoundWordsCombined = new Set(
            Object.values(realtimeGameData.players).flatMap(p => p.foundWords || [])
        );
        if (allFoundWordsCombined.size >= allWordsInLevel.length) {
            if (realtimeGameData.status === 'in-progress') {
                const gameRef = db.collection('game_rooms').doc(gameId);
                const finalSortedPlayers = Object.entries(realtimeGameData.players).sort(([, a], [, b]) => b.score - a.score);
                const winnerUsername = finalSortedPlayers.length > 0 ? finalSortedPlayers[0][0] : 'draw';
                gameRef.update({
                    status: 'finished',
                    winner: winnerUsername
                }).catch(err => {
                    console.error("Oyun durumu g√ºncellenirken hata olu≈ütu:", err);
                });
            }
        }
    }, [realtimeGameData, gameId, isRealtimeDuel]);
    
    

    const handleForfeit = () => {
        const opponentName = realtimeGameData && Object.keys(realtimeGameData.players).find(p => p !== username);
        if (gameId && opponentName) {
            db.collection('game_rooms').doc(gameId).update({ status: 'finished', winner: opponentName, reason: `${username} oyundan ayrƒ±ldƒ±.` }).finally(() => { goToHome(); });
        } else {
            goToHome();
        }
    };

    React.useEffect(() => {
        if (!gameState || !gameState.words) return;
        const newColorMap = {};
        foundWordsInOrder.forEach((word, index) => {
            const wordInfo = gameState.words.find(w => w.word === word);
            if (wordInfo && wordInfo.positions) {
                const colorIndex = index % wordFoundColors.length;
                const colorClasses = wordFoundColors[colorIndex];
                wordInfo.positions.forEach(pos => {
                    newColorMap[`${pos.row}-${pos.col}`] = colorClasses;
                });
            }
        });
        setFoundCellColorMap(newColorMap);
    }, [foundWordsInOrder, gameState]);    

    const closeModal = () => setModalContent({ isOpen: false });
    const showExitConfirmation = React.useCallback(() => {
        const isDuel = isRealtimeDuel;
        const bodyText = isDuel
            ? "Oyundan √ßƒ±kƒ±p ana sayfaya d√∂nmek istediƒüinize emin misiniz? <br /><strong class='text-red-500'>Bu i≈ülem ma√ßƒ± kaybettiƒüiniz anlamƒ±na gelecektir.</strong>"
            : "Ana men√ºye d√∂nmek istediƒüinize emin misiniz?";
        const confirmButtonText = isDuel ? "Evet, Terk Et" : "Evet, √áƒ±k";
        const confirmButtonAction = isDuel ? handleForfeit : goToHome;
        setModalContent({
            isOpen: true,
            title: '', 
            onClose: closeModal,
            body: (
                 <div className="w-full max-w-sm text-white bg-gradient-to-br from-slate-700 to-gray-800 rounded-2xl shadow-2xl p-6 text-center">
                    <div className="text-6xl mb-4">ü§î</div>
                    <h2 className="text-2xl font-bold mb-2">Oyundan Ayrƒ±l</h2>
                    <p className="text-white/80 mb-6" dangerouslySetInnerHTML={{ __html: bodyText }}></p>
                    <div className="flex justify-center gap-4">
                        <button onClick={closeModal} className="px-8 py-2 bg-white/20 text-white font-bold rounded-lg hover:bg-white/30">Hayƒ±r, Kal</button>
                        <button onClick={confirmButtonAction} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">{confirmButtonText}</button>
                    </div>
                </div>
            )
        });
    }, [isRealtimeDuel, isVsComputer, goToHome, handleForfeit, realtimeGameData]);

    
    
    const isCellFound = React.useCallback((r, c) => {
    if (isRealtimeDuel) {
        if (!realtimeGameData || !realtimeGameData.boardData || !realtimeGameData.players) return false;
        for (const player of Object.values(realtimeGameData.players)) {
            const foundWordInfo = realtimeGameData.boardData.words.filter(w => (player.foundWords || []).includes(w.word));
            for (const word of foundWordInfo) {
                if (word.positions.some(p => p.row === r && p.col === c)) return true;
            }
        }
        return false;
    } else {
        if (gameState?.words?.some(w => foundWords.includes(w.word) && w.positions.some(p => p.row === r && p.col === c))) return 'player';
        if (isVsComputer && gameState?.words?.some(w => computerState.foundWords.includes(w.word) && w.positions.some(p => p.row === r && p.col === c))) return 'computer';
        return false;
    }
}, [isRealtimeDuel, realtimeGameData, gameState, foundWords, isVsComputer, computerState]);
    
    

   

    const handleInteractionEnd = () => {
        if (!isSwiping || !board || selectedCells.length <= 1) {
            setIsSwiping(false);
            setSelectedCells([]);
            return;
        }
        setIsSwiping(false);
        const rawWord = selectedCells.map(c => board?.[c.row]?.[c.col] || '').join('');
        const word = customToUpperCase(rawWord);
        if (isRealtimeDuel) {
            const targetWord = realtimeGameData.boardData.words.find(w => w.word === word);
            const alreadyFoundByAnyPlayer = Object.values(realtimeGameData.players).some(p => (p.foundWords || []).includes(word));
            if (targetWord && !alreadyFoundByAnyPlayer) {
                playSound('correctSound');
                vibrate('success');
                const points = word.length * 10;
                const gameRef = db.collection('game_rooms').doc(gameId);
                const scoreUpdateKey = `players.${username}.score`;
                const scoreUpdate = { [scoreUpdateKey]: firebase.firestore.FieldValue.increment(points) };
                const wordsUpdateKey = `players.${username}.foundWords`;
                const wordsUpdate = { [wordsUpdateKey]: firebase.firestore.FieldValue.arrayUnion(word) };
                gameRef.update(scoreUpdate).catch(err => console.error("Skor g√ºncellenirken hata:", err));
                gameRef.update(wordsUpdate).catch(err => console.error("Kelime g√ºncellenirken hata:", err));
            } else {
                playSound('wrongSound');
                vibrate('error');
            }
        } else {
            const isAlreadyUsedByComputer = isVsComputer && selectedCells.some(cell =>
                gameState.words.some(w =>
                    computerState.foundWords.includes(w.word) &&
                    w.positions.some(p => p.row === cell.row && p.col === cell.col)
                )
            );
            if (isAlreadyUsedByComputer) {
                playSound('wrongSound');
                vibrate('error');
                setSelectedCells([]);
                return;
            }
            const targetWord = gameState.words.find(w => w.word === word);
			if (targetWord && !foundWords.includes(word)) {
				setFoundWords(prev => [...prev, word]);
				setFoundWordsInOrder(prev => [...prev, word]);
				let wordScore = isVsComputer ? word.length * 5 : word.length * (getScoreMultiplier(levelStartTime));
				setScore(s => s + wordScore);
				playSound('correctSound');
				vibrate('success');
				setJustFoundWordInfo({ word, positions: targetWord.positions });
				setTimeout(() => setJustFoundWordInfo(null), 600);
			}
            else {
                const masterWordList = (wordLists[language] || []).map(customToUpperCase);
                const isBonusWord = masterWordList.includes(word);
                const alreadyFound = foundWords.includes(word) || foundBonusWords.includes(word);
                if (isBonusWord && !alreadyFound && word.length >= 3) {
                    setFoundBonusWords(prev => [...prev, word]);
                    const bonusScore = word.length * 2;
                    setScore(s => s + bonusScore);
                    playSound('correctSound');
                    vibrate('success');
                    setJustFoundWordInfo({ word, positions: selectedCells });
                    setTimeout(() => setJustFoundWordInfo(null), 600);
                    setToastMessage(`Listede olmayan (${word}) kelimesini buldun, +${bonusScore} puan`);
                } else {
                    playSound('wrongSound');
                    vibrate('error');
                }
            }
        }
        setSelectedCells([]);
    };







    
    const playSound = React.useCallback((soundId) => {
        const sound = document.getElementById(soundId);
        if (sound) {
            sound.currentTime = 0;
            sound.play().catch(e => {});
        }
    }, []);

    const getScoreMultiplier = (startTime) => {
        if (!startTime) return 1;
        const elapsedSeconds = (Date.now() - startTime) / 1000;
        if (elapsedSeconds <= 20) return 5;
        if (elapsedSeconds <= 40) return 4;
        if (elapsedSeconds <= 60) return 3;
        if (elapsedSeconds <= 80) return 2;
        return 1;
    };

    const handleAnswerSlotClick = (letter, index) => {
        if (hintLockedSlots.includes(index) || !letter) return;
        const newAnswerSlots = [...answerSlots];
        newAnswerSlots[index] = null;
        setAnswerSlots(newAnswerSlots);
        setSourceLetters([...sourceLetters, letter]);
    };

    const handleSourceLetterClick = (letter) => {
        const firstEmptyIndex = answerSlots.findIndex(slot => slot === null);
        if (firstEmptyIndex === -1) return;
        const newAnswerSlots = [...answerSlots];
        newAnswerSlots[firstEmptyIndex] = letter;
        setAnswerSlots(newAnswerSlots);
        setSourceLetters(sourceLetters.filter(l => l.id !== letter.id));
    };
    
    const goToNextLevel = () => {
        const newStats = { ...stats };
        newStats.maxLevelCompleted = Math.max(stats.maxLevelCompleted, level);
        if (!newStats.modesCompleted) newStats.modesCompleted = {};
        newStats.modesCompleted[config.name] = true;
        const currentModeHighScore = newStats.highScores[config.name] || 0;
        newStats.highScores[config.name] = Math.max(currentModeHighScore, score);
        onStatsChange(newStats);
        closeModal();
        setLevel(prevLevel => prevLevel + 1);
    };

    const triggerConfetti = () => confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
    
    const handleCheckHiddenWord = () => {
        if (!gameState || !gameState.hiddenWord) { return; }
        const getHiddenWordMultiplier = (attempts) => { const attemptNumber = attempts + 1; if (attemptNumber === 1) return 5; if (attemptNumber === 2) return 4; if (attemptNumber === 3) return 3; if (attemptNumber === 4) return 2; return 1; };
        const guessedWord = customToUpperCase(answerSlots.map(l => l && l.char).join(''));
        const correctWord = gameState.hiddenWord;
        if (guessedWord === correctWord) {
            playSound('achievementSound'); vibrate('achievement'); triggerConfetti();
            const newStats = { ...stats }; if (!newStats.modesCompleted) newStats.modesCompleted = {};
            newStats.modesCompleted[config.name] = true; let goldEarned = 0;
            if (config.name === 'easy' || config.name === 'super-easy') goldEarned = 1; else if (config.name === 'hard') goldEarned = 3; else if (config.name === 'timed-easy') goldEarned = 5; else if (config.name === 'timed-hard') goldEarned = 8;
            newStats.gold = (stats.gold || 0) + goldEarned;
            const attemptMultiplier = getHiddenWordMultiplier(hiddenWordAttempts);
            const hiddenWordBaseScore = (correctWord.length * 50); const finalHiddenWordScore = hiddenWordBaseScore * attemptMultiplier;
            const finalScore = score + finalHiddenWordScore; setScore(finalScore);
            const currentHighScore = newStats.highScores[config.name] || 0;
            newStats.highScores[config.name] = Math.max(currentHighScore, finalScore); onStatsChange(newStats);
            const shareText = `Kelime Avƒ±'nda ${level + 1}. seviyeyi tamamladƒ±m ve ${finalScore} puan aldƒ±m!`;
            setModalContent({
                isOpen: true, title: '', onClose: config?.isOneShot ? goToHome : goToNextLevel,
                body: ( <div className="text-white bg-gradient-to-br from-green-500 to-teal-600 rounded-2xl shadow-2xl p-6 text-center w-full max-w-sm"> <div className="text-6xl mb-3 animate-bounce">üèÜ</div> <h2 className="text-3xl font-black tracking-tight mb-2">Seviye Tamamlandƒ±!</h2> <div className="grid grid-cols-2 gap-4 text-left my-6 bg-black/20 p-4 rounded-xl"> <div className="border-r border-white/20 pr-4"> <p className="text-xs text-white/70 uppercase tracking-wider">Seviye</p> <p className="text-3xl font-bold">{level + 1}</p> </div> <div> <p className="text-xs text-white/70 uppercase tracking-wider">Kazanƒ±lan Altƒ±n</p> <p className="text-3xl font-bold">üí∞ +{goldEarned}</p> </div> <div className="col-span-2 text-center border-t border-white/20 pt-4"> <p className="text-sm font-semibold text-white/80 uppercase">Toplam Puan</p> <p className="text-5xl font-extrabold">{finalScore}</p> </div> </div> <div className="flex flex-col gap-3"> {config?.isOneShot ? ( <button onClick={goToHome} className="w-full px-4 py-3 bg-white text-green-700 font-bold rounded-lg transform transition-transform hover:scale-105 shadow-lg">Ana Sayfaya D√∂n</button> ) : ( <button onClick={goToNextLevel} className="w-full px-4 py-3 bg-white text-green-700 font-bold rounded-lg transform transition-transform hover:scale-105 shadow-lg">Sonraki Seviye ‚Üí</button> )} </div> <ShareButtons text={shareText} setToastMessage={setToastMessage} /> </div> )
            });
        } else {
            playSound('wrongSound'); vibrate('error'); setIsShaking(true); setTimeout(() => setIsShaking(false), 400); setHiddenWordAttempts(prev => prev + 1);
            const lettersToReturn = []; const newAnswerSlots = Array(gameState.hiddenWord.length).fill(null);
            answerSlots.forEach((letter, index) => { if (letter) { if (hintLockedSlots.includes(index)) { newAnswerSlots[index] = letter; } else { lettersToReturn.push(letter); } } });
            setSourceLetters(prevSource => _.shuffle([...prevSource, ...lettersToReturn])); setAnswerSlots(newAnswerSlots);
        }
    };
    
	const getModeDisplayName = (modeKey, translations) => {
        const keyMap = { 'super-easy': 'superEasyMode', 'easy': 'easyMode', 'hard': 'hardMode', 'timed-easy': 'timedEasyMode', 'timed-hard': 'timedHardMode' };
        const translationKey = keyMap[modeKey] || 'randomMode';
        return translations[translationKey] || modeKey;
    };
	
    const handleRevealWordHint = () => {
        const unfoundWords = gameState.words.filter(w => !foundWords.includes(w.word));
        if (stats.gold < 1 || unfoundWords.length === 0) return;
        const wordToReveal = _.sample(unfoundWords);
        onStatsChange({ ...stats, gold: stats.gold - 1 });
        setFoundWords(prev => [...prev, wordToReveal.word]);
        setJustFoundWordInfo({ word: wordToReveal.word, positions: wordToReveal.positions });
        setTimeout(() => setJustFoundWordInfo(null), 600);
        playSound('correctSound');
        vibrate('success');
    };

    const handleHiddenWordHint = () => {
        if (stats.gold < 1 || !gameState) return;
        const hintIndex = answerSlots.findIndex((slot, index) => slot === null && !hintLockedSlots.includes(index));
        if (hintIndex === -1) return;
        const correctChar = gameState.hiddenWord[hintIndex];
        let letterToMove = null;
        const newAnswerSlots = [...answerSlots];
        let newSourceLetters = [...sourceLetters];
        const sourceIdx = newSourceLetters.findIndex(l => l.char === correctChar);
        if (sourceIdx > -1) {
            letterToMove = newSourceLetters[sourceIdx];
            newSourceLetters.splice(sourceIdx, 1);
        } else {
            const wrongSlotIdx = newAnswerSlots.findIndex((l, i) => l?.char === correctChar && !hintLockedSlots.includes(i));
            if (wrongSlotIdx > -1) {
                letterToMove = newAnswerSlots[wrongSlotIdx];
                newAnswerSlots[wrongSlotIdx] = null;
            }
        }
        if (!letterToMove) return;
        if (newAnswerSlots[hintIndex]) {
            newSourceLetters.push(newAnswerSlots[hintIndex]);
        }
        newAnswerSlots[hintIndex] = letterToMove;
        setAnswerSlots(newAnswerSlots);
        setSourceLetters(_.shuffle(newSourceLetters));
        setHintLockedSlots(prev => [...prev, hintIndex]);
        onStatsChange({ ...stats, gold: stats.gold - 1 });
        playSound('correctSound');
    };

    const handleGoHomeClick = () => {
        // Tek seferlik rastgele oyunsa, uyarƒ± g√∂stermeden doƒürudan ana men√ºye d√∂n.
        if (config?.isOneShot) {
            goToHome();
            return;
        }

        // Diƒüer t√ºm durumlar i√ßin √ßƒ±kƒ±≈ü onayƒ± modalƒ±nƒ± g√∂ster.
        setModalContent({
            isOpen: true,
            title: '',
            onClose: closeModal,
            body: (
                <div className="w-full max-w-sm text-white bg-gradient-to-br from-slate-700 to-gray-800 rounded-2xl shadow-2xl p-6 text-center">
                    <div className="text-6xl mb-4">üëã</div>
                    <h2 className="text-2xl font-bold mb-2">{t.areYouSureTitle}</h2>
                    <p className="text-white/80 mb-6">{t.quitGameBody}</p>
                    <div className="flex justify-center gap-4">
                        <button onClick={closeModal} className="px-8 py-2 bg-white/20 text-white font-bold rounded-lg hover:bg-white/30">{t.stayButton}</button>
                        <button onClick={goToHome} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">{t.quitButton}</button>
                    </div>
                </div>
            )
        });
    };

	React.useEffect(() => {
        foundWordsRef.current = foundWords;
        computerStateRef.current = computerState;
    }, [foundWords, computerState]);

    React.useEffect(() => {
        if (isLoading || !isVsComputer || !gameState) {
            return;
        }
        const aiStrength = config.aiStrength || 'orta';
        const intervalTime = { zayif: 15000, orta: 11000, guclu: 7000 }[aiStrength];
        const computerMoveInterval = setInterval(() => {
            const currentFoundWordsByPlayer = foundWordsRef.current;
            const currentFoundWordsByComputer = computerStateRef.current.foundWords;
            const playerOccupiedCells = new Set();
            gameState.words.filter(w => currentFoundWordsByPlayer.includes(w.word)).forEach(wordInfo => {
                wordInfo.positions.forEach(pos => playerOccupiedCells.add(`${pos.row}-${pos.col}`));
            });
            const allCurrentlyFoundWords = [...currentFoundWordsByPlayer, ...currentFoundWordsByComputer];
            if (gameState.words.length > 0 && allCurrentlyFoundWords.length >= gameState.words.length) {
                clearInterval(computerMoveInterval);
                return;
            }
            const availableWords = gameState.words.filter(wordInfo => {
                if (allCurrentlyFoundWords.includes(wordInfo.word)) return false;
                const isOverlapping = wordInfo.positions.some(pos => playerOccupiedCells.has(`${pos.row}-${pos.col}`));
                return !isOverlapping;
            });
            if (availableWords.length > 0) {
                const wordToFind = _.sample(availableWords);
                setComputerState(prev => ({ score: prev.score + (wordToFind.word.length * 5), foundWords: [...prev.foundWords, wordToFind.word] }));
                playSound('correctSound');
            }
        }, intervalTime); 
        return () => clearInterval(computerMoveInterval);
    }, [isLoading, isVsComputer, gameState, config.aiStrength, playSound, setComputerState]);

    React.useEffect(() => {
		if (isLoading || !isVsComputer || !gameState || !gameState.words) return;
		const totalWords = gameState.words.length;
		if (totalWords === 0) return;
		const totalFoundCount = foundWords.length + computerState.foundWords.length;
		if (totalFoundCount >= totalWords) {
			const finalPlayerScore = score;
			const finalComputerScore = computerState.score;
			let resultTitle = ''; let resultIcon = 'ü§ù'; let cardClass = ''; let shareText = '';
			if (finalPlayerScore > finalComputerScore) {
				resultTitle = 'Tebrikler, Kazandƒ±n!'; resultIcon = 'üèÜ'; cardClass = 'from-green-500 to-teal-500';
				shareText = `Kelime Avƒ±'nda yapay zekayƒ± ${finalPlayerScore} - ${finalComputerScore} yendim! Sen de oyna!`;
			} else if (finalComputerScore > finalPlayerScore) {
				resultTitle = 'Kaybettin'; resultIcon = 'üòî'; cardClass = 'from-red-500 to-rose-600';
				shareText = `Kelime Avƒ±'nda yapay zekaya kar≈üƒ± oynadƒ±m. Skor: ${finalPlayerScore} - ${finalComputerScore}.`;
			} else {
				resultTitle = 'Berabere!'; resultIcon = 'ü§ù'; cardClass = 'from-sky-500 to-indigo-500';
				shareText = `Kelime Avƒ±'nda yapay zeka ile ${finalPlayerScore} - ${finalComputerScore} berabere kaldƒ±m!`;
			}
			setModalContent({
				isOpen: true,
				title: '',
				onClose: goToHome,
				body: (
					 <div className={`relative w-full max-w-sm text-white bg-gradient-to-br ${cardClass} rounded-2xl shadow-2xl p-6 text-center`}>
						<div className="text-6xl mb-4 animate-bounce">{resultIcon}</div>
						<h2 className="text-4xl font-black tracking-tighter mb-2">{resultTitle}</h2>
						<div className="bg-black/20 rounded-lg py-2 px-4 inline-block mb-4">
							<p className="text-3xl font-bold tabular-nums tracking-wide">{finalPlayerScore} - {finalComputerScore}</p>
							<p className="text-xs text-white/70 uppercase tracking-wider">Sen - Yapay Zeka</p>
						</div>
						<button onClick={goToHome} className="w-full mt-4 bg-white/90 hover:bg-white text-gray-800 font-bold py-3 px-8 rounded-lg shadow-lg">Ana Sayfaya D√∂n</button>
						<ShareButtons text={shareText} setToastMessage={setToastMessage} />
					</div>
				)
			});
		}
	}, [foundWords, computerState.foundWords, score, isVsComputer, isLoading, gameState]);

    React.useEffect(() => {
        if (isRealtimeDuel || !gameState || !Array.isArray(gameState.words) || gameState.words.length === 0) {
            return;
        }
        const allRequiredWords = gameState.words.map(w => w.word);
        const areAllFound = allRequiredWords.every(requiredWord => foundWords.includes(requiredWord));

        if (areAllFound) {
            setAllRequiredWordsFound(true);
        }
    }, [foundWords, gameState, isRealtimeDuel]);

    React.useEffect(() => {
        // Bu effect, oyunun durumunu (seviye, skor, bulunan kelimeler, kalan s√ºre)
        // her deƒüi≈ütiƒüinde localStorage'a kaydeder.
        // Bu sayede oyuncu oyundan √ßƒ±ksa bile kaldƒ±ƒüƒ± yerden devam edebilir.
        
        // √áok oyunculu, vs-computer veya tek seferlik rastgele oyunlarƒ± kaydetme.
        if (isRealtimeDuel || isVsComputer || config?.isOneShot) return;

        // Oyun hen√ºz y√ºklenmediyse veya bir hata varsa kaydetme.
        if (isLoading || isGenerating || !gameState) return;

        const saveKey = config.modeType === 'takip' ? `takip-${config.name}` : config.name;
        
        const gameStateToSave = {
            level,
            score,
            foundWords,
            timeLeft,
            gameState,
            mode: config.name,
            language: language,
            difficulty: config.difficulty,
            boardSize: config.boardSize,
            modeType: config.modeType
        };
        
        try {
            const currentSaves = JSON.parse(localStorage.getItem(ALL_SAVES_KEY)) || {};
            currentSaves[saveKey] = gameStateToSave;
            localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
        } catch (e) {
            console.error("Oyun kaydedilirken hata:", e);
        }

    }, [level, score, foundWords, timeLeft, gameState, isLoading, isGenerating]); // Baƒüƒ±mlƒ±lƒ±klarƒ± g√ºncelledik
    
	React.useEffect(() => {
		if (allRequiredWordsFound && gameState && gameState.hiddenWord && !isRealtimeDuel) {
			const wordLength = gameState.hiddenWord.length;
			const letters = _.shuffle(gameState.hiddenWord.split('')).map((char, index) => ({ id: `letter-${index}-${char}`, char: char }));
			setAnswerSlots(Array(wordLength).fill(null));
			setSourceLetters(letters);
			setHintLockedSlots([]);
			if (wordLength >= 8) {
				const firstChar = gameState.hiddenWord[0];
				const hintLetterIndex = letters.findIndex(l => l.char === firstChar);
				if (hintLetterIndex > -1) {
					const hintLetter = letters.splice(hintLetterIndex, 1)[0];
					const finalAnswerSlots = Array(wordLength).fill(null);
					finalAnswerSlots[0] = hintLetter;
					setAnswerSlots(finalAnswerSlots);
					setHintLockedSlots([0]);
					setSourceLetters(_.shuffle(letters));
				}
			}
		}
	}, [allRequiredWordsFound, gameState, isRealtimeDuel]);

    React.useEffect(() => {
        if (!config.name?.startsWith('timed') || !gameState || modalContent.isOpen || isRealtimeDuel) return;
        if (allRequiredWordsFound) {
            if (hiddenWordTimeLeft === 0) {
                vibrate('error');
                setModalContent({ isOpen: true, title: "S√ºre Bitti!", onClose: goToHome, body: ( <div className="flex flex-col items-center gap-4"> <p className="text-lg text-gray-700 text-center">T√ºh! S√ºre bitti.<br/>Bulman gereken gizli kelime <b className="text-red-600">{gameState.hiddenWord}</b> idi.</p> <button onClick={goToHome} className="bg-blue-600 text-white px-6 py-2 rounded-lg font-medium">{t.homeButton}</button> </div> ) });
                return;
            }
            const timerId = setInterval(() => setHiddenWordTimeLeft(t => t > 0 ? t - 1 : 0), 1000);
            return () => clearInterval(timerId);
        } else {
            if (timeLeft === 0) {
                vibrate('error');
                try {
                    const currentSaves = JSON.parse(localStorage.getItem(ALL_SAVES_KEY)) || {};
                    const savedGame = currentSaves[config.name];
                    if (savedGame) {
                        savedGame.foundWords = [];
                        savedGame.timeLeft = getInitialTime(config.name, savedGame.level);
                        currentSaves[config.name] = savedGame;
                        localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
                    }
                } catch (e) { console.error("S√ºre bittiƒüinde oyun kaydƒ± g√ºncellenirken hata:", e); }
                setModalContent({ isOpen: true, title: t.timeUp, onClose: goToHome, body: ( <div> <p className="text-xl mb-4">{t.finalScore(score)}</p> <button onClick={goToHome} className="bg-blue-600 text-white px-5 py-2 rounded-lg font-medium">{t.homeButton}</button> </div> ) });
                return;
            }
		    const timerId = setInterval(() => setTimeLeft(t => t > 0 ? t - 1 : 0), 1000);
		    return () => clearInterval(timerId);
        }
    }, [timeLeft, hiddenWordTimeLeft, config, gameState, modalContent.isOpen, allRequiredWordsFound, isRealtimeDuel]);

    React.useEffect(() => {
        if (allRequiredWordsFound && config.name?.startsWith('timed') && hiddenWordTimeLeft === null && !isRealtimeDuel && !isVsComputer) {
            const wordLength = gameState?.hiddenWord?.length || 5;
            const duration = 15 + (wordLength * 5);
            setHiddenWordTimeLeft(duration);
        }
    }, [allRequiredWordsFound, config, hiddenWordTimeLeft, gameState, isRealtimeDuel, isVsComputer]);

    React.useEffect(() => {
        if (isRealtimeDuel && realtimeGameData?.status === 'finished' && realtimeGameData.players) {
            const finalSortedPlayers = Object.entries(realtimeGameData.players).sort(([, a], [, b]) => b.score - a.score);
            const winnerUsername = finalSortedPlayers.length > 0 ? finalSortedPlayers[0][0] : null;
            const isWinner = winnerUsername === username;
            if (isWinner) { triggerConfetti(); }
            let shareText = `Kelime Avƒ±'nda √ßok oyunculu bir ma√ßƒ± tamamladƒ±m! Sonu√ßlar: `;
            finalSortedPlayers.forEach(([pName, pData]) => { shareText += `${pName}: ${pData.score}, `; });
            setModalContent({
                isOpen: true,
                title: '',
                onClose: goToHome,
                body: (
                     <div className={`relative w-full max-w-sm text-white bg-gradient-to-br ${isWinner ? 'from-green-500 to-teal-600' : 'from-slate-700 to-gray-800'} rounded-2xl shadow-2xl p-6 text-center`}>
                        <div className="text-6xl mb-4 animate-bounce">{isWinner ? 'üèÜ' : 'üèÅ'}</div>
                        <h2 className="text-4xl font-black tracking-tighter mb-2">{isWinner ? "Kazandƒ±n!" : "Oyun Bitti!"}</h2>
                        <p className="text-white/80 mb-4">ƒ∞≈üte sonu√ßlar:</p>
                        <div className="space-y-2 text-left bg-black/20 p-3 rounded-lg w-full">
                            {finalSortedPlayers.map(([pName, pData], index) => (
                                <div key={pName} className={`flex justify-between items-center text-lg p-2 rounded ${pName === username ? 'bg-yellow-500/30' : ''}`}>
                                    <span className="font-semibold flex items-center gap-2">
                                       <span className="w-6 text-center">{index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`}</span>
                                       {pName}
                                    </span>
                                    <span className="font-bold">{pData.score}</span>
                                </div>
                            ))}
                        </div>
                        <button onClick={goToHome} className="w-full mt-6 bg-white/90 hover:bg-white text-gray-800 font-bold py-3 px-8 rounded-lg shadow-lg">Ana Sayfaya D√∂n</button>
                        <ShareButtons text={shareText} setToastMessage={setToastMessage} />
                    </div>
                )
            });
        }
    }, [realtimeGameData, username]);

	if (isLoading || isGenerating) {
        // HATA D√úZELTƒ∞LDƒ∞: Metin, artƒ±k var olan √ßeviri anahtarlarƒ±yla olu≈üturuluyor.
        const levelText = t.level;
        const levelNumber = level + 1;
        const loadingStatusText = t.loading + "...";
        
		return (
            <div className="h-full w-full flex flex-col items-center justify-center text-white p-4" style={{
                background: 'linear-gradient(135deg, #4f46e5, #7c3aed, #db2777, #f59e0b)',
                backgroundSize: '400% 400%',
                animation: 'gradient-animation 10s ease infinite'
            }}>
                {/* Zƒ±playan oyun logosu */}
                <img src="logo.png" alt="Oyun Logosu" className="w-36 h-36 mb-8 drop-shadow-lg animate-bounce" />
                
                {/* Farklƒ± renkteki metinler */}
                <div className="text-center">
                    <p className="text-5xl font-black tracking-tighter" style={{ textShadow: '2px 2px 4px rgba(0,0,0,0.5)' }}>
                        <span className="text-cyan-300">{levelText}</span>
                        <span className="text-white mx-3">{levelNumber}</span>
                        <span className="text-amber-300">{loadingStatusText}</span>
                    </p>
                </div>

                {/* Hareketli y√ºkleme √ßubuƒüu */}
                <div className="w-64 max-w-full mt-10 bg-white/20 rounded-full h-3 overflow-hidden shadow-inner">
                    <div className="bg-white h-3 rounded-full animate-loading-bar-slide"></div>
                </div>
            </div>
        );
	}

    if (error) { return (<div className="flex flex-col items-center justify-center h-full p-4 text-center"><p className="text-lg font-semibold text-red-600">{error}</p><button onClick={goToHome} className="mt-4 bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600">Ana Sayfaya D√∂n</button></div>); }
    
    if (!gameState || !board || !board[0] || !Array.isArray(gameState.words) || !gameState.hiddenWord) {
        return ( <div className="flex flex-col items-center justify-center h-full p-4 text-center"> <p className="text-lg font-semibold text-orange-600">Oyun verileri beklenmedik bir ≈üekilde eksik. L√ºtfen oyunu yeniden ba≈ülatƒ±n.</p> <button onClick={() => { localStorage.removeItem('wordHuntAllSaves'); window.location.reload(); }} className="mt-4 bg-orange-500 text-white px-4 py-2 rounded-lg hover:bg-orange-600"> Hafƒ±zayƒ± Temizle ve Yeniden Ba≈ülat </button> </div> );
    }
     
	if (isRealtimeDuel) {
		const sortedPlayers = realtimeGameData && realtimeGameData.players ? Object.entries(realtimeGameData.players).sort(([, a], [, b]) => b.score - a.score) : [];
		return (
			<div className="h-full w-full flex flex-col items-center py-2 sm:py-4 bg-indigo-50">
				<div className="container w-full h-full flex flex-col gap-1 text-center text-gray-800 p-1">
					<div className="flex-shrink-0 w-full grid grid-cols-4 gap-1 mb-1">
						{sortedPlayers.map(([playerName, playerData]) => {
							const playerCard = playerCardColors.find(c => c.id === playerData.cardColor);
							const cardBgClass = playerCard ? playerCard.class : 'bg-gradient-to-br from-slate-500 to-gray-600';
							return (
								<div key={playerName} className={`p-1.5 rounded-lg text-white shadow-md text-center ${cardBgClass} ${username === playerName ? 'ring-2 ring-yellow-400 ring-offset-2 ring-offset-indigo-50' : ''}`}>
									<p className="font-bold text-xs truncate" title={playerName}>{playerName}</p>
									<p className="font-extrabold text-base">{playerData.score}</p>
								</div>
							);
						})}
					</div>
					<div ref={gridRef} className="flex-shrink-0 grid gap-0.5 p-1 rounded-lg bg-indigo-100 w-full max-w-2xl mx-auto aspect-square shadow-inner"
						style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }}
						onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)}
						onMouseMove={(e) => throttledMouseMove(e.clientX, e.clientY)}
						onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd}
						onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)}
						onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd} >
						
						{board.map((row, r) => row.map((letter, c) => {
							const isSelected = selectedCells.some(cell => cell.row === r && cell.col === c);
							const owner = cellOwnerMap[`${r}-${c}`];
							let cellClass = 'bg-white text-gray-800 hover:bg-gray-200';
							if (isSelected) {
								cellClass = 'bg-yellow-300 text-black transform scale-110 shadow-lg';
							} else if (owner && realtimeGameData.players[owner]) {
								const sortedPlayersForColor = Object.keys(realtimeGameData.players).sort();
								const playerIndex = sortedPlayersForColor.indexOf(owner);
								const colorInfo = wordFoundColors[playerIndex % wordFoundColors.length];
								cellClass = `${colorInfo.bg} ${colorInfo.text}`;
							}
							return (<div key={`${r}-${c}`} data-row={r} data-col={c} className={`flex items-center justify-center aspect-square text-center font-bold rounded-sm transition-all duration-150 select-none ${cellClass}`}>{letter}</div>);
						}))}
					</div>
					<div className="flex-1 min-h-0 w-full max-w-2xl mx-auto mt-1 flex flex-col bg-white rounded-lg shadow">
						<div className="flex-1 overflow-y-auto scrollbar-thin p-2">
							<div className="flex flex-wrap justify-center content-start gap-x-1.5 gap-y-1">
								{(() => {
									const allFoundWordsCombined = new Set(Object.values(realtimeGameData.players).flatMap(p => p.foundWords));
									const allWordsInLevel = realtimeGameData.boardData ? realtimeGameData.boardData.words : [];
									return allWordsInLevel.map(({ word }) => {
										const isFound = allFoundWordsCombined.has(word);
										const isHidden = realtimeGameData.gameSettings.difficulty === 'hard' && !isFound;
										return (
											<span key={word} className={`font-medium transition-all duration-300 rounded-md px-2 py-1 text-xs ${ isFound ? 'bg-gray-300 text-gray-500 line-through opacity-60' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : 'bg-indigo-100 text-gray-800' }`}>
												{isHidden ? '???' : word}
											</span>
										);
									});
								})()}
							</div>
						</div>
					</div>
					<div className="flex-shrink-0 w-full">
						<button onClick={showExitConfirmation} className="w-full py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition-all text-sm">Oyundan √áƒ±k (Terk Et)</button>
					</div>
					<Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.body}</Modal>
				</div>
			</div>
		);
	}

    if (isVsComputer) {
        const allWordsInLevel = gameState.words; const allFoundWordsCombined = new Set([...foundWords, ...computerState.foundWords]);
        const calculateFontSize = (numCols) => { if (!numCols) return { fontSize: '18px' }; const maxGridWidth = 768; const targetRatio = 0.8; const minFontSize = 10; const preferredVw = (100 / numCols) * targetRatio; const maxFontSize = (maxGridWidth / numCols) * targetRatio; return { fontSize: `clamp(${minFontSize}px, ${preferredVw.toFixed(2)}vw, ${maxFontSize.toFixed(2)}px)` }; };
        const fontSizeStyle = calculateFontSize(board?.[0]?.length);
        return ( <div className="h-full w-full flex flex-col items-center py-2 sm:py-4 bg-indigo-50"> <div className="container w-full h-full flex flex-col gap-2 text-center text-gray-800 p-1"> <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.body}</Modal> <div className="flex-shrink-0 w-full max-w-2xl mx-auto"> <div className="flex justify-between items-center bg-white p-1.5 rounded-lg shadow-sm"> <div className="flex items-center gap-2 w-2/5 justify-start"><span className="font-semibold text-sm truncate text-indigo-700">Siz</span><span className="text-lg font-bold text-green-600">{score}</span></div> <span className="text-sm font-bold text-gray-400">VS</span> <div className="flex items-center gap-2 w-2/5 justify-end"><span className="font-semibold text-sm truncate text-gray-600">Bilgisayar ({config.difficulty})</span><span className="text-lg font-bold text-red-600">{computerState.score}</span></div> </div> </div> <div className="flex-shrink-0 w-full max-w-2xl mx-auto"> <div ref={gridRef} className="grid gap-0.5 p-1 rounded-lg bg-indigo-100 w-full aspect-square shadow-inner" style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }} 
            onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)} 
            onMouseMove={(e) => throttledMouseMove(e.clientX, e.clientY)}
            onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd} 
            onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)} 
            onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd} >
            {board.map((row, r) => row.map((letter, c) => { const isSelected = selectedCells.some(cell => cell.row === r && cell.col === c); const foundBy = isCellFound(r, c); let cellClass = 'bg-white text-gray-800 hover:bg-gray-200'; if (isSelected) { cellClass = 'bg-yellow-300 text-black transform scale-110 shadow-lg'; } else if (foundBy === 'player') { cellClass = 'bg-green-300 text-green-800'; } else if (foundBy === 'computer') { cellClass = 'bg-red-300 text-red-800'; } return ( <div key={`${r}-${c}`} data-row={r} data-col={c} className={`flex items-center justify-center aspect-square text-center font-bold rounded-sm transition-all duration-150 select-none ${cellClass}`} style={fontSizeStyle}> {letter} </div> ); }))} </div> </div> <div className="flex-1 min-h-0 w-full max-w-2xl mx-auto"> <div className="bg-white rounded-lg p-1 shadow h-full overflow-y-auto scrollbar-thin"> <div className="flex flex-wrap justify-center content-start gap-x-1.5 gap-y-1 p-1"> {allWordsInLevel.map(({ word }) => { const isFound = allFoundWordsCombined.has(word); const isHidden = config.difficulty === 'hard' && !isFound; return (<span key={word} className={`font-medium transition-all duration-300 rounded-md px-2 py-1 text-xs ${ isFound ? 'bg-gray-300 text-gray-500 line-through opacity-50' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : 'bg-indigo-100 text-gray-800' }`}>{isHidden ? '???' : word}</span>); })} </div> </div> </div> <div className="flex-shrink-0 w-full max-w-2xl mx-auto"> <button onClick={showExitConfirmation} className="w-full py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition-all text-sm">Ana Men√ºye D√∂n</button> </div> </div> </div> );
    }

    const calculateFontSize = (numCols) => {
        if (!numCols) return { fontSize: '18px' };
        const maxGridWidth = 768; const targetRatio = 0.8; const minFontSize = 10;
        const preferredVw = (100 / numCols) * targetRatio;
        const maxFontSize = (maxGridWidth / numCols) * targetRatio;
        return { fontSize: `clamp(${minFontSize}px, ${preferredVw.toFixed(2)}vw, ${maxFontSize.toFixed(2)}px)`, fontWeight: '900' };
    };

    const fontSizeStyle = calculateFontSize(board?.[0]?.length);
    
    return (
        <div className="relative h-screen w-full">
            <div className={`h-screen w-full flex flex-col p-2 gap-2 text-center overflow-hidden ${theme.bg}`}>
                <div className="w-full flex-shrink-0 grid grid-cols-3 gap-2">
    {/* S√úRE SOLA ALINDI */}
    <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm">
        {(config.name?.startsWith('timed') && !allRequiredWordsFound) ? ( <div key={timeLeft} className="animate-timer-pulse flex items-center justify-center gap-1 text-blue-600 tabular-nums" title="Kalan S√ºre"> <span className="text-xl">‚è±Ô∏è</span> <span className="font-bold text-sm">{Math.floor(timeLeft / 60)}:{(timeLeft % 60).toString().padStart(2, '0')}</span> </div> ) : ( <div className="flex items-center justify-center gap-1 text-slate-400" title="Bu modda s√ºre yoktur"> <span className="text-xl">‚è±Ô∏è</span> <span className="font-bold text-sm">-:--</span> </div> )}
    </div>
    {/* ALTIN ORTADA KALDI */}
    <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm" title={t.gold}><span className="text-xl">üí∞</span><span className="font-bold text-sm text-amber-600">{stats.gold || 0}</span></div>
    {/* PUAN SAƒûA ALINDI */}
    <div className="bg-white/80 hover:bg-white border border-slate-200 rounded-xl p-0.5 flex flex-row items-center justify-center gap-1 text-slate-700 shadow-sm" title={t.score}><span className="text-xl">‚≠ê</span><span className="font-bold text-sm text-green-600">{score}</span></div>
</div>
               {!allRequiredWordsFound && (
                    <div className="flex-1 min-h-0 p-2 bg-gray-100 rounded-lg overflow-y-auto scrollbar-thin flex">
                        <div className="flex flex-wrap justify-center items-center gap-x-2 gap-y-1 m-auto">
                            {gameState.words.map(({ word }) => {
                                const isFound = foundWords.includes(word);
                                const isHidden = (config.name === 'hard' || config.name === 'timed-hard') && !isFound;
                                const sizeClasses = config.name === 'super-easy' ? 'px-4 py-2 text-lg' : 'px-1 py-1 text-base';
                                return ( <span key={word} className={`transition-all duration-500 rounded-lg ${sizeClasses} ${isFound ? 'bg-gray-300 text-gray-500 line-through opacity-50' : isHidden ? 'bg-gray-400 text-transparent pointer-events-none' : theme.wordBg + ' text-gray-800'}`}> {isHidden ? '?????' : word} </span> );
                            })}
                        </div>
                    </div>
                )}
                <div className="w-full flex-shrink-0">
                    {!allRequiredWordsFound ? (
                        <div ref={gridRef} className={`grid gap-0.5 content-start rounded-lg shadow-md w-full max-w-full mx-auto aspect-square ${theme.gridBg}`} 
                            style={{ gridTemplateColumns: `repeat(${board[0].length}, minmax(0, 1fr))` }} 
                            onMouseDown={(e) => handleInteractionStart(e.clientX, e.clientY)} 
                            onMouseMove={(e) => throttledMouseMove(e.clientX, e.clientY)} 
                            onMouseUp={handleInteractionEnd} onMouseLeave={handleInteractionEnd} 
                            onTouchStart={(e) => handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)} 
                            onTouchEnd={handleInteractionEnd} onTouchCancel={handleInteractionEnd} >
                        {(() => {
                            const numCols = board[0] ? board[0].length : 1;
							return board.map((row, rowIndex) => row.map((letter, colIndex) => { 
								const isSelected = selectedCells.some(cell => cell.row === rowIndex && cell.col === colIndex);
								const isFoundPart = isCellFound(rowIndex, colIndex); 
								const isJustFound = justFoundWordInfo?.positions.some(p => p.row === rowIndex && p.col === colIndex); 
								const isBonusGlowCell = bonusGlowCells.some(cell => cell.row === rowIndex && cell.col === colIndex); 
								const colorInfo = foundCellColorMap[`${rowIndex}-${colIndex}`];
								return <Cell key={`${rowIndex}-${colIndex}`} letter={letter} isSelected={isSelected} isFoundRequiredPart={!!isFoundPart} isJustFound={isJustFound} isBonusGlow={isBonusGlowCell} theme={theme} numCols={numCols} foundWordColorInfo={colorInfo} rowIndex={rowIndex} colIndex={colIndex} />;
							}));
                        })()}
                        </div>
                    ) : (
                        <div className="w-full h-full flex items-center justify-center overflow-y-auto overflow-x-hidden scrollbar-thin bg-white rounded-lg">
                            <div className="w-full max-w-2xl mx-auto p-2">
                                <p className="font-bold text-lg text-indigo-700">{t.hiddenWord}</p>
                                {hiddenWordTimeLeft !== null && <div key={hiddenWordTimeLeft} className="animate-timer-pulse text-xl font-bold text-red-600 my-2">Kalan S√ºre: {hiddenWordTimeLeft}s</div>}
                                <div id="answer-area-container" className={`my-2 p-1 bg-gray-200 rounded-lg w-full flex flex-wrap justify-center gap-2 ${isShaking ? 'shake-animation' : ''}`}>{answerSlots.map((letter, index) => ( <div key={index} onClick={() => handleAnswerSlotClick(letter, index)} className={`w-12 h-12 aspect-square flex items-center justify-center rounded-md text-4xl leading-none font-bold transition-all ${hintLockedSlots.includes(index) ? 'bg-amber-300 cursor-not-allowed' : 'bg-white shadow-inner cursor-pointer hover:bg-red-100'} text-gray-800`}>{letter ? letter.char : ''}</div> ))}</div>
                                <p className="text-sm text-gray-600 mt-4 mb-2">Kalan Harfler</p>
                                <div className="p-2 bg-gray-200 rounded-lg w-full flex flex-wrap justify-center gap-2 min-h-[64px]">{sourceLetters.map(letter => ( <button key={letter.id} onClick={() => handleSourceLetterClick(letter)} className="w-12 h-12 flex items-center justify-center rounded-md bg-sky-500 text-white text-2xl font-bold shadow-md hover:bg-sky-600 active:scale-90 transition-all">{letter.char}</button> ))}</div>
                                <button onClick={handleCheckHiddenWord} disabled={answerSlots.some(l => l === null)} className="mt-4 w-full bg-green-500 text-white rounded-lg py-3 font-bold hover:bg-green-600 transition-transform active:scale-95 disabled:bg-gray-400 disabled:cursor-not-allowed">{t.checkButton}</button>
                            </div>
                        </div>
                    )}
                </div>
				<div className="w-full flex-shrink-0 mb-1" style={{ fontFamily: "'Nunito', sans-serif" }}>
					<div className={`bg-gradient-to-r ${infoBarClass} border border-slate-200 rounded-xl p-1 text-center shadow-sm flex items-center justify-center divide-x-2 divide-slate-300/50`}>
						<div className="px-3 flex items-center gap-1.5">
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4 opacity-70"> <path d="M15.5 2A1.5 1.5 0 0014 3.5v13a1.5 1.5 0 001.5 1.5h1a1.5 1.5 0 001.5-1.5v-13A1.5 1.5 0 0016.5 2h-1zM9.5 6A1.5 1.5 0 008 7.5v9a1.5 1.5 0 001.5 1.5h1a1.5 1.5 0 001.5-1.5v-9A1.5 1.5 0 0010.5 6h-1zM3.5 10A1.5 1.5 0 002 11.5v5a1.5 1.5 0 001.5 1.5h1a1.5 1.5 0 001.5-1.5v-5A1.5 1.5 0 004.5 10h-1z" /> </svg>
							<p className="font-semibold text-xs sm:text-sm"> Mod: <span className="font-extrabold">{getModeDisplayName(config.name, t)}</span> </p>
						</div>
						<div className="px-3 flex items-center gap-1.5">
							 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4 opacity-70"> <path fillRule="evenodd" d="M10.868 2.884c.321-.772 1.305-.772 1.626 0l1.83 4.425a1 1 0 00.95.69h4.642c.81 0 1.133 1.04.546 1.593l-3.75 2.725a1 1 0 00-.364 1.118l1.42 4.134c.245.714-.638 1.342-1.285.933l-3.89-2.82a1 1 0 00-1.176 0l-3.89 2.82c-.647.409-1.53-.219-1.285-.933l1.42-4.134a1 1 0 00-.364-1.118L2.054 9.592c-.587-.553-.264-1.593.546-1.593h4.642a1 1 0 00.95-.69l1.83-4.425z" clipRule="evenodd" /> </svg>
							<p className="font-semibold text-xs sm:text-sm"> Seviye: <span className="font-extrabold">{level + 1}</span> </p>
						</div>
					</div>
				</div>
				<div className="w-full flex-shrink-0 grid grid-cols-2 gap-2">
					<button onClick={handleGoHomeClick} title={t.homeButton} className="w-full rounded-xl p-1 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-white/80 hover:bg-white border border-slate-200 text-slate-700"><span className="text-base">üè†</span><span>Anasayfa</span></button>
					{allRequiredWordsFound ? ( <button onClick={handleHiddenWordHint} disabled={stats.gold < 1} className="w-full rounded-xl p-1 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-sky-500 hover:bg-sky-600 text-white disabled:bg-slate-400 disabled:text-white/80 disabled:cursor-not-allowed"> <span className="text-base">üîë</span> <span>ƒ∞pucu</span> <span className="opacity-80 font-normal">(-1üí∞)</span> </button> ) : ( <button onClick={handleRevealWordHint} disabled={stats.gold < 1 || (gameState && foundWords.length === gameState.words.length)} className="w-full rounded-xl p-1 flex flex-row items-center justify-center gap-2 shadow-sm font-bold text-sm bg-amber-500 hover:bg-amber-600 text-white disabled:bg-slate-400 disabled:text-white/80 disabled:cursor-not-allowed"> <span className="text-base">üîé</span> <span>A√ß</span> <span className="opacity-80 font-normal">(-1üí∞)</span> </button> )}
				</div>
                <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={modalContent.onClose || closeModal}>{modalContent.body}</Modal>
            </div>
        </div>
    );
});






function DuelModeModal({ isOpen, onClose, duelProgress, startGame, currentUser, goToHome }) {
        if (!isOpen || !duelProgress) return null;
        const t = translations['tr'] || translations['en'];
        const [activeTab, setActiveTab] = React.useState('super-easy');
        const [scores, setScores] = React.useState({});
        const [loading, setLoading] = React.useState(true);

        const duelModes = [
            { key: 'super-easy', title: t.superEasyMode, icon: 'üß∏', color: 'from-sky-500 to-cyan-400' },
            { key: 'easy', title: t.easyMode, icon: 'üòä', color: 'from-blue-500 to-indigo-500' },
            { key: 'hard', title: t.hardMode, icon: 'üî•', color: 'from-purple-600 to-violet-600' },
            { key: 'timed-easy', title: t.timedEasyMode, icon: '‚è±Ô∏è', color: 'from-emerald-500 to-teal-500' },
            { key: 'timed-hard', title: t.timedHardMode, icon: '‚ö°', color: 'from-slate-700 to-gray-800' }
        ];

        const leaderboardTabs = [
            { key: 'super-easy', line1Key: '√ßok', line2Key: 'kolay', activeBg: 'bg-green-500' },
            { key: 'easy', line1Key: 'kolay', line2Key: 'normal', activeBg: 'bg-teal-500' },
            { key: 'hard', line1Key: 'zor', line2Key: 'normal', activeBg: 'bg-red-500' },
            { key: 'timed-easy', line1Key: 's√ºreli', line2Key: 'kolay', activeBg: 'bg-blue-500' },
            { key: 'timed-hard', line1Key: 's√ºreli', line2Key: 'zor', activeBg: 'bg-orange-500' }
        ];

        React.useEffect(() => {
            if (isOpen) {
                setLoading(true);
                const fetchPromises = leaderboardTabs.map(tab =>
                    db.collection("duel-scores")
                        .where("mode", "==", tab.key)
                        .orderBy("score", "desc")
                        .limit(50)
                        .get()
                );
                Promise.all(fetchPromises)
                    .then(snapshots => {
                        const newScores = {};
                        snapshots.forEach((snapshot, index) => {
                            const mode = leaderboardTabs[index].key;
                            newScores[mode] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        });
                        setScores(newScores);
                    })
                    .catch(error => console.error("D√ºello liderlik tablosu verileri √ßekilirken hata olu≈ütu:", error))
                    .finally(() => setLoading(false));
            }
        }, [isOpen]);

        return (
            <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-2 sm:p-4" onClick={onClose}>
                <div className="bg-white dark:bg-gray-900 p-4 sm:p-6 rounded-2xl shadow-2xl max-w-4xl w-full text-center relative max-h-[95vh] overflow-y-auto scrollbar-thin" onClick={e => e.stopPropagation()}>
                    <h3 className="text-3xl sm:text-4xl font-black mb-6 text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-indigo-600">üèÜ D√úELLO MEYDANI üèÜ</h3>
                    <button onClick={onClose} className="absolute top-3 right-3 text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 text-4xl">&times;</button>
                    <div className="grid grid-cols-2 gap-3 sm:gap-4 mb-8">
                        {duelModes.map(modeInfo => {
                            const progress = duelProgress[modeInfo.key] || { currentLevel: 0, cumulativeScore: 0 };
                            return (
                                <div key={modeInfo.key} className={`flex flex-col text-white rounded-2xl shadow-lg bg-gradient-to-br ${modeInfo.color} transform hover:-translate-y-1 transition-transform`}>
                                     <div className="flex justify-between items-start p-3 rounded-t-lg bg-black/20">
                                        <h4 className="text-lg sm:text-xl font-bold">{modeInfo.title}</h4>
                                        <span className="text-3xl sm:text-4xl opacity-80">{modeInfo.icon}</span>
                                    </div>
                                    <div className="bg-black/10 p-3 text-xs sm:text-sm space-y-1 text-left">
                                        <p>Mevcut Seviye: <span className="font-bold sm:text-base">{progress.currentLevel + 1}</span></p>
                                        <p>Toplam Puan: <span className="font-bold sm:text-base">{progress.cumulativeScore}</span></p>
                                    </div>
                                    <button onClick={() => startGame(modeInfo.key)} className="w-full bg-white/30 hover:bg-white/40 backdrop-blur-sm font-bold py-2 sm:py-3 rounded-b-lg transition-all text-base sm:text-lg">
                                        {progress.currentLevel > 0 ? 'DEVAM ET' : 'BA≈ûLA'}
                                    </button>
                                 </div>
                            );
                        })}
                    </div>
                    <hr className="my-6 border-gray-300 dark:border-gray-700"/>
                    <div>
                         <div className="flex justify-between items-center mb-4 px-1">
                            <h4 className="text-2xl font-bold text-gray-800 dark:text-gray-100 uppercase">D√úELLO Lƒ∞DERLERƒ∞</h4>
                            <button onClick={onClose} className="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all text-sm flex items-center gap-2">
        üè† <span>Anasayfa</span>
    </button>
                        </div>
                        <div className="flex items-center border-b-2 border-gray-200 dark:border-gray-700">
                             {leaderboardTabs.map(tab => {
                                 const isActive = activeTab === tab.key;
                                 return (
                                     <button key={tab.key} onClick={() => setActiveTab(tab.key)} className={`flex-1 flex flex-col justify-center items-center h-14 py-1 text-center transition-all duration-300 border-x border-transparent ${isActive ? `${tab.activeBg} scale-105 z-10 rounded-t-lg` : 'hover:bg-gray-100 dark:hover:bg-gray-800'}`}>
                                         <span className={`block text-xs font-bold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}>
                                             {t[tab.line1Key]}
                                         </span>
                                         <span className={`block text-xs font-semibold leading-tight uppercase ${isActive ? 'text-white' : 'text-gray-500 dark:text-gray-400'}`}>
                                             {t[tab.line2Key]}
                                         </span>
                                     </button>
                                 );
                             })}
                         </div>
                        <div className="min-h-[250px]">
                        {loading
                            ? <p className="text-gray-600 dark:text-gray-400 pt-10">Liderlik tablosu y√ºkleniyor...</p>
                            : <DuelLeaderboardDisplay scores={scores[activeTab]} currentUser={currentUser} />
                        }
                    </div>
                </div>
            </div>
        </div>
    );
    }
        



function UsernamePrompt({ onSave, language }) {
    const t = translations[language] || translations['en'];
    const [name, setName] = React.useState('');
    const [isLoading, setIsLoading] = React.useState(false);
    const [error, setError] = React.useState('');
    
    const handleSave = async () => {
        if (!name.trim()) return;
        setIsLoading(true);
        setError('');
        const success = await onSave(name.trim());
        if (!success) {
            setError(t.usernameTaken);
            setIsLoading(false);
        }
    };
    
    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
            <div className="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm text-center">
                <h3 className="text-2xl font-bold mb-4 text-gray-800">{t.welcome}</h3>
                <p className="text-gray-600 mb-5">{t.usernamePrompt}</p>
                <input
                    type="text"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    className="w-full border-2 border-gray-300 p-2 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-indigo-400"
                    placeholder={t.usernamePlaceholder}
                    maxLength={15}
                    disabled={isLoading}
                />
                {error && <p className="text-red-500 text-sm mt-2">{error}</p>}
                <button
                    onClick={handleSave}
                    disabled={!name.trim() || isLoading}
                    className="w-full mt-4 bg-indigo-600 text-white font-bold px-6 py-3 rounded-lg hover:bg-indigo-700 transition-all shadow-lg disabled:bg-gray-400 disabled:cursor-not-allowed"
                >
                    {isLoading ? t.checking : t.saveAndStart}
                </button>
            </div>
        </div>
    );
}
        
function DuelLeaderboardDisplay({ scores, currentUser }) {
            if (!scores || scores.length === 0) {
                return <p className="text-gray-600 dark:text-gray-400 pt-10">Bu d√ºello kategorisinde hen√ºz skor bulunmuyor.</p>;
            }
            const rankIcons = ['ü•á', 'ü•à', 'ü•â'];
            return (
                <div className="text-left overflow-y-auto max-h-[250px] mt-4 pr-2 scrollbar-thin">
                    <ul className="space-y-2">
                        {scores.map((score, index) => {
                            const isCurrentUser = score.username === currentUser;
                            return (
                                <li key={score.id || index} className={`flex items-center p-3 rounded-lg transition-all ${isCurrentUser ? 'bg-purple-100 dark:bg-purple-800/20 border-2 border-purple-400' : 'bg-gray-50 dark:bg-gray-800'}`}>
                                    <span className="font-bold text-lg w-10 text-center text-gray-500 dark:text-gray-400">{rankIcons[index] || index + 1}</span>
                                    <div className="flex-1">
                                        <p className={`font-semibold text-gray-800 dark:text-gray-200 ${isCurrentUser ? 'text-purple-900 dark:text-purple-300' : ''}`}>{score.username}</p>
                                        <p className={`text-xs text-gray-500 dark:text-gray-400 ${isCurrentUser ? 'text-purple-800 dark:text-purple-400' : ''}`}>Seviye {score.level}</p>
                                    </div>
                                    <span className={`font-bold text-xl text-indigo-600 dark:text-indigo-400 tabular-nums ${isCurrentUser ? 'text-purple-900 dark:text-purple-300' : ''}`}>{score.score}</span>
                                </li>
                            );
                        })}
                    </ul>
                </div>
            );
        }

    window.androidBridge = {
        onBackPress: () => {
            if (typeof window.androidBridge.registered_onBackPress === 'function') {
                window.androidBridge.registered_onBackPress();
            }
        },
        registered_onBackPress: null,
        receiveFCMToken: (token) => {
            pendingFCMToken = token;
            const currentUser = localStorage.getItem('wordHuntUsername');
            if (currentUser) {
                saveTokenForUser(currentUser, token);
            } else {
            }
        },
        };

    let pendingFCMToken = null;

    const saveTokenForUser = async (username, token, maxRetries = 3, toastCallback = null) => {
        if (!username || !token) return;

        const userRef = db.collection("users").doc(username);

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                await userRef.set({ fcmToken: token }, { merge: true });
                pendingFCMToken = null;
                return;
            } catch (error) {
                console.error(`WebAppLog: FCM token kaydetme denemesi ${attempt} ba≈üarƒ±sƒ±z oldu. Hata:`, error);
                if (attempt === maxRetries) {
                    const errorMessage = "Bildirim ayarlarƒ± yapƒ±lamadƒ±. ƒ∞nternetinizi kontrol edin.";
                    console.error(`WebAppLog: T√ºm denemelere raƒümen FCM token kaydedilemedi. Kullanƒ±cƒ±ya g√∂sterilen hata: ${errorMessage}`);
                    if (toastCallback) {
                        toastCallback(errorMessage);
                    }
                } else {
                    const delay = Math.pow(2, attempt) * 1000;
                    await new Promise(res => setTimeout(res, delay));
                }
            }
        }
    };


    function App() {
        const [page, setPage] = React.useState('home');
        const [language, setLanguage] = React.useState('tr');
        const [modeConfig, setModeConfig] = React.useState({ name: 'easy' });
        const [gameStats, setGameStats] = React.useState(loadGameStats);
        const [modalContent, setModalContent] = React.useState({ isOpen: false, title: '', body: null });
        const [allSaves, setAllSaves] = React.useState(null);
        const [username, setUsername] = React.useState('');
        const [gold, setGold] = React.useState(0);
        const [showUsernamePrompt, setShowUsernamePrompt] = React.useState(false);
        const [isInitializing, setIsInitializing] = React.useState(true);
        const [gameId, setGameId] = React.useState(null);
        const [showAppExitModal, setShowAppExitModal] = React.useState(false);
        const [toastMessage, setToastMessage] = React.useState(null);
        const [incomingInvitation, setIncomingInvitation] = React.useState(null);
        const [isAvatarModalOpen, setIsAvatarModalOpen] = React.useState(false);
        const [avatarId, setAvatarId] = React.useState(null);
        const [isProfileModalOpen, setIsProfileModalOpen] = React.useState(false);
        const [friendRequest, setFriendRequest] = React.useState(null);
        const [cardColor, setCardColor] = React.useState(null);
		const [unlockedAvatars, setUnlockedAvatars] = React.useState(['avatar1']);
        const [unlockedColors, setUnlockedColors] = React.useState(['gray']);
        const [directInvite, setDirectInvite] = React.useState(null);
        const [updateInfo, setUpdateInfo] = React.useState({ required: false, url: '' });
        const [gameKey, setGameKey] = React.useState(null);
        const [isLeaderboardModalOpen, setLeaderboardModalOpen] = React.useState(false); 
	const wordHuntRef = React.useRef(null);

        const loadUserData = async (user) => {
        const userRef = db.collection("users").doc(user);
        const doc = await userRef.get();
        if (doc.exists) {
            const userData = doc.data();
            setUsername(user);
            setGold(userData.gold || 0);
            setAvatarId(userData.avatarId || 'avatar1');
            setCardColor(userData.cardColor || 'gray');
            setUnlockedAvatars(userData.unlockedAvatars || ['avatar1']);
            setUnlockedColors(userData.unlockedColors || ['gray']);
        } else {
            localStorage.removeItem('wordHuntUsername');
            setShowUsernamePrompt(true);
        }
    };

		const handlePurchaseItem = async (itemType, itemId, cost) => {
        if (gold < cost) {
            setToastMessage("Yetersiz altƒ±n!");
            return;
        }

        const newGold = gold - cost;
        const userRef = db.collection("users").doc(username);

        try {
            if (itemType === 'avatar') {
                await userRef.update({
                    gold: newGold,
                    unlockedAvatars: firebase.firestore.FieldValue.arrayUnion(itemId)
                });
                setUnlockedAvatars(prev => [...prev, itemId]);
            } else if (itemType === 'color') {
                await userRef.update({
                    gold: newGold,
                    unlockedColors: firebase.firestore.FieldValue.arrayUnion(itemId)
                });
                setUnlockedColors(prev => [...prev, itemId]);
            }
            setGold(newGold);
            setToastMessage("Ba≈üarƒ±yla satƒ±n alƒ±ndƒ±!");
        } catch (error) {
            console.error("Satƒ±n alma hatasƒ±:", error);
            setToastMessage("Bir hata olu≈ütu.");
        }
    };


        const handleSaveUsername = async (name) => {
        const userRef = db.collection("users").doc(name);
        const doc = await userRef.get();
        if (doc.exists) {
            return false;
        } else {
            await userRef.set({ gold: 0, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
            localStorage.setItem('wordHuntUsername', name);
            setUsername(name);
            setGold(0);
            setShowUsernamePrompt(false);

            if (window.Android && typeof window.Android.saveUsername === 'function') {
                window.Android.saveUsername(name);
            } else if (pendingFCMToken) {
                saveTokenForUser(name, pendingFCMToken, 3, setToastMessage);
            }

            return true;
        }
    };

      const handleStatsChange = React.useCallback((newStats) => {
            saveGameStats(newStats);
            setGameStats(newStats);
            if (username && typeof newStats.gold !== 'undefined' && newStats.gold !== gold) {
                setGold(newStats.gold);
                db.collection("users").doc(username).update({ gold: newStats.gold }).catch(error => console.error("Altƒ±n g√ºncellenirken hata:", error));
            }
        }, [username, gold]); 

     const handleAvatarSelect = async (avatarId) => {
        if (!username) return;

        try {
            await db.collection("users").doc(username).update({
                avatarId: avatarId
            });
            setAvatarId(avatarId);
            setToastMessage("Avatarƒ±n ba≈üarƒ±yla g√ºncellendi!");
            setIsAvatarModalOpen(false);

        } catch (error) {
            console.error("Avatar g√ºncellenirken hata olu≈ütu:", error);
            setToastMessage("Hata: Avatar g√ºncellenemedi.");
        }
    };


const goToHome = React.useCallback(() => {
            if (page === 'lobby' && username) {
                db.collection('lobby').doc(username).delete().catch(() => {});
            } else if (page === 'game' && gameId) {
            }
            setPage('home');
            setGameId(null);
        }, [username, page, gameId]);

const createGameRoom = async (settings) => {
            if (!username) return;
            setToastMessage("Yeni oyun odasƒ± olu≈üturuluyor...");

            const roomRef = db.collection('game_rooms').doc();

            const newRoom = {
                roomId: roomRef.id,
                status: 'waiting',
                host: username,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                gameSettings: {
                    boardSize: settings.boardSize || 'medium',
                    difficulty: settings.difficulty || 'easy', 
                    maxPlayers: parseInt(settings.maxPlayers) || 3,
                },
                players: {
                    [username]: { score: 0, foundWords: [], avatarId: avatarId || 'avatar1', cardColor: cardColor || 'gray', color: 'green', joinedAt: firebase.firestore.FieldValue.serverTimestamp() }
                }
            };

            try {
                await roomRef.set(newRoom);
                setToastMessage("Oda ba≈üarƒ±yla kuruldu!");
                setGameId(roomRef.id);
                setPage('room_lobby');
            } catch (error) {
                console.error("Oda kurulamadƒ±:", error);
                setToastMessage("Hata: Oda olu≈üturulamadƒ±.");
            }
        };

        const joinGameRoom = async (roomIdToJoin) => {
            if (!username) return;
            const roomRef = db.collection('game_rooms').doc(roomIdToJoin);

            try {
                await db.runTransaction(async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists) throw "Bu oda artƒ±k mevcut deƒüil.";

                    const roomData = roomDoc.data();
                    const playerCount = Object.keys(roomData.players).length;

                    if (roomData.status !== 'waiting') throw "Bu oyun √ßoktan ba≈ülamƒ±≈ü veya bitmi≈ü.";
                    if (playerCount >= roomData.gameSettings.maxPlayers) throw "Bu oda dolu.";
                    if (roomData.players[username]) {
                        setToastMessage("Zaten bu odadasƒ±nƒ±z.");
                        setGameId(roomIdToJoin);
                        setPage('room_lobby');
                        return;
                    }
                    
                    const playerColors = ['green', 'red', 'blue', 'purple'];
                    const newPlayerColor = playerColors[playerCount] || 'gray';

                    const newPlayerField = `players.${username}`;
                    transaction.update(roomRef, {
                        [newPlayerField]: {
                            score: 0,
                            foundWords: [],
                            avatarId: avatarId || 'avatar1',
                            cardColor: cardColor || 'gray',
                            color: newPlayerColor,
                            joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                        }
                    });
                });

                setToastMessage("Odaya ba≈üarƒ±yla katƒ±ldƒ±nƒ±z!");
                setGameId(roomIdToJoin);
                setPage('room_lobby');

            } catch (error) {
                console.error("Odaya katƒ±lƒ±rken hata:", error);
                setToastMessage(`Hata: ${error.toString()}`);
            }
        };



const startGame = async (roomId) => {
    const roomRef = db.collection('game_rooms').doc(roomId);
    
    try {
        const roomDoc = await roomRef.get();
        if (!roomDoc.exists) {
            console.error("[startGame] Hata: Oda bulunamadƒ±.");
            setToastMessage("Hata: Oyun odasƒ± bulunamadƒ±.");
            return;
        }
        const roomData = roomDoc.data();

        if (roomData.host !== username) {
            setToastMessage("Sadece oda kurucusu oyunu ba≈ülatabilir!");
            return;
        }

        const boardSize = roomData.gameSettings.boardSize;
        
        const gameConfig = { name: 'multiplayer', boardSize: boardSize, modeType: 'avi' };
        const newBoardData = createBoard(null, language, gameConfig);

        if (!newBoardData) {
            console.error("[startGame] Hata: createBoard fonksiyonu 'null' d√∂nd√ºrd√º.");
            setToastMessage("Hata: Oyun tahtasƒ± olu≈üturulamadƒ±. L√ºtfen tekrar deneyin.");
            return;
        }

        const boardAsMap = {};
        newBoardData.board.forEach((row, index) => {
            boardAsMap[index] = row;
        });

        await roomRef.update({
            status: 'in-progress',
            boardData: { ...newBoardData, board: boardAsMap }
        });
        setPage('game');

    } catch (error) {
        console.error("[startGame] Veritabanƒ± G√úNCELLEME HATASI:", error);
        setToastMessage("Kritik Hata: Oyun veritabanƒ±na yazƒ±lamadƒ±. Konsolu kontrol edin.");
    }
};









        
       const sendDirectInvite = (targetPlayer, boardSize, difficulty) => {
            if (!username || !targetPlayer) return;

            setToastMessage(`${targetPlayer.username} kullanƒ±cƒ±sƒ±na davet g√∂nderiliyor...`);
            
            const gameId = [username, targetPlayer.username].sort().join('_') + `_${Date.now()}`;
            const gameRef = db.collection('game_rooms').doc(gameId);

            const newRoomData = {
                roomId: gameId,
                status: 'invited',
                host: username,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                gameSettings: {
                    boardSize: boardSize || 'medium',
                    difficulty: difficulty || 'easy', 
                    maxPlayers: 2
                },
                players: {
                    [username]: { score: 0, foundWords: [], avatarId: avatarId || 'avatar1', cardColor: cardColor || 'gray', color: 'green' },
                    [targetPlayer.username]: { score: 0, foundWords: [], avatarId: targetPlayer.avatarId || 'avatar1', cardColor: targetPlayer.cardColor || 'gray', color: 'red' }
                }
            };

            gameRef.set(newRoomData).then(() => {
                db.collection('lobby').doc(targetPlayer.username).set({
                    status: 'invited', invitedBy: username, gameId: gameId,
                }, { merge: true });

                db.collection('invites').add({
                    from: username,
                    to: targetPlayer.username,
                    gameId: gameId,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });

                setToastMessage("Davet g√∂nderildi!");
                setGameId(gameId);
                setPage('room_lobby');
            }).catch(error => {
                console.error("Davet g√∂nderilirken hata:", error);
                setToastMessage("Hata: Davet g√∂nderilemedi.");
            });
        };

const handleAcceptDirectInvite = async () => {
            if (!directInvite) return;
            const gameRef = db.collection('game_rooms').doc(directInvite.gameId);
            try {
                const roomDoc = await gameRef.get();
                if (!roomDoc.exists) throw new Error("Oda bulunamadƒ±!");
                const roomData = roomDoc.data();
                const boardSize = roomData.gameSettings.boardSize;
                const newBoardData = createBoard(null, language, null, boardSize);
                if (!newBoardData) throw new Error("Oyun tahtasƒ± olu≈üturulamadƒ±.");

                const boardAsMap = {};
                newBoardData.board.forEach((row, index) => {
                    boardAsMap[index] = row;
                });
                await gameRef.update({
                    status: 'in-progress',
                    boardData: { ...newBoardData, board: boardAsMap }
                });
                await db.collection('lobby').doc(username).update({ status: 'in-game', gameId: directInvite.gameId });
                setGameId(directInvite.gameId);
                setPage('room_lobby'); 
                setDirectInvite(null);

            } catch (error) {
                console.error("Davet kabul edilirken hata:", error);
                setToastMessage("Hata: Oyuna katƒ±lamadƒ±nƒ±z. " + error.message);
            }
        };

        const handleDeclineDirectInvite = async () => {
            if (!directInvite) return;
            await db.collection('game_rooms').doc(directInvite.gameId).delete();
            await db.collection('lobby').doc(directInvite.invitedBy).update({ status: 'idle', gameId: null });
            await db.collection('lobby').doc(username).update({ status: 'idle', gameId: null });
            setDirectInvite(null);
            setToastMessage("Davet reddedildi.");
        };




React.useEffect(() => {
            if (!username || !db) return;

            const userLobbyRef = db.collection('lobby').doc(username);
            const unsubscribe = userLobbyRef.onSnapshot((doc) => {
                const data = doc.data();
                if (data && data.status === 'invited' && data.gameId && data.invitedBy) {
                    setDirectInvite({
                        gameId: data.gameId,
                        invitedBy: data.invitedBy
                    });
                } else {
                    setDirectInvite(null);
                }
            });

            return () => unsubscribe(); 
        }, [username, db]);



        React.useEffect(() => 
        {
            window.androidBridge.handleIncomingDuel = (payloadString) => 
            {
             try {
            const payload = JSON.parse(payloadString);
            if (payload && payload.id && payload.invitedBy) {
                setIncomingInvitation(payload);
            } else {
                console.error("WebAppLog: Ge√ßersiz veya eksik payload.", payload);
            }
                } catch (error) {
            console.error("WebAppLog: Gelen payload i≈ülenirken hata olu≈ütu:", error);
                }
            };
            return () => 
            {window.androidBridge.handleIncomingDuel = null;};
            }, []);


        const handleAndroidBack = React.useCallback(() => {
            const t = translations[language] || translations['en'];
            
            if (page === 'game') {
                // Oyun ekranƒ±ndayken, WordHunt komponentindeki √ßƒ±kƒ±≈ü onayƒ± fonksiyonunu √ßaƒüƒ±rƒ±yoruz.
                // Bu fonksiyonu WordHunt'a bir ref aracƒ±lƒ±ƒüƒ±yla ileteceƒüiz.
                if (wordHuntRef.current && typeof wordHuntRef.current.showExitConfirmation === 'function') {
                    wordHuntRef.current.showExitConfirmation();
                }
            } else if (page === 'home') {
                // Ana sayfadaysak, uygulamadan √ßƒ±kƒ±≈ü onayƒ±nƒ± g√∂ster.
                setModalContent({
                    isOpen: true,
                    title: t.areYouSureTitle,
                    onClose: () => setModalContent({ isOpen: false }),
                    body: (
                        <div className="text-center">
                            <p className="text-lg text-gray-700 mb-6">{t.appQuitBody}</p>
                            <div className="flex justify-center gap-4">
                                <button onClick={() => setModalContent({ isOpen: false })} className="px-8 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600">{t.stayButton}</button>
                                <button onClick={() => { if (window.Android && window.Android.closeApp) { window.Android.closeApp(); } }} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">{t.quitButton}</button>
                            </div>
                        </div>
                    )
                });
            } else {
                // Diƒüer t√ºm sayfalardan geri tu≈üuna basƒ±ldƒ±ƒüƒ±nda ana sayfaya d√∂n.
                goToHome();
            }
        }, [page, goToHome, language]);

        window.androidBridge.handleIncomingDuel = async (duelId) => {
            if (!duelId) return;
            const duelRef = db.collection('active-duels').doc(duelId);
            const duelDoc = await duelRef.get();
            if (duelDoc.exists) {
                setIncomingInvitation({ id: duelDoc.id, ...duelDoc.data() });
            } else {
            }
        };

        React.useEffect(() => {
            if (!username || !db) return;
            const lobbyRef = db.collection('lobby').doc(username);
            const updatePresence = (status) => {
                lobbyRef.set({
                    username: username,
                    presence: status,
                    last_active: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
            };
            updatePresence('online');
            const handleVisibilityChange = () => {
                if (document.visibilityState === 'hidden') {
                    updatePresence('offline');
                } else {
                    updatePresence('online');
                }
            };
            const handleBeforeUnload = () => {
                updatePresence('offline');
            };
            document.addEventListener('visibilitychange', handleVisibilityChange);
            window.addEventListener('beforeunload', handleBeforeUnload);
            return () => {
                document.removeEventListener('visibilitychange', handleVisibilityChange);
                window.removeEventListener('beforeunload', handleBeforeUnload);
            };
        }, [username, db]);

        React.useEffect(() => {
            if (!username) return;
            const requestsRef = db.collection('users').doc(username).collection('friendRequests');
            const unsubscribe = requestsRef.onSnapshot(snapshot => {
                if (!snapshot.empty) {
                    const firstRequest = snapshot.docs[0];
                    setFriendRequest({ id: firstRequest.id, ...firstRequest.data() });
                } else {
                    setFriendRequest(null);
                }
            });
            return () => unsubscribe();
        }, [username, db]);

        const handleColorSelect = async (colorId) => {
            if (!username) return;
            try {
                await db.collection('users').doc(username).update({
                    cardColor: colorId
                });
                setCardColor(colorId);
                setToastMessage("Kart rengin g√ºncellendi!");
            } catch (error) {
                console.error("Kart rengi g√ºncellenirken hata:", error);
            }
        };

        const handleUsernameUpdate = async (newName) => {
            const trimmedName = newName.trim();
            if (!trimmedName || trimmedName === username) {
                setToastMessage("Yeni kullanƒ±cƒ± adƒ± ge√ßerli veya mevcut olanla aynƒ±.");
                return;
            }
            const userRef = db.collection("users").doc(trimmedName);
            const doc = await userRef.get();
            if (doc.exists) {
                setToastMessage("Bu kullanƒ±cƒ± adƒ± zaten alƒ±nmƒ±≈ü.");
                return;
            }
            try {
                const oldUserDoc = await db.collection("users").doc(username).get();
                if(oldUserDoc.exists) {
                    await db.collection("users").doc(trimmedName).set(oldUserDoc.data());
                    await db.collection("users").doc(username).delete();
                    localStorage.setItem('wordHuntUsername', trimmedName);
                    setUsername(trimmedName);
                    setToastMessage("Kullanƒ±cƒ± adƒ±n ba≈üarƒ±yla g√ºncellendi!");
                }
            } catch (error) {
                console.error("Kullanƒ±cƒ± adƒ± g√ºncellenirken hata:", error);
                setToastMessage("Hata: Kullanƒ±cƒ± adƒ± g√ºncellenemedi.");
            }
        };

        const handleAcceptFriendRequest = async () => {
            if (!friendRequest) return;
            const fromUser = friendRequest.from;
            const batch = db.batch();
            const myFriendRef = db.collection('users').doc(username).collection('friends').doc(fromUser);
            batch.set(myFriendRef, { addedAt: firebase.firestore.FieldValue.serverTimestamp() });
            const theirFriendRef = db.collection('users').doc(fromUser).collection('friends').doc(username);
            batch.set(theirFriendRef, { addedAt: firebase.firestore.FieldValue.serverTimestamp() });
            const requestRef = db.collection('users').doc(username).collection('friendRequests').doc(fromUser);
            batch.delete(requestRef);
            try {
                await batch.commit();
                setToastMessage(`${fromUser} ile arkada≈ü oldunuz!`);
                setFriendRequest(null);
            } catch (error) {
                console.error("ƒ∞stek kabul edilemedi:", error);
            }
        };

        const handleDeclineFriendRequest = async () => {
            if (!friendRequest) return;
            const requestRef = db.collection('users').doc(username).collection('friendRequests').doc(friendRequest.from);
            await requestRef.delete();
            setFriendRequest(null);
        };

        React.useEffect(() => {
            if (page === 'game' || page === 'lobby') {
                document.body.classList.add('no-scroll');
            } else {
                document.body.classList.remove('no-scroll');
            }
        }, [page]);

       React.useEffect(() => {
            window.androidBridge.registered_onBackPress = handleAndroidBack;

            const initializeApp = async () => {
                setIsInitializing(true);
                try {
                    if (window.Android && typeof window.Android.getVersionName === 'function') {
                        const appVersion = window.Android.getVersionName();
                        if (appVersion) {
                            window.setAppVersion(appVersion);
                        }
                    }

                    const savedUser = localStorage.getItem('wordHuntUsername');
                    if (savedUser) {
                        await loadUserData(savedUser);
                        if (pendingFCMToken) {
                            saveTokenForUser(savedUser, pendingFCMToken, 3, setToastMessage);
                        }
                    } else {
                        setShowUsernamePrompt(true);
                    }
                } catch (error) {
                    console.error("Uygulama ba≈ülatƒ±lƒ±rken bir hata olu≈ütu:", error);
                } finally {
                    setIsInitializing(false);
                }
            };

            initializeApp();

            return () => {
                window.androidBridge.registered_onBackPress = null;
            };
        }, [handleAndroidBack]);

      

        React.useEffect(() => {
            if (page === 'home') {
                try {
                    const saves = localStorage.getItem(ALL_SAVES_KEY);
                    setAllSaves(saves ? JSON.parse(saves) : { lastPlayed: null });
                } catch (e) {
                    setAllSaves({ lastPlayed: null });
                }
            }
        }, [page]);

        React.useEffect(() => {
            if (toastMessage) {
                const timer = setTimeout(() => setToastMessage(null), 3800);
                return () => clearTimeout(timer);
            }
        }, [toastMessage]);

const startSinglePlayerGame = (selectedMode) => {
            const t = translations[language] || translations['en'];
            
            const isTracking = selectedMode.startsWith('takip-');
            const modeName = isTracking ? selectedMode.substring(6) : selectedMode;
            const modeType = isTracking ? 'takip' : 'avi';

            if (modeName === 'random') {
                const playableModes = ['super-easy', 'easy', 'hard', 'timed-easy', 'timed-hard'];
                const randomModeKey = _.sample(playableModes);
                const keyForTranslation = randomModeKey.replace(/-(\w)/g, (m, l) => l.toUpperCase()) + 'Mode';
                const randomModeName = t[keyForTranslation] || randomModeKey;
                const randomLevel = _.random(0, 89);
                setModalContent({
                    isOpen: true,
                    title: t.randomGameTitle,
                    body: (<div><p className="text-gray-700 text-lg mb-6" dangerouslySetInnerHTML={{ __html: t.randomGameBody(randomModeName, randomLevel + 1) }} /><button onClick={() => {
                        setGameKey(Date.now());
                        setModeConfig({ name: randomModeKey, modeType: modeType, level: randomLevel, isOneShot: true });
                        setPage('game');
                        setModalContent({ isOpen: false });
                    }} className="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg">{t.startButton}</button></div>)
                });
                return;
            }

            const savedGameForMode = allSaves?.[selectedMode];
            if (!savedGameForMode) {
                setGameKey(Date.now());
                setModeConfig({ name: modeName, modeType: modeType });
                setPage('game');
            } else {
                const handleContinue = () => {
                    setGameKey(Date.now());
                    setModeConfig({ name: savedGameForMode.mode, modeType: modeType, level: savedGameForMode.level });
                    setLanguage(savedGameForMode.language);
                    setModalContent({ isOpen: false });
                    setPage('game');
                };
                const handleNewGame = () => {
                    const currentSaves = { ...allSaves };
                    delete currentSaves[selectedMode];
                    localStorage.setItem(ALL_SAVES_KEY, JSON.stringify(currentSaves));
                    setAllSaves(currentSaves);
                    
                    setGameKey(Date.now());
                    setModeConfig({ name: modeName, modeType: modeType });
                    setModalContent({ isOpen: false });
                    setPage('game');
                };

                let modalBgClass = 'from-sky-600 to-indigo-700';
                if (savedGameForMode.mode.includes('super-easy')) {
                    modalBgClass = 'from-purple-600 to-violet-700';
                } else if (savedGameForMode.mode.includes('hard')) {
                    modalBgClass = 'from-red-600 to-rose-700';
                }
                
                setModalContent({
                    isOpen: true,
                    title: '',
                    onClose: () => setModalContent({ isOpen: false }),
                    body: (
                        <div className={`w-full max-w-sm text-white bg-gradient-to-br ${modalBgClass} rounded-2xl shadow-2xl p-6 text-center`}>
                            <div className="text-6xl mb-4">üß≠</div>
                            <h2 className="text-2xl font-bold mb-2">{t.savedGameFoundTitle}</h2>
                            <p className="text-white/80 mb-6" dangerouslySetInnerHTML={{ __html: t.savedGameFoundBody(savedGameForMode.level + 1) }}></p>
                            <div className="flex flex-col gap-3">
                                <button 
                                    onClick={handleContinue}
                                    className="w-full px-8 py-3 bg-amber-500 text-white font-bold rounded-lg hover:bg-amber-400 transition-all transform hover:scale-105 shadow-lg"
                                >
                                    {t.continueButton}
                                </button>
                                <button 
                                    onClick={handleNewGame}
                                    className="w-full px-8 py-2 bg-emerald-600 text-white font-bold rounded-lg hover:bg-emerald-500 transition-all"
                                >
                                    {t.newGameButton}
                                </button>
                            </div>
                        </div>
                    )
                });
            }
        };

	const launchVsComputerGame = (difficulty, boardSize, aiStrength) => { 
            setModalContent({ isOpen: false });
            setGameKey(Date.now());
            setModeConfig({ 
                name: 'vs-computer', 
                difficulty: difficulty, 
                boardSize: boardSize,
                aiStrength: aiStrength 
            });
            setPage('game');
        };

       const openVsComputerSetupModal = () => {
            const VsComputerSetupModal = ({ onStart }) => {
                const [difficulty, setDifficulty] = React.useState('easy');
                const [size, setSize] = React.useState('medium');
                const [aiStrength, setAiStrength] = React.useState('orta');

                const strengthOptions = [
                    { key: 'zayif', label: 'Zayƒ±f', icon: 'üß†' },
                    { key: 'orta', label: 'Orta', icon: 'ü§ì' }, 
                    { key: 'guclu', label: 'G√º√ßl√º', icon: '‚ö°Ô∏è' }
                ];
                const difficultyOptions = [
                    { key: 'easy', label: 'Kolay', icon: 'üß∏' },
                    { key: 'hard', label: 'Zor', icon: 'üî•' },
                ];
                const sizeOptions = [
                    { key: 'small', label: 'K√º√ß√ºk', icon: 'ü§è' },
                    { key: 'medium', label: 'Orta', icon: 'üëå' },
                    { key: 'large', label: 'Geni≈ü', icon: 'üëê' },
                ];
                return (
                    <div className="flex flex-col gap-6 mt-2">
                        <div>
                            <h4 className="font-bold text-lg text-slate-700 mb-3 text-left">Yapay Zek√¢ G√ºc√º</h4>
                            <div className="grid grid-cols-3 gap-3">
                                {strengthOptions.map(opt => (
                                    <button
                                        key={opt.key}
                                        onClick={() => setAiStrength(opt.key)}
                                        className={`p-3 h-24 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${aiStrength === opt.key ? 'bg-gradient-to-br from-amber-400 to-orange-500 text-white ring-4 ring-offset-2 ring-amber-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}
                                    >
                                        <span className="text-3xl">{opt.icon}</span>
                                        <span className="mt-1 text-sm">{opt.label}</span>
                                        {/* Alt yazƒ± (desc) buradan kaldƒ±rƒ±ldƒ± */}
                                    </button>
                                ))}
                            </div>
                        </div>

                        <div>
                            <h4 className="font-bold text-lg text-slate-700 mb-3 text-left">Zorluk Seviyesi</h4>
                            <div className="grid grid-cols-2 gap-3">
                                {difficultyOptions.map(opt => (
                                    <button
                                        key={opt.key}
                                        onClick={() => setDifficulty(opt.key)}
                                        className={`p-3 h-24 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${difficulty === opt.key ? (opt.key === 'easy' ? 'bg-gradient-to-br from-green-400 to-emerald-500' : 'bg-gradient-to-br from-red-500 to-rose-600') + ' text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}
                                    >
                                        <span className="text-4xl">{opt.icon}</span>
                                        <span className="mt-1 text-base">{opt.label}</span>
                                        {/* Alt yazƒ± (desc) buradan kaldƒ±rƒ±ldƒ± */}
                                    </button>
                                ))}
                            </div>
                        </div>

                        <div>
                            <h4 className="font-bold text-lg text-slate-700 mb-3 text-left">Oyun Alanƒ± Boyutu</h4>
                            <div className="grid grid-cols-3 gap-3">
                                {sizeOptions.map(opt => (
                                     <button
                                        key={opt.key}
                                        onClick={() => setSize(opt.key)}
                                        className={`p-3 h-24 rounded-xl font-bold flex flex-col items-center justify-center text-center transition-all transform ${size === opt.key ? 'bg-indigo-600 text-white ring-4 ring-offset-2 ring-indigo-500 scale-105' : 'bg-slate-200 text-slate-800 hover:bg-slate-300'}`}
                                    >
                                        <span className="text-3xl">{opt.icon}</span>
                                        <span className="mt-1 text-sm">{opt.label}</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                        <button
                            onClick={() => onStart(difficulty, size, aiStrength)}
                            className="w-full mt-4 py-3 bg-gradient-to-r from-purple-600 to-indigo-700 text-white font-bold rounded-lg text-lg hover:shadow-xl transition-all transform hover:scale-105"
                        >
                            Ba≈ülat!
                        </button>
                    </div>
                );
            };
            setModalContent({
                isOpen: true,
                title: 'Siz vs. ü§ñ',
                body: <VsComputerSetupModal onStart={launchVsComputerGame} />
            });
        };

        const startGameVsComputer = () => {
        openVsComputerSetupModal();
    };
const statsForWordHunt = React.useMemo(() => {
            return { ...gameStats, gold: gold, username: username };
        }, [gameStats, gold, username]);
        const handleAcceptInvitation = async () => {
            if (!incomingInvitation) return;
            const duelId = incomingInvitation.id;
            const gameRef = db.collection('active-duels').doc(duelId);
            await gameRef.update({ status: 'active' });
            const playerUsernames = Object.keys(incomingInvitation.players);
            const player1Ref = db.collection('lobby').doc(playerUsernames[0]);
            const player2Ref = db.collection('lobby').doc(playerUsernames[1]);
            await player1Ref.update({ status: 'in-game', gameId: duelId });
            await player2Ref.update({ status: 'in-game', gameId: duelId });
            setIncomingInvitation(null);
            setGameId(duelId);
            setPage('game');
        };

        const handleDeclineInvitation = async () => {
            if (!incomingInvitation) return;
            await db.collection('active-duels').doc(incomingInvitation.id).delete();
            setIncomingInvitation(null);
        };

        

        const goToLobby = () => {
            if (username) {
                const lobbyData = {
                    username: username,
                    status: 'idle',
                    joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    last_active: firebase.firestore.FieldValue.serverTimestamp()
                };
                db.collection('lobby').doc(username).set(lobbyData);
                setPage('lobby');
            } else {
                setShowUsernamePrompt(true);
            }
        };

      const openLobbyPage = () => {
            setPage('lobby');
        };

    

        return (
            <ErrorBoundary>
                <div className="h-full w-full overflow-hidden">
                  {page === 'home' && (
                        <HomePage
                            startGame={startSinglePlayerGame}
                            startGameVsComputer={startGameVsComputer}
                            language={language}
                            setLanguage={setLanguage}
                            stats={statsForWordHunt}
                            setModalContent={setModalContent}
                            setLeaderboardModalOpen={setLeaderboardModalOpen} 
                            savedGame={allSaves && allSaves.lastPlayed ? allSaves[allSaves.lastPlayed] : null}
                            username={username}
                            isInitializing={isInitializing}
                            openLobbyPage={openLobbyPage}
                            avatarId={avatarId}
                            openProfileModal={() => setIsProfileModalOpen(true)}
				            cardColor={cardColor} 
                            playerCardColors={playerCardColors}                         />
                    )}
                 {page === 'lobby' && (
                        <DuelLobbyPage
                            username={username}
                            onBack={goToHome}
                            db={db}
                            setToastMessage={setToastMessage}
                            joinGameRoom={joinGameRoom}
                            createGameRoom={createGameRoom}
                            sendDirectInvite={sendDirectInvite}
                        />
                    )}

   

{page === 'room_lobby' && (
    <RoomLobbyPage
        username={username}
        gameId={gameId}
        db={db}
        onBack={goToHome}
        startGame={startGame}
        setPage={setPage}
        setToastMessage={setToastMessage}
        setModeConfig={setModeConfig} 
     />
)}


                    {page === 'game' && (
                        <WordHunt
                            ref={wordHuntRef} 
                            key={gameKey}
                            config={modeConfig}
                            gameId={gameId}
                            username={username}
                            goToHome={goToHome}
                            language={language}
                            stats={{ ...gameStats, gold: gold, username: username }}
                            onStatsChange={handleStatsChange}
                            initialSavedState={allSaves && !gameId ? allSaves[modeConfig.name] : null}
                            toastMessage={toastMessage}
                            setToastMessage={setToastMessage}
                        />
                    )}
                </div>
                <Modal isOpen={modalContent.isOpen} title={modalContent.title} onClose={() => setModalContent({ isOpen: false })}>
                    {modalContent.body}
                </Modal>
                {showUsernamePrompt && <UsernamePrompt onSave={handleSaveUsername} />}
                
          
                {showAppExitModal && (
                    <Modal isOpen={true} title="Oyundan √áƒ±k" onClose={() => setShowAppExitModal(false)}>
                        <div className="text-center">
                            <p className="text-lg text-gray-700 mb-6">Uygulamadan √ßƒ±kmak istediƒüinize emin misiniz?</p>
                            <div className="flex justify-center gap-4">
                                <button onClick={() => setShowAppExitModal(false)} className="px-8 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600">Hayƒ±r</button>
                                <button onClick={() => { if (window.Android && window.Android.closeApp) { window.Android.closeApp(); } }} className="px-8 py-2 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700">Evet</button>
                            </div>
                        </div>
                    </Modal>
                )}
                <AvatarSelectionModal
                    isOpen={isAvatarModalOpen}
                    onClose={() => setIsAvatarModalOpen(false)}
                    onAvatarSelect={handleAvatarSelect}
                />
                <ProfileModal
    isOpen={isProfileModalOpen}
    onClose={() => setIsProfileModalOpen(false)}
    username={username}
    avatarId={avatarId}
    cardColor={cardColor}
    gold={gold}
    unlockedAvatars={unlockedAvatars}
    unlockedColors={unlockedColors}
    onAvatarSelect={handleAvatarSelect}
    onUsernameUpdate={handleUsernameUpdate}
    onColorSelect={handleColorSelect}
    onPurchaseItem={handlePurchaseItem}
    language={language}
/>
                <FriendRequestModal
                    isOpen={!!friendRequest}
                    requestDetails={friendRequest}
                    onAccept={handleAcceptFriendRequest}
                    onDecline={handleDeclineFriendRequest}
                />

<DirectInviteModal
                    isOpen={!!directInvite}
                    invitationDetails={directInvite}
                    onAccept={handleAcceptDirectInvite}
                    onDecline={handleDeclineDirectInvite}
                />


                {toastMessage && (
                    <div className="toast-notification fixed bottom-24 left-1/2 -translate-x-1/2 bg-indigo-600 text-white font-bold py-3 px-6 rounded-full shadow-lg z-[9999]">
                        {toastMessage}
                    </div>
                )}
                {/* Lƒ∞DERLƒ∞K TABLOSU MODALI EKLENDƒ∞ */}
                <LeaderboardModal 
                    isOpen={isLeaderboardModalOpen} 
                    onClose={() => setLeaderboardModalOpen(false)} 
                    currentUser={username} 
                    language={language} 
                />
            </ErrorBoundary>
        );
    }
    window.handleAndroidBackPress = function() {
        if (window.appNavigator && window.appNavigator.getCurrentPage() === 'game') {
            window.appNavigator.goToHome();
            return true;
        }
        return false;
    };
    initializeGame();

</script>
</body>
</html>
